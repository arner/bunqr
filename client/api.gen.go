// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
)

// AdditionalInformation defines model for AdditionalInformation.
type AdditionalInformation struct {
	// Attachment The Attachments to attach to the refund request.
	Attachment []AttachmentMasterCardActionRefund `json:"attachment,omitempty"`

	// Category The category of the refund, required for chargeback.
	Category string `json:"category,omitempty"`

	// Comment Comment about the refund.
	Comment string `json:"comment,omitempty"`

	// Reason The reason to refund, required for chargeback.
	Reason string `json:"reason,omitempty"`

	// TermsAndConditions Proof that the user acknowledged the terms and conditions for chargebacks.
	TermsAndConditions string `json:"terms_and_conditions,omitempty"`
}

// AdditionalTransactionInformationCategory defines model for AdditionalTransactionInformationCategory.
type AdditionalTransactionInformationCategory struct {
	// Category The category.
	Category string `json:"category,omitempty"`

	// Color The color of the category.
	Color string `json:"color,omitempty"`

	// Description The description of the category.
	Description string `json:"description,omitempty"`

	// DescriptionTranslated The translation of the description of the category.
	DescriptionTranslated string `json:"description_translated,omitempty"`

	// Icon The icon of the category.
	Icon string `json:"icon,omitempty"`

	// Order The sort order of the category.
	Order int `json:"order,omitempty"`

	// Status Whether this category is active. Only relevant for user-defined categories.
	Status string `json:"status,omitempty"`

	// Type Who created this category.
	Type string `json:"type,omitempty"`
}

// AdditionalTransactionInformationCategoryListing defines model for AdditionalTransactionInformationCategoryListing.
type AdditionalTransactionInformationCategoryListing struct {
	// Category The category.
	Category string `json:"category,omitempty"`

	// Color The color of the category.
	Color string `json:"color,omitempty"`

	// Description The description of the category.
	Description string `json:"description,omitempty"`

	// DescriptionTranslated The translation of the description of the category.
	DescriptionTranslated string `json:"description_translated,omitempty"`

	// Icon The icon of the category.
	Icon string `json:"icon,omitempty"`

	// Order The sort order of the category.
	Order int `json:"order,omitempty"`

	// Status Whether this category is active. Only relevant for user-defined categories.
	Status string `json:"status,omitempty"`

	// Type Who created this category.
	Type string `json:"type,omitempty"`
}

// AdditionalTransactionInformationCategoryUserDefined defines model for AdditionalTransactionInformationCategoryUserDefined.
type AdditionalTransactionInformationCategoryUserDefined struct {
	// Category The category.
	Category string `json:"category,omitempty"`

	// Color The color of the category.
	Color string `json:"color,omitempty"`

	// Description The description of the category.
	Description string `json:"description,omitempty"`

	// Icon The icon of the category.
	Icon string `json:"icon,omitempty"`

	// Status Whether this category is active. Only relevant for user-defined categories.
	Status string `json:"status,omitempty"`
}

// AdditionalTransactionInformationCategoryUserDefinedCreate defines model for AdditionalTransactionInformationCategoryUserDefinedCreate.
type AdditionalTransactionInformationCategoryUserDefinedCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// Address defines model for Address.
type Address struct {
	// City The city.
	City string `json:"city,omitempty"`

	// Country The country as an ISO 3166-1 alpha-2 country code.
	Country string `json:"country,omitempty"`

	// Extra The apartment, building or other extra information for addresses.
	Extra string `json:"extra,omitempty"`

	// HouseNumber The house number.
	HouseNumber string `json:"house_number,omitempty"`

	// IsUserAddressUpdated To show whether user created or updated her address for app event listing.
	IsUserAddressUpdated bool `json:"is_user_address_updated,omitempty"`

	// MailboxName The name on the mailbox (only used for Postal addresses).
	MailboxName string `json:"mailbox_name,omitempty"`

	// PoBox The PO box.
	PoBox string `json:"po_box,omitempty"`

	// PostalCode The postal code.
	PostalCode string `json:"postal_code,omitempty"`

	// Province The province according to local standard.
	Province string `json:"province,omitempty"`

	// Street The street.
	Street string `json:"street,omitempty"`
}

// Amount defines model for Amount.
type Amount struct {
	// Currency The currency of the amount. It is an ISO 4217 formatted currency code.
	Currency string `json:"currency,omitempty"`

	// Value The amount formatted to two decimal places.
	Value string `json:"value,omitempty"`
}

// Attachment defines model for Attachment.
type Attachment struct {
	// ContentType The content type of the attachment's file.
	ContentType string `json:"content_type,omitempty"`

	// Description The description of the attachment.
	Description string `json:"description,omitempty"`

	// Urls The URLs where the file can be downloaded.
	Urls []AttachmentUrl `json:"urls,omitempty"`
}

// AttachmentConversationContentListing defines model for AttachmentConversationContentListing.
type AttachmentConversationContentListing = map[string]interface{}

// AttachmentMasterCardActionRefund defines model for AttachmentMasterCardActionRefund.
type AttachmentMasterCardActionRefund struct {
	// Id The id of the attached Attachment.
	Id int `json:"id,omitempty"`
}

// AttachmentMonetaryAccount defines model for AttachmentMonetaryAccount.
type AttachmentMonetaryAccount = map[string]interface{}

// AttachmentMonetaryAccountContentListing defines model for AttachmentMonetaryAccountContentListing.
type AttachmentMonetaryAccountContentListing = map[string]interface{}

// AttachmentMonetaryAccountCreate defines model for AttachmentMonetaryAccountCreate.
type AttachmentMonetaryAccountCreate struct {
	// Id The ID of the attachment created.
	Id int `json:"id,omitempty"`
}

// AttachmentMonetaryAccountPayment defines model for AttachmentMonetaryAccountPayment.
type AttachmentMonetaryAccountPayment struct {
	// Id The id of the attached Attachment.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount this Attachment is attached from.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`
}

// AttachmentPublic defines model for AttachmentPublic.
type AttachmentPublic = map[string]interface{}

// AttachmentPublicContentListing defines model for AttachmentPublicContentListing.
type AttachmentPublicContentListing = map[string]interface{}

// AttachmentPublicCreate defines model for AttachmentPublicCreate.
type AttachmentPublicCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// AttachmentPublicRead defines model for AttachmentPublicRead.
type AttachmentPublicRead struct {
	Attachment *Attachment `json:"attachment,omitempty"`

	// Created The timestamp of the attachment's creation.
	Created string `json:"created,omitempty"`

	// Updated The timestamp of the attachment's last update.
	Updated string `json:"updated,omitempty"`

	// Uuid The UUID of the attachment.
	Uuid string `json:"uuid,omitempty"`
}

// AttachmentUrl defines model for AttachmentUrl.
type AttachmentUrl struct {
	// Type The file type of attachment.
	Type string `json:"type,omitempty"`

	// Url The URL where the attachment can be downloaded.
	Url string `json:"url,omitempty"`
}

// AttachmentUserContentListing defines model for AttachmentUserContentListing.
type AttachmentUserContentListing = map[string]interface{}

// AttachmentUserRead defines model for AttachmentUserRead.
type AttachmentUserRead struct {
	Attachment *Attachment `json:"attachment,omitempty"`

	// Created The timestamp of the attachment's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the attachment.
	Id int `json:"id,omitempty"`

	// Updated The timestamp of the attachment's last update.
	Updated string `json:"updated,omitempty"`
}

// Avatar defines model for Avatar.
type Avatar struct {
	// AnchorUuid The public UUID of object this avatar is anchored to.
	AnchorUuid string `json:"anchor_uuid,omitempty"`

	// Image The actual image information of this avatar.
	Image []Image `json:"image,omitempty"`

	// Style The style (if applicable) for this Avatar.
	Style string `json:"style,omitempty"`

	// Uuid The public UUID of the avatar.
	Uuid string `json:"uuid,omitempty"`
}

// AvatarCreate defines model for AvatarCreate.
type AvatarCreate struct {
	// Uuid The UUID of the created avatar.
	Uuid string `json:"uuid,omitempty"`
}

// AvatarRead defines model for AvatarRead.
type AvatarRead struct {
	// Image The content type of the image.
	Image []Image `json:"image,omitempty"`

	// Uuid The UUID of the created avatar.
	Uuid string `json:"uuid,omitempty"`
}

// BankSwitchServiceNetherlandsIncoming defines model for BankSwitchServiceNetherlandsIncoming.
type BankSwitchServiceNetherlandsIncoming struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	Attachment        *Attachment           `json:"attachment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// RejectionReason Rejection reason enum.
	RejectionReason string `json:"rejection_reason,omitempty"`

	// RejectionReasonDescription Rejection reason description to be shown to the user.
	RejectionReasonDescription string `json:"rejection_reason_description,omitempty"`

	// RejectionReasonDescriptionTranslated Rejection reason description to be shown to the user, translated.
	RejectionReasonDescriptionTranslated string `json:"rejection_reason_description_translated,omitempty"`

	// RejectionReasonTogetherUrl Rejection reason together URL.
	RejectionReasonTogetherUrl string `json:"rejection_reason_together_url,omitempty"`

	// Status The status of the switch service.
	Status string `json:"status,omitempty"`

	// SubStatus The sub status of the switch service.
	SubStatus string `json:"sub_status,omitempty"`

	// TimeEnd The timestamp when the switch service ends.
	TimeEnd string `json:"time_end,omitempty"`

	// TimeStartActual The timestamp when the switch service actually starts.
	TimeStartActual string `json:"time_start_actual,omitempty"`

	// TimeStartDesired The timestamp when the switch service desired to be start.
	TimeStartDesired string    `json:"time_start_desired,omitempty"`
	UserAlias        *LabelUser `json:"user_alias,omitempty"`
}

// BankSwitchServiceNetherlandsIncomingPayment defines model for BankSwitchServiceNetherlandsIncomingPayment.
type BankSwitchServiceNetherlandsIncomingPayment struct {
	BankSwitchService *BankSwitchServiceNetherlandsIncoming `json:"bank_switch_service,omitempty"`
	Payment           *Payment                              `json:"payment,omitempty"`
}

// BankSwitchServiceNetherlandsIncomingPaymentRead defines model for BankSwitchServiceNetherlandsIncomingPaymentRead.
type BankSwitchServiceNetherlandsIncomingPaymentRead struct {
	BankSwitchService *BankSwitchServiceNetherlandsIncoming `json:"bank_switch_service,omitempty"`
	Payment           *Payment                              `json:"payment,omitempty"`
}

// BillingContractSubscription defines model for BillingContractSubscription.
type BillingContractSubscription struct {
	// ContractDateEnd The date until when the billing contract is valid.
	ContractDateEnd string `json:"contract_date_end,omitempty"`

	// ContractDateStart The date from when the billing contract is valid.
	ContractDateStart string `json:"contract_date_start,omitempty"`

	// ContractVersion The version of the billing contract.
	ContractVersion int `json:"contract_version,omitempty"`

	// Created The timestamp when the billing contract was made.
	Created string `json:"created,omitempty"`

	// Id The id of the billing contract.
	Id int `json:"id,omitempty"`

	// Status The subscription status.
	Status string `json:"status,omitempty"`

	// SubStatus The subscription substatus.
	SubStatus string `json:"sub_status,omitempty"`

	// SubscriptionType The subscription type of the user. Can be one of PERSON_SUPER_LIGHT_V1, PERSON_LIGHT_V1, PERSON_MORE_V1, PERSON_FREE_V1, PERSON_PREMIUM_V1, COMPANY_V1, or COMPANY_V2.
	SubscriptionType string `json:"subscription_type,omitempty"`

	// SubscriptionTypeDowngrade The subscription type the user will have after a subscription downgrade. Will be null if downgrading is not possible.
	SubscriptionTypeDowngrade string `json:"subscription_type_downgrade,omitempty"`

	// Updated The timestamp when the billing contract was last updated.
	Updated string `json:"updated,omitempty"`
}

// BillingContractSubscriptionListing defines model for BillingContractSubscriptionListing.
type BillingContractSubscriptionListing struct {
	// ContractDateEnd The date until when the billing contract is valid.
	ContractDateEnd string `json:"contract_date_end,omitempty"`

	// ContractDateStart The date from when the billing contract is valid.
	ContractDateStart string `json:"contract_date_start,omitempty"`

	// ContractVersion The version of the billing contract.
	ContractVersion int `json:"contract_version,omitempty"`

	// Created The timestamp when the billing contract was made.
	Created string `json:"created,omitempty"`

	// Id The id of the billing contract.
	Id int `json:"id,omitempty"`

	// Status The subscription status.
	Status string `json:"status,omitempty"`

	// SubStatus The subscription substatus.
	SubStatus string `json:"sub_status,omitempty"`

	// SubscriptionType The subscription type of the user. Can be one of PERSON_SUPER_LIGHT_V1, PERSON_LIGHT_V1, PERSON_MORE_V1, PERSON_FREE_V1, PERSON_PREMIUM_V1, COMPANY_V1, or COMPANY_V2.
	SubscriptionType string `json:"subscription_type,omitempty"`

	// SubscriptionTypeDowngrade The subscription type the user will have after a subscription downgrade. Will be null if downgrading is not possible.
	SubscriptionTypeDowngrade string `json:"subscription_type_downgrade,omitempty"`

	// Updated The timestamp when the billing contract was last updated.
	Updated string `json:"updated,omitempty"`
}

// BirdeeInvestmentPortfolio defines model for BirdeeInvestmentPortfolio.
type BirdeeInvestmentPortfolio struct {
	// Allocations The allocations of the investment portfolio.
	Allocations []BirdeePortfolioAllocation      `json:"allocations,omitempty"`
	Balance     *BirdeeInvestmentPortfolioBalance `json:"balance,omitempty"`

	// ExternalIdentifier The external identifier of the portfolio.
	ExternalIdentifier string                        `json:"external_identifier,omitempty"`
	Goal               *BirdeeInvestmentPortfolioGoal `json:"goal,omitempty"`

	// InvestmentTheme The investment theme.
	InvestmentTheme string `json:"investment_theme,omitempty"`

	// Name The name associated with the investment portfolio.
	Name string `json:"name,omitempty"`

	// NumberOfStrategyChangeAnnualMaximum Maximum number of strategy changes in a year.
	NumberOfStrategyChangeAnnualMaximum int `json:"number_of_strategy_change_annual_maximum,omitempty"`

	// NumberOfStrategyChangeAnnualUsed Maximum number of strategy changes used.
	NumberOfStrategyChangeAnnualUsed int `json:"number_of_strategy_change_annual_used,omitempty"`

	// RiskProfileType The type of risk profile associated with the portfolio.
	RiskProfileType string `json:"risk_profile_type,omitempty"`

	// Status Status of the portfolio.
	Status string `json:"status,omitempty"`
}

// BirdeeInvestmentPortfolioBalance defines model for BirdeeInvestmentPortfolioBalance.
type BirdeeInvestmentPortfolioBalance struct {
	AmountAvailable         Amount `json:"amount_available,omitempty"`
	AmountDepositPending    Amount `json:"amount_deposit_pending,omitempty"`
	AmountDepositTotal      Amount `json:"amount_deposit_total,omitempty"`
	AmountFeeTotal          Amount `json:"amount_fee_total,omitempty"`
	AmountProfit            Amount `json:"amount_profit,omitempty"`
	AmountWithdrawalPending Amount `json:"amount_withdrawal_pending,omitempty"`
	AmountWithdrawalTotal   Amount `json:"amount_withdrawal_total,omitempty"`
}

// BirdeeInvestmentPortfolioGoal defines model for BirdeeInvestmentPortfolioGoal.
type BirdeeInvestmentPortfolioGoal struct {
	AmountTarget Amount `json:"amount_target,omitempty"`

	// TimeEnd The investment goal end time.
	TimeEnd string `json:"time_end,omitempty"`
}

// BirdeePortfolioAllocation defines model for BirdeePortfolioAllocation.
type BirdeePortfolioAllocation struct {
	// Amount Monetary amount of the financial instrument in the portfolio.
	Amount string `json:"amount,omitempty"`

	// InstrumentAssetClass Asset Class of the instrument.
	InstrumentAssetClass string `json:"instrument_asset_class,omitempty"`

	// InstrumentAssetClassName Name of the asset class.
	InstrumentAssetClassName string `json:"instrument_asset_class_name,omitempty"`

	// InstrumentCurrency Currency of the instrument.
	InstrumentCurrency string `json:"instrument_currency,omitempty"`

	// InstrumentIsin ISIN code of the instrument.
	InstrumentIsin string `json:"instrument_isin,omitempty"`

	// InstrumentKeyInformationDocumentUri Key Information Document of the instrument.
	InstrumentKeyInformationDocumentUri string `json:"instrument_key_information_document_uri,omitempty"`

	// InstrumentName Name of the instrument.
	InstrumentName string `json:"instrument_name,omitempty"`

	// InstrumentRegionName Name of the geographical region covered by the instrument
	InstrumentRegionName string `json:"instrument_region_name,omitempty"`

	// Price Unit price of the financial instrument.
	Price string `json:"price,omitempty"`

	// Quantity Quantity of the financial instrument in the portfolio.
	Quantity string `json:"quantity,omitempty"`

	// Weight Weight of the financial instrument in the model portfolio.
	Weight string `json:"weight,omitempty"`
}

// BunqId defines model for BunqId.
type BunqId struct {
	// Id An integer ID of an object. Unique per object type.
	Id int `json:"id,omitempty"`
}

// BunqMeFundraiserProfile defines model for BunqMeFundraiserProfile.
type BunqMeFundraiserProfile struct {
	Alias      *LabelMonetaryAccount `json:"alias,omitempty"`
	Attachment *AttachmentPublic     `json:"attachment,omitempty"`

	// Color The color chosen for the bunq.me fundraiser profile in hexadecimal format.
	Color string `json:"color,omitempty"`

	// Currency The currency of the MonetaryAccount that created the bunq.me fundraiser profile.
	Currency string `json:"currency,omitempty"`

	// Description The description of the bunq.me fundraiser profile.
	Description string `json:"description,omitempty"`

	// InviteProfileName Provided if the user has enabled their invite link.
	InviteProfileName string `json:"invite_profile_name,omitempty"`

	// MerchantAvailable List of available merchants.
	MerchantAvailable []BunqMeMerchantAvailable `json:"merchant_available,omitempty"`
	Pointer           *Pointer                   `json:"pointer,omitempty"`

	// RedirectUrl The URL which the user is sent to when a payment is completed.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// Status The status of the bunq.me fundraiser profile, can be ACTIVE or DEACTIVATED.
	Status string `json:"status,omitempty"`
}

// BunqMeFundraiserProfileUserListing defines model for BunqMeFundraiserProfileUserListing.
type BunqMeFundraiserProfileUserListing struct {
	Alias      *LabelMonetaryAccount `json:"alias,omitempty"`
	Attachment *AttachmentPublic     `json:"attachment,omitempty"`

	// Color The color chosen for the bunq.me fundraiser profile in hexadecimal format.
	Color string `json:"color,omitempty"`

	// Currency The currency of the MonetaryAccount that created the bunq.me fundraiser profile.
	Currency string `json:"currency,omitempty"`

	// Description The description of the bunq.me fundraiser profile.
	Description string `json:"description,omitempty"`

	// MonetaryAccountId Id of the monetary account on which you want to receive bunq.me payments.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// OwnerUserId Id of the user owning the profile.
	OwnerUserId int     `json:"owner_user_id,omitempty"`
	Pointer     *Pointer `json:"pointer,omitempty"`

	// RedirectUrl The URL which the user is sent to when a payment is completed.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// Status The status of the bunq.me fundraiser profile, can be ACTIVE or DEACTIVATED.
	Status string `json:"status,omitempty"`
}

// BunqMeFundraiserProfileUserRead defines model for BunqMeFundraiserProfileUserRead.
type BunqMeFundraiserProfileUserRead struct {
	Alias      *LabelMonetaryAccount `json:"alias,omitempty"`
	Attachment *AttachmentPublic     `json:"attachment,omitempty"`

	// Color The color chosen for the bunq.me fundraiser profile in hexadecimal format.
	Color string `json:"color,omitempty"`

	// Currency The currency of the MonetaryAccount that created the bunq.me fundraiser profile.
	Currency string `json:"currency,omitempty"`

	// Description The description of the bunq.me fundraiser profile.
	Description string `json:"description,omitempty"`

	// MonetaryAccountId Id of the monetary account on which you want to receive bunq.me payments.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// OwnerUserId Id of the user owning the profile.
	OwnerUserId int     `json:"owner_user_id,omitempty"`
	Pointer     *Pointer `json:"pointer,omitempty"`

	// RedirectUrl The URL which the user is sent to when a payment is completed.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// Status The status of the bunq.me fundraiser profile, can be ACTIVE or DEACTIVATED.
	Status string `json:"status,omitempty"`
}

// BunqMeFundraiserResult defines model for BunqMeFundraiserResult.
type BunqMeFundraiserResult struct {
	BunqmeFundraiserProfile *BunqMeFundraiserProfile `json:"bunqme_fundraiser_profile,omitempty"`

	// Created The timestamp when the bunq.me was created.
	Created string `json:"created,omitempty"`

	// Id The id of the bunq.me.
	Id int `json:"id,omitempty"`

	// Payments The list of payments, paid to the bunq.me fundraiser profile.
	Payments []Payment `json:"payments,omitempty"`

	// Updated The timestamp when the bunq.me was last updated.
	Updated string `json:"updated,omitempty"`
}

// BunqMeFundraiserResultRead defines model for BunqMeFundraiserResultRead.
type BunqMeFundraiserResultRead struct {
	BunqmeFundraiserProfile *BunqMeFundraiserProfile `json:"bunqme_fundraiser_profile,omitempty"`

	// Created The timestamp when the bunq.me was created.
	Created string `json:"created,omitempty"`

	// Id The id of the bunq.me.
	Id int `json:"id,omitempty"`

	// Payments The list of payments, paid to the bunq.me fundraiser profile.
	Payments []Payment `json:"payments,omitempty"`

	// Updated The timestamp when the bunq.me was last updated.
	Updated string `json:"updated,omitempty"`
}

// BunqMeMerchantAvailable defines model for BunqMeMerchantAvailable.
type BunqMeMerchantAvailable struct {
	// Available Whether or not the merchant is available for the user.
	Available bool `json:"available,omitempty"`

	// MerchantType A merchant type supported by bunq.me.
	MerchantType string `json:"merchant_type,omitempty"`
}

// BunqMeTab defines model for BunqMeTab.
type BunqMeTab struct {
	BunqmeTabEntry BunqMeTabEntry `json:"bunqme_tab_entry"`

	// EventId The ID of the related event if the bunqMeTab made by 'split' functionality.
	EventId int `json:"event_id,omitempty"`

	// Status The status of the bunq.me. Ignored in POST requests but can be used for cancelling the bunq.me by setting status as CANCELLED with a PUT request.
	Status string `json:"status,omitempty"`
}

// BunqMeTabCreate defines model for BunqMeTabCreate.
type BunqMeTabCreate struct {
	// Id The id of the created bunq.me.
	Id int `json:"id,omitempty"`
}

// BunqMeTabEntry defines model for BunqMeTabEntry.
type BunqMeTabEntry struct {
	Alias          *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountInquired Amount               `json:"amount_inquired,omitempty"`

	// Description The description for the bunq.me. Maximum 9000 characters.
	Description string `json:"description,omitempty"`

	// InviteProfileName Provided if the user has enabled their invite link.
	InviteProfileName string `json:"invite_profile_name,omitempty"`

	// MerchantAvailable List of available merchants.
	MerchantAvailable []BunqMeMerchantAvailable `json:"merchant_available,omitempty"`

	// RedirectUrl The URL which the user is sent to when a payment is completed.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// Status The status of the bunq.me. Can be WAITING_FOR_PAYMENT, CANCELLED or EXPIRED.
	Status string `json:"status,omitempty"`

	// Uuid The uuid of the bunq.me.
	Uuid string `json:"uuid,omitempty"`
}

// BunqMeTabListing defines model for BunqMeTabListing.
type BunqMeTabListing struct {
	AliasMonetaryAccount *LabelMonetaryAccount `json:"alias_monetary_account,omitempty"`

	// BunqmeTabEntries The bunq.me tab entries attached to this bunq.me Tab.
	BunqmeTabEntries []BunqMeTabEntry `json:"bunqme_tab_entries,omitempty"`
	BunqmeTabEntry   *BunqMeTabEntry   `json:"bunqme_tab_entry,omitempty"`

	// BunqmeTabShareUrl The url that points to the bunq.me page.
	BunqmeTabShareUrl string `json:"bunqme_tab_share_url,omitempty"`

	// Created The timestamp when the bunq.me was created.
	Created string `json:"created,omitempty"`

	// Id The id of the created bunq.me.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the bunq.me was sent from.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// ResultInquiries The list of bunq.me result Inquiries successfully made and paid.
	ResultInquiries []BunqMeTabResultInquiry `json:"result_inquiries,omitempty"`

	// Status The status of the bunq.me. Can be WAITING_FOR_PAYMENT, CANCELLED or EXPIRED.
	Status string `json:"status,omitempty"`

	// TimeExpiry The timestamp of when the bunq.me expired or will expire.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Type The type of the bunq.me Tab. Should be BUNQ_ME
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the bunq.me was last updated.
	Updated string `json:"updated,omitempty"`
}

// BunqMeTabRead defines model for BunqMeTabRead.
type BunqMeTabRead struct {
	AliasMonetaryAccount *LabelMonetaryAccount `json:"alias_monetary_account,omitempty"`

	// BunqmeTabEntries The bunq.me tab entries attached to this bunq.me Tab.
	BunqmeTabEntries []BunqMeTabEntry `json:"bunqme_tab_entries,omitempty"`
	BunqmeTabEntry   *BunqMeTabEntry   `json:"bunqme_tab_entry,omitempty"`

	// BunqmeTabShareUrl The url that points to the bunq.me page.
	BunqmeTabShareUrl string `json:"bunqme_tab_share_url,omitempty"`

	// Created The timestamp when the bunq.me was created.
	Created string `json:"created,omitempty"`

	// Id The id of the created bunq.me.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the bunq.me was sent from.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// ResultInquiries The list of bunq.me result Inquiries successfully made and paid.
	ResultInquiries []BunqMeTabResultInquiry `json:"result_inquiries,omitempty"`

	// Status The status of the bunq.me. Can be WAITING_FOR_PAYMENT, CANCELLED or EXPIRED.
	Status string `json:"status,omitempty"`

	// TimeExpiry The timestamp of when the bunq.me expired or will expire.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Type The type of the bunq.me Tab. Should be BUNQ_ME
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the bunq.me was last updated.
	Updated string `json:"updated,omitempty"`
}

// BunqMeTabResultInquiry defines model for BunqMeTabResultInquiry.
type BunqMeTabResultInquiry struct {
	// BunqMeTabId The Id of the bunq.me tab that this BunqMeTabResultInquiry belongs to.
	BunqMeTabId int     `json:"bunq_me_tab_id,omitempty"`
	Payment     *Payment `json:"payment,omitempty"`
}

// BunqMeTabResultResponse defines model for BunqMeTabResultResponse.
type BunqMeTabResultResponse struct {
	Payment *Payment `json:"payment,omitempty"`
}

// BunqMeTabResultResponseRead defines model for BunqMeTabResultResponseRead.
type BunqMeTabResultResponseRead struct {
	Payment *Payment `json:"payment,omitempty"`
}

// BunqMeTabUpdate defines model for BunqMeTabUpdate.
type BunqMeTabUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// Card defines model for Card.
type Card struct {
	// ActivationCode DEPRECATED: Activate a card by setting status to ACTIVE when the order_status is ACCEPTED_FOR_PRODUCTION.
	ActivationCode string `json:"activation_code,omitempty"`

	// CancellationReason The reason for card cancellation.
	CancellationReason string `json:"cancellation_reason,omitempty"`
	CardLimit          Amount `json:"card_limit,omitempty"`
	CardLimitAtm       Amount `json:"card_limit_atm,omitempty"`

	// CountryPermission The countries for which to grant (temporary) permissions to use the card.
	CountryPermission []CardCountryPermission `json:"country_permission,omitempty"`

	// MonetaryAccountIdFallback ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.
	MonetaryAccountIdFallback int `json:"monetary_account_id_fallback,omitempty"`

	// OrderStatus The order status to set for the card. Set to CARD_REQUEST_PENDING to get a virtual card produced.
	OrderStatus string `json:"order_status,omitempty"`

	// PinCode The plaintext pin code. Requests require encryption to be enabled.
	PinCode string `json:"pin_code,omitempty"`

	// PinCodeAssignment Array of Types, PINs, account IDs assigned to the card.
	PinCodeAssignment []CardPinAssignment `json:"pin_code_assignment,omitempty"`

	// PreferredNameOnCard The user's preferred name as it will be on the card.
	PreferredNameOnCard string `json:"preferred_name_on_card,omitempty"`

	// PrimaryAccountNumbers Array of PANs and their attributes.
	PrimaryAccountNumbers []CardPrimaryAccountNumber `json:"primary_account_numbers,omitempty"`

	// SecondLine The second line of text on the card
	SecondLine string `json:"second_line,omitempty"`

	// Status The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN or CANCELLED, and can only be set to LOST/STOLEN/CANCELLED when order status is ACCEPTED_FOR_PRODUCTION/DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Can only be set to DEACTIVATED after initial activation, i.e. order_status is DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Mind that all the possible choices (apart from ACTIVE and DEACTIVATED) are permanent and cannot be changed after.
	Status string `json:"status,omitempty"`
}

// CardBatch defines model for CardBatch.
type CardBatch struct {
	// Cards The cards that need to be updated.
	Cards []CardBatchEntry `json:"cards,omitempty"`
}

// CardBatchCreate defines model for CardBatchCreate.
type CardBatchCreate struct {
	// UpdatedCardIds The ids of the cards that have been updated.
	UpdatedCardIds []BunqId `json:"updated_card_ids,omitempty"`
}

// CardBatchEntry defines model for CardBatchEntry.
type CardBatchEntry struct {
	CardLimit    Amount `json:"card_limit,omitempty"`
	CardLimitAtm Amount `json:"card_limit_atm,omitempty"`

	// CountryPermission The countries for which to grant (temporary) permissions to use the card.
	CountryPermission []CardCountryPermission `json:"country_permission,omitempty"`

	// Id The ID of the card that needs to be updated.
	Id int `json:"id,omitempty"`

	// MonetaryAccountIdFallback ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.
	MonetaryAccountIdFallback int `json:"monetary_account_id_fallback,omitempty"`

	// Status The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN or CANCELLED, and can only be set to LOST/STOLEN/CANCELLED when order status is ACCEPTED_FOR_PRODUCTION/DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Can only be set to DEACTIVATED after initial activation, i.e. order_status is DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Mind that all the possible choices (apart from ACTIVE and DEACTIVATED) are permanent and cannot be changed after.
	Status string `json:"status,omitempty"`
}

// CardBatchReplace defines model for CardBatchReplace.
type CardBatchReplace struct {
	// Cards The cards that need to be replaced.
	Cards []CardBatchReplaceEntry `json:"cards,omitempty"`
}

// CardBatchReplaceCreate defines model for CardBatchReplaceCreate.
type CardBatchReplaceCreate struct {
	// UpdatedCardIds The ids of the cards that have been replaced.
	UpdatedCardIds []BunqId `json:"updated_card_ids,omitempty"`
}

// CardBatchReplaceEntry defines model for CardBatchReplaceEntry.
type CardBatchReplaceEntry struct {
	// Id The ID of the card that needs to be replaced.
	Id int `json:"id,omitempty"`

	// NameOnCard The user's name as it will be on the card. Check 'card-name' for the available card names for a user.
	NameOnCard string `json:"name_on_card,omitempty"`

	// PinCodeAssignment Array of Types, PINs, account IDs assigned to the card.
	PinCodeAssignment []CardPinAssignment `json:"pin_code_assignment,omitempty"`

	// SecondLine The second line on the card.
	SecondLine string `json:"second_line,omitempty"`
}

// CardCountryPermission defines model for CardCountryPermission.
type CardCountryPermission struct {
	// Country The country to allow transactions in (e.g. NL, DE).
	Country string `json:"country,omitempty"`

	// ExpiryTime Expiry time of this rule.
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Id The id of the card country permission entry.
	Id int `json:"id,omitempty"`
}

// CardCredit defines model for CardCredit.
type CardCredit struct {
	Alias *Pointer `json:"alias,omitempty"`

	// FirstLine The first line of text on the card, used as name/description for it. It can contain at most 17 characters and it can be empty.
	FirstLine string `json:"first_line,omitempty"`

	// MonetaryAccountIdFallback ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.
	MonetaryAccountIdFallback int `json:"monetary_account_id_fallback,omitempty"`

	// NameOnCard The user's name as it will be on the card. Check 'card-name' for the available card names for a user.
	NameOnCard string `json:"name_on_card,omitempty"`

	// OrderStatus The order status of this card. Can be CARD_REQUEST_PENDING or VIRTUAL_DELIVERY.
	OrderStatus string `json:"order_status,omitempty"`

	// PinCodeAssignment Array of Types, PINs, account IDs assigned to the card.
	PinCodeAssignment []CardPinAssignment `json:"pin_code_assignment,omitempty"`

	// PreferredNameOnCard The user's preferred name that can be put on the card.
	PreferredNameOnCard string `json:"preferred_name_on_card,omitempty"`

	// ProductType The product type of the card to order.
	ProductType string `json:"product_type,omitempty"`

	// SecondLine The second line of text on the card, used as name/description for it. It can contain at most 17 characters and it can be empty.
	SecondLine string `json:"second_line,omitempty"`

	// Type The type of card to order. Can be MASTERCARD.
	Type string `json:"type,omitempty"`
}

// CardCreditCreate defines model for CardCreditCreate.
type CardCreditCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CardDebit defines model for CardDebit.
type CardDebit struct {
	Alias *Pointer `json:"alias,omitempty"`

	// MonetaryAccountIdFallback ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.
	MonetaryAccountIdFallback int `json:"monetary_account_id_fallback,omitempty"`

	// NameOnCard The user's name as it will be on the card. Check 'card-name' for the available card names for a user.
	NameOnCard string `json:"name_on_card,omitempty"`

	// OrderStatus The order status of this card. Can be CARD_REQUEST_PENDING or VIRTUAL_DELIVERY.
	OrderStatus string `json:"order_status,omitempty"`

	// PinCodeAssignment Array of Types, PINs, account IDs assigned to the card.
	PinCodeAssignment []CardPinAssignment `json:"pin_code_assignment,omitempty"`

	// PreferredNameOnCard The user's preferred name that can be put on the card.
	PreferredNameOnCard string `json:"preferred_name_on_card,omitempty"`

	// ProductType The product type of the card to order.
	ProductType string `json:"product_type,omitempty"`

	// SecondLine The second line of text on the card, used as name/description for it. It can contain at most 17 characters and it can be empty.
	SecondLine string `json:"second_line,omitempty"`

	// Type The type of card to order. Can be MAESTRO or MASTERCARD.
	Type string `json:"type,omitempty"`
}

// CardDebitCreate defines model for CardDebitCreate.
type CardDebitCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CardGeneratedCvc2 defines model for CardGeneratedCvc2.
type CardGeneratedCvc2 struct {
	// Type The type of generated cvc2. Can be STATIC or GENERATED.
	Type string `json:"type,omitempty"`
}

// CardGeneratedCvc2Create defines model for CardGeneratedCvc2Create.
type CardGeneratedCvc2Create struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CardGeneratedCvc2Listing defines model for CardGeneratedCvc2Listing.
type CardGeneratedCvc2Listing struct {
	// Created The timestamp of the cvc code's creation.
	Created string `json:"created,omitempty"`

	// Cvc2 The cvc2 code.
	Cvc2 string `json:"cvc2,omitempty"`

	// ExpiryTime Expiry time of the cvc2.
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Id The id of the cvc code.
	Id int `json:"id,omitempty"`

	// Status The status of the cvc2. Can be AVAILABLE, USED, EXPIRED, BLOCKED.
	Status string `json:"status,omitempty"`

	// Type The type of generated cvc2. Can be STATIC or GENERATED.
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the cvc code's last update.
	Updated string `json:"updated,omitempty"`
}

// CardGeneratedCvc2Read defines model for CardGeneratedCvc2Read.
type CardGeneratedCvc2Read struct {
	// Created The timestamp of the cvc code's creation.
	Created string `json:"created,omitempty"`

	// Cvc2 The cvc2 code.
	Cvc2 string `json:"cvc2,omitempty"`

	// ExpiryTime Expiry time of the cvc2.
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Id The id of the cvc code.
	Id int `json:"id,omitempty"`

	// Status The status of the cvc2. Can be AVAILABLE, USED, EXPIRED, BLOCKED.
	Status string `json:"status,omitempty"`

	// Type The type of generated cvc2. Can be STATIC or GENERATED.
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the cvc code's last update.
	Updated string `json:"updated,omitempty"`
}

// CardGeneratedCvc2Update defines model for CardGeneratedCvc2Update.
type CardGeneratedCvc2Update struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CardListing defines model for CardListing.
type CardListing struct {
	CardGeneratedCvc2 *CardGeneratedCvc2 `json:"card_generated_cvc2,omitempty"`
	CardLimit         Amount            `json:"card_limit,omitempty"`
	CardLimitAtm      Amount            `json:"card_limit_atm,omitempty"`

	// CardMetalMemberSinceDate The date for the member since field on the black metal card.
	CardMetalMemberSinceDate string          `json:"card_metal_member_since_date,omitempty"`
	CardReplacement          *CardReplacement `json:"card_replacement,omitempty"`

	// CardShipmentTrackingUrl A tracking link provided by our shipment provider.
	CardShipmentTrackingUrl string              `json:"card_shipment_tracking_url,omitempty"`
	CompanyEmployeeCard     *CompanyEmployeeCard `json:"company_employee_card,omitempty"`

	// Country The country that is domestic to the card. Defaults to country of residence of user.
	Country string `json:"country,omitempty"`

	// CountryPermission The countries for which to grant (temporary) permissions to use the card.
	CountryPermission []CardCountryPermission `json:"country_permission,omitempty"`

	// Created The timestamp of the card's creation.
	Created string `json:"created,omitempty"`

	// ExpiryDate Expiry date of the card.
	ExpiryDate string `json:"expiry_date,omitempty"`

	// FirstLine The first line of text on the card
	FirstLine string `json:"first_line,omitempty"`

	// Id The id of the card.
	Id int `json:"id,omitempty"`

	// IsCardEligibleForFreeReplacement Whether this card is eligible for a free replacement.
	IsCardEligibleForFreeReplacement bool `json:"is_card_eligible_for_free_replacement,omitempty"`

	// IsLimitedEdition Whether this card is a limited edition metal card.
	IsLimitedEdition            bool                 `json:"is_limited_edition,omitempty"`
	LabelMonetaryAccountCurrent *LabelMonetaryAccount `json:"label_monetary_account_current,omitempty"`
	LabelMonetaryAccountOrdered *LabelMonetaryAccount `json:"label_monetary_account_ordered,omitempty"`
	MonetaryAccount             *MonetaryAccount      `json:"monetary_account,omitempty"`

	// MonetaryAccountIdFallback ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.
	MonetaryAccountIdFallback int `json:"monetary_account_id_fallback,omitempty"`

	// NameOnCard The user's name on the card.
	NameOnCard string `json:"name_on_card,omitempty"`

	// OrderStatus The order status of the card. Can be NEW_CARD_REQUEST_RECEIVED, CARD_REQUEST_PENDING, SENT_FOR_PRODUCTION, ACCEPTED_FOR_PRODUCTION, DELIVERED_TO_CUSTOMER, CARD_UPDATE_REQUESTED, CARD_UPDATE_PENDING, CARD_UPDATE_SENT, CARD_UPDATE_ACCEPTED, VIRTUAL_DELIVERY, NEW_CARD_REQUEST_PENDING_USER_APPROVAL, SENT_FOR_DELIVERY or NEW_CARD_REQUEST_CANCELLED.
	OrderStatus string `json:"order_status,omitempty"`

	// PaymentAccountReference The payment account reference number associated with the card.
	PaymentAccountReference string `json:"payment_account_reference,omitempty"`

	// PinCodeAssignment Array of Types, PINs, account IDs assigned to the card.
	PinCodeAssignment []CardPinAssignment `json:"pin_code_assignment,omitempty"`

	// PreferredNameOnCard The user's preferred name on the card.
	PreferredNameOnCard string `json:"preferred_name_on_card,omitempty"`

	// PrimaryAccountNumbers Array of PANs and their attributes.
	PrimaryAccountNumbers []CardPrimaryAccountNumber `json:"primary_account_numbers,omitempty"`

	// ProductSubType The product sub-type of the card.
	ProductSubType string `json:"product_sub_type,omitempty"`

	// ProductType The product type of the card.
	ProductType string `json:"product_type,omitempty"`

	// PublicUuid The public UUID of the card.
	PublicUuid string `json:"public_uuid,omitempty"`

	// SecondLine The second line of text on the card
	SecondLine string `json:"second_line,omitempty"`

	// Status The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN, CANCELLED, EXPIRED or PIN_TRIES_EXCEEDED.
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the card. Can be NONE or REPLACED.
	SubStatus string `json:"sub_status,omitempty"`

	// SubType The sub-type of the card.
	SubType string `json:"sub_type,omitempty"`

	// Type The type of the card. Can be MAESTRO, MASTERCARD.
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the card's last update.
	Updated string `json:"updated,omitempty"`

	// UserHolderId ID of the user who is holder of the card.
	UserHolderId int `json:"user_holder_id,omitempty"`

	// UserId DEPRECATED. ID of the user who is owner of the card.
	UserId int `json:"user_id,omitempty"`

	// UserOwnerId ID of the user who is owner of the card.
	UserOwnerId int `json:"user_owner_id,omitempty"`
}

// CardNameListing defines model for CardNameListing.
type CardNameListing struct {
	// PossibleCardNameArray All possible variations (of suitable length) of user's legal name for the debit card.
	PossibleCardNameArray []string `json:"possible_card_name_array,omitempty"`
}

// CardPinAssignment defines model for CardPinAssignment.
type CardPinAssignment struct {
	// MonetaryAccountId The ID of the monetary account to assign to this pin for the card.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// PinCode The 4 digit PIN to be assigned to this account.
	PinCode string `json:"pin_code,omitempty"`

	// RoutingType Routing type.
	RoutingType string `json:"routing_type,omitempty"`

	// Status The status of the card pin assignment.
	Status string `json:"status,omitempty"`

	// Type PIN type. Can be PRIMARY, SECONDARY or TERTIARY
	Type string `json:"type,omitempty"`
}

// CardPrimaryAccountNumber defines model for CardPrimaryAccountNumber.
type CardPrimaryAccountNumber struct {
	// Description The description for this PAN.
	Description string `json:"description,omitempty"`

	// FourDigit The last four digits of the PAN.
	FourDigit string `json:"four_digit,omitempty"`

	// Id The ID for this Virtual PAN.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The ID of the monetary account to assign to this PAN, only for Online Cards.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Status The status for this PAN, only for Online Cards.
	Status string `json:"status,omitempty"`

	// Type The type of the PAN.
	Type string `json:"type,omitempty"`

	// Uuid The UUID for this Virtual PAN.
	Uuid string `json:"uuid,omitempty"`
}

// CardRead defines model for CardRead.
type CardRead struct {
	CardGeneratedCvc2 *CardGeneratedCvc2 `json:"card_generated_cvc2,omitempty"`
	CardLimit         Amount            `json:"card_limit,omitempty"`
	CardLimitAtm      Amount            `json:"card_limit_atm,omitempty"`

	// CardMetalMemberSinceDate The date for the member since field on the black metal card.
	CardMetalMemberSinceDate string          `json:"card_metal_member_since_date,omitempty"`
	CardReplacement          *CardReplacement `json:"card_replacement,omitempty"`

	// CardShipmentTrackingUrl A tracking link provided by our shipment provider.
	CardShipmentTrackingUrl string              `json:"card_shipment_tracking_url,omitempty"`
	CompanyEmployeeCard     *CompanyEmployeeCard `json:"company_employee_card,omitempty"`

	// Country The country that is domestic to the card. Defaults to country of residence of user.
	Country string `json:"country,omitempty"`

	// CountryPermission The countries for which to grant (temporary) permissions to use the card.
	CountryPermission []CardCountryPermission `json:"country_permission,omitempty"`

	// Created The timestamp of the card's creation.
	Created string `json:"created,omitempty"`

	// ExpiryDate Expiry date of the card.
	ExpiryDate string `json:"expiry_date,omitempty"`

	// FirstLine The first line of text on the card
	FirstLine string `json:"first_line,omitempty"`

	// Id The id of the card.
	Id int `json:"id,omitempty"`

	// IsCardEligibleForFreeReplacement Whether this card is eligible for a free replacement.
	IsCardEligibleForFreeReplacement bool `json:"is_card_eligible_for_free_replacement,omitempty"`

	// IsLimitedEdition Whether this card is a limited edition metal card.
	IsLimitedEdition            bool                 `json:"is_limited_edition,omitempty"`
	LabelMonetaryAccountCurrent *LabelMonetaryAccount `json:"label_monetary_account_current,omitempty"`
	LabelMonetaryAccountOrdered *LabelMonetaryAccount `json:"label_monetary_account_ordered,omitempty"`
	MonetaryAccount             *MonetaryAccount      `json:"monetary_account,omitempty"`

	// MonetaryAccountIdFallback ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.
	MonetaryAccountIdFallback int `json:"monetary_account_id_fallback,omitempty"`

	// NameOnCard The user's name on the card.
	NameOnCard string `json:"name_on_card,omitempty"`

	// OrderStatus The order status of the card. Can be NEW_CARD_REQUEST_RECEIVED, CARD_REQUEST_PENDING, SENT_FOR_PRODUCTION, ACCEPTED_FOR_PRODUCTION, DELIVERED_TO_CUSTOMER, CARD_UPDATE_REQUESTED, CARD_UPDATE_PENDING, CARD_UPDATE_SENT, CARD_UPDATE_ACCEPTED, VIRTUAL_DELIVERY, NEW_CARD_REQUEST_PENDING_USER_APPROVAL, SENT_FOR_DELIVERY or NEW_CARD_REQUEST_CANCELLED.
	OrderStatus string `json:"order_status,omitempty"`

	// PaymentAccountReference The payment account reference number associated with the card.
	PaymentAccountReference string `json:"payment_account_reference,omitempty"`

	// PinCodeAssignment Array of Types, PINs, account IDs assigned to the card.
	PinCodeAssignment []CardPinAssignment `json:"pin_code_assignment,omitempty"`

	// PreferredNameOnCard The user's preferred name on the card.
	PreferredNameOnCard string `json:"preferred_name_on_card,omitempty"`

	// PrimaryAccountNumbers Array of PANs and their attributes.
	PrimaryAccountNumbers []CardPrimaryAccountNumber `json:"primary_account_numbers,omitempty"`

	// ProductSubType The product sub-type of the card.
	ProductSubType string `json:"product_sub_type,omitempty"`

	// ProductType The product type of the card.
	ProductType string `json:"product_type,omitempty"`

	// PublicUuid The public UUID of the card.
	PublicUuid string `json:"public_uuid,omitempty"`

	// SecondLine The second line of text on the card
	SecondLine string `json:"second_line,omitempty"`

	// Status The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN, CANCELLED, EXPIRED or PIN_TRIES_EXCEEDED.
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the card. Can be NONE or REPLACED.
	SubStatus string `json:"sub_status,omitempty"`

	// SubType The sub-type of the card.
	SubType string `json:"sub_type,omitempty"`

	// Type The type of the card. Can be MAESTRO, MASTERCARD.
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the card's last update.
	Updated string `json:"updated,omitempty"`

	// UserHolderId ID of the user who is holder of the card.
	UserHolderId int `json:"user_holder_id,omitempty"`

	// UserId DEPRECATED. ID of the user who is owner of the card.
	UserId int `json:"user_id,omitempty"`

	// UserOwnerId ID of the user who is owner of the card.
	UserOwnerId int `json:"user_owner_id,omitempty"`
}

// CardReplace defines model for CardReplace.
type CardReplace struct {
	// NameOnCard The user's name as it will be on the card. Check 'card-name' for the available card names for a user.
	NameOnCard string `json:"name_on_card,omitempty"`

	// PinCodeAssignment Array of Types, PINs, account IDs assigned to the card.
	PinCodeAssignment []CardPinAssignment `json:"pin_code_assignment,omitempty"`

	// PreferredNameOnCard The user's preferred name that can be put on the card.
	PreferredNameOnCard string `json:"preferred_name_on_card,omitempty"`

	// SecondLine The second line on the card.
	SecondLine string `json:"second_line,omitempty"`
}

// CardReplaceCreate defines model for CardReplaceCreate.
type CardReplaceCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CardReplacement defines model for CardReplacement.
type CardReplacement struct {
	AddressMain   *Address `json:"address_main,omitempty"`
	AddressPostal *Address `json:"address_postal,omitempty"`

	// CardId The original card that belongs to the CardReplacement.
	CardId int `json:"card_id,omitempty"`

	// CardNewId The new card that replaces the original card in the CardReplacement.
	CardNewId int `json:"card_new_id,omitempty"`

	// Status The status of the CardReplacement.
	Status string `json:"status,omitempty"`
}

// CardUpdate defines model for CardUpdate.
type CardUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CashbackPayoutItem defines model for CashbackPayoutItem.
type CashbackPayoutItem struct {
	Amount Amount `json:"amount,omitempty"`

	// RateApplied The cashback rate.
	RateApplied string `json:"rate_applied,omitempty"`

	// Status The status of the cashback payout item.
	Status              string                                   `json:"status,omitempty"`
	TransactionCategory *AdditionalTransactionInformationCategory `json:"transaction_category,omitempty"`
}

// Certificate defines model for Certificate.
type Certificate struct {
	// Certificate A single certificate in the chain in .PEM format.
	Certificate string `json:"certificate,omitempty"`
}

// CertificatePinned defines model for CertificatePinned.
type CertificatePinned struct {
	// CertificateChain The certificate chain in .PEM format.
	CertificateChain []Certificate `json:"certificate_chain"`
}

// CertificatePinnedCreate defines model for CertificatePinnedCreate.
type CertificatePinnedCreate struct {
	// Id The id generated for the pinned certificate chain.
	Id int `json:"id,omitempty"`
}

// CertificatePinnedDelete defines model for CertificatePinnedDelete.
type CertificatePinnedDelete = map[string]interface{}

// CertificatePinnedListing defines model for CertificatePinnedListing.
type CertificatePinnedListing struct {
	// CertificateChain The certificate chain in .PEM format. Certificates are glued with newline characters.
	CertificateChain string `json:"certificate_chain,omitempty"`

	// Id The id generated for the pinned certificate chain.
	Id int `json:"id,omitempty"`
}

// CertificatePinnedRead defines model for CertificatePinnedRead.
type CertificatePinnedRead struct {
	// CertificateChain The certificate chain in .PEM format. Certificates are glued with newline characters.
	CertificateChain string `json:"certificate_chain,omitempty"`

	// Id The id generated for the pinned certificate chain.
	Id int `json:"id,omitempty"`
}

// CoOwner defines model for CoOwner.
type CoOwner struct {
	Alias *LabelUser `json:"alias,omitempty"`

	// Status Can be: ACCEPTED, REJECTED, PENDING or REVOKED
	Status string `json:"status,omitempty"`
}

// CoOwnerInviteResponse defines model for CoOwnerInviteResponse.
type CoOwnerInviteResponse struct {
	Alias *LabelMonetaryAccount `json:"alias,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner   []CoOwner            `json:"all_co_owner,omitempty"`
	CounterAlias *LabelMonetaryAccount `json:"counter_alias,omitempty"`

	// FreezeStatus The freeze_status of the invite.
	FreezeStatus    string    `json:"freeze_status,omitempty"`
	LabelFreezeUser *LabelUser `json:"label_freeze_user,omitempty"`

	// MonetaryAccountId The ID of the monetaryAccount
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// MonetaryAccountType The extension type of the monetaryAccount
	MonetaryAccountType string `json:"monetary_account_type,omitempty"`

	// Status The status of the invite. Can be PENDING, REVOKED (the user deletes the share inquiry before it's accepted) or ACCEPTED
	Status string `json:"status,omitempty"`
}

// Company defines model for Company.
type Company struct {
	AddressMain   Address `json:"address_main"`
	AddressPostal Address `json:"address_postal"`

	// AvatarUuid The public UUID of the company's avatar.
	AvatarUuid string `json:"avatar_uuid,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string `json:"chamber_of_commerce_number,omitempty"`

	// Country The country where the company is registered.
	Country string `json:"country,omitempty"`

	// LegalForm The company's legal form.
	LegalForm string `json:"legal_form,omitempty"`

	// Name The company name.
	Name string `json:"name,omitempty"`

	// SignupTrackType The type of signup track the user is following.
	SignupTrackType string `json:"signup_track_type,omitempty"`

	// SubscriptionType The subscription type for the company.
	SubscriptionType string `json:"subscription_type,omitempty"`

	// Ubo The names and birth dates of the company's ultimate beneficiary owners. Minimum zero, maximum four.
	Ubo       []Ubo            `json:"ubo,omitempty"`
	VatNumber *CompanyVatNumber `json:"vat_number,omitempty"`

	// VatNumbers All the vat numbers of the company
	VatNumbers []CompanyVatNumber `json:"vat_numbers,omitempty"`
}

// CompanyCreate defines model for CompanyCreate.
type CompanyCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CompanyEmployeeCard defines model for CompanyEmployeeCard.
type CompanyEmployeeCard struct {
	AmountLimitMonthly Amount `json:"amount_limit_monthly,omitempty"`
	AmountSpentMonthly Amount `json:"amount_spent_monthly,omitempty"`
	Card               *Card   `json:"card,omitempty"`

	// CompanyNameOnCard The name of the company that should be displayed on the card.
	CompanyNameOnCard string `json:"company_name_on_card,omitempty"`

	// EmployeeNameOnCard The name of the employee that should be displayed on the card.
	EmployeeNameOnCard string `json:"employee_name_on_card,omitempty"`

	// EmployeePreferredNameOnCard The user's preferred name as it will be on the card.
	EmployeePreferredNameOnCard string `json:"employee_preferred_name_on_card,omitempty"`

	// NumberOfCompanyEmployeeCardReceiptPending The number of transactions that still need a receipt.
	NumberOfCompanyEmployeeCardReceiptPending int    `json:"number_of_company_employee_card_receipt_pending,omitempty"`
	PointerCounterUser                        Pointer `json:"pointer_counter_user"`
	PointerMonetaryAccount                    Pointer `json:"pointer_monetary_account"`

	// ProductType The product type of the card to order.
	ProductType string `json:"product_type,omitempty"`

	// Status The status of the employee card.
	Status string `json:"status,omitempty"`

	// Type The type of card to order.
	Type string `json:"type,omitempty"`
}

// CompanyEmployeeCardReceipt defines model for CompanyEmployeeCardReceipt.
type CompanyEmployeeCardReceipt struct {
	// Status The status of the receipt.
	Status string `json:"status,omitempty"`
}

// CompanyEmployeeSettingAdyenCardTransaction defines model for CompanyEmployeeSettingAdyenCardTransaction.
type CompanyEmployeeSettingAdyenCardTransaction struct {
	// MonetaryAccountPayoutId The ID of the monetary account where Tap to Pay transactions should be paid out to.
	MonetaryAccountPayoutId int    `json:"monetary_account_payout_id,omitempty"`
	PointerCounterUser      Pointer `json:"pointer_counter_user"`

	// Status Whether the user is allowed to use Tap to Pay.
	Status string `json:"status,omitempty"`
}

// CompanyListing defines model for CompanyListing.
type CompanyListing struct {
	UserCompany *UserCompany `json:"UserCompany,omitempty"`
}

// CompanyRead defines model for CompanyRead.
type CompanyRead struct {
	UserCompany *UserCompany `json:"UserCompany,omitempty"`
}

// CompanyUpdate defines model for CompanyUpdate.
type CompanyUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CompanyVatNumber defines model for CompanyVatNumber.
type CompanyVatNumber struct {
	// Country The country of the VAT identification number.
	Country string `json:"country,omitempty"`

	// Type The VAT identification number type.
	Type string `json:"type,omitempty"`

	// Value The VAT identification number number.
	Value string `json:"value,omitempty"`
}

// ConfirmationOfFunds defines model for ConfirmationOfFunds.
type ConfirmationOfFunds struct {
	Amount      Amount  `json:"amount"`
	PointerIban Pointer `json:"pointer_iban"`
}

// ConfirmationOfFundsCreate defines model for ConfirmationOfFundsCreate.
type ConfirmationOfFundsCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CreatePayment defines model for CreatePayment.
type CreatePayment struct {
	Amount Amount `json:"amount"`

	// Attachment The Attachments attached to the Payment.
	Attachment        []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`
	CounterpartyAlias Pointer                             `json:"counterparty_alias"`

	// Description The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.
	Description string `json:"description,omitempty"`
}

// CurrencyCloudBeneficiary defines model for CurrencyCloudBeneficiary.
type CurrencyCloudBeneficiary struct {
	// AllField All fields that were required by CurrencyCloud. Obtained through the CurrencyCloudBeneficiaryRequirement listing.
	AllField []string `json:"all_field,omitempty"`

	// Country The country of the beneficiary.
	Country string `json:"country,omitempty"`

	// Currency The currency of the beneficiary.
	Currency string `json:"currency"`

	// LegalEntityType The legal entity type of the beneficiary.
	LegalEntityType string `json:"legal_entity_type,omitempty"`

	// Name The name of the beneficiary.
	Name string `json:"name"`

	// PaymentType The payment type this requirement is for.
	PaymentType string `json:"payment_type,omitempty"`
}

// CurrencyCloudBeneficiaryCreate defines model for CurrencyCloudBeneficiaryCreate.
type CurrencyCloudBeneficiaryCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CurrencyCloudBeneficiaryListing defines model for CurrencyCloudBeneficiaryListing.
type CurrencyCloudBeneficiaryListing struct {
	// AccountNumber The account number to display for the beneficiary.
	AccountNumber string `json:"account_number,omitempty"`

	// Created The timestamp of the beneficiaries creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the beneficiary.
	Currency string `json:"currency,omitempty"`

	// ExternalIdentifier The external identifier of the beneficiary.
	ExternalIdentifier string `json:"external_identifier,omitempty"`

	// Id The id of the profile.
	Id int `json:"id,omitempty"`

	// Name The name of the beneficiary.
	Name string `json:"name,omitempty"`

	// Updated The timestamp of the beneficiaries last update.
	Updated string `json:"updated,omitempty"`
}

// CurrencyCloudBeneficiaryRead defines model for CurrencyCloudBeneficiaryRead.
type CurrencyCloudBeneficiaryRead struct {
	// AccountNumber The account number to display for the beneficiary.
	AccountNumber string `json:"account_number,omitempty"`

	// Created The timestamp of the beneficiaries creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the beneficiary.
	Currency string `json:"currency,omitempty"`

	// ExternalIdentifier The external identifier of the beneficiary.
	ExternalIdentifier string `json:"external_identifier,omitempty"`

	// Id The id of the profile.
	Id int `json:"id,omitempty"`

	// Name The name of the beneficiary.
	Name string `json:"name,omitempty"`

	// Updated The timestamp of the beneficiaries last update.
	Updated string `json:"updated,omitempty"`
}

// CurrencyCloudBeneficiaryRequirementField defines model for CurrencyCloudBeneficiaryRequirementField.
type CurrencyCloudBeneficiaryRequirementField struct {
	// InputType The type of data to input. Determines the keyboard to display.
	InputType string `json:"input_type,omitempty"`

	// Label The label to display for the field.
	Label string `json:"label,omitempty"`

	// Name The name of the field.
	Name string `json:"name,omitempty"`

	// ValidationExpression The expression to validate field input.
	ValidationExpression string `json:"validation_expression,omitempty"`
}

// CurrencyCloudBeneficiaryRequirementListing defines model for CurrencyCloudBeneficiaryRequirementListing.
type CurrencyCloudBeneficiaryRequirementListing struct {
	// AllField The fields that are required.
	AllField []CurrencyCloudBeneficiaryRequirementField `json:"all_field,omitempty"`

	// LegalEntityType The entity type this requirement is for.
	LegalEntityType string `json:"legal_entity_type,omitempty"`

	// PaymentType The payment type this requirement is for.
	PaymentType string `json:"payment_type,omitempty"`
}

// CurrencyCloudPaymentQuote defines model for CurrencyCloudPaymentQuote.
type CurrencyCloudPaymentQuote struct {
	// Pointers The points we want to know the fees for.
	Pointers []Pointer `json:"pointers,omitempty"`
}

// CurrencyCloudPaymentQuoteCreate defines model for CurrencyCloudPaymentQuoteCreate.
type CurrencyCloudPaymentQuoteCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CurrencyConversion defines model for CurrencyConversion.
type CurrencyConversion struct {
	Amount                      Amount               `json:"amount,omitempty"`
	CounterAmount               Amount               `json:"counter_amount,omitempty"`
	CounterLabelMonetaryAccount *LabelMonetaryAccount `json:"counter_label_monetary_account,omitempty"`

	// Created The timestamp of the conversion's creation.
	Created string `json:"created,omitempty"`

	// DateDeliveryExpected The expected delivery date of the conversion.
	DateDeliveryExpected string `json:"date_delivery_expected,omitempty"`

	// GroupUuid The group uuid of the conversion.
	GroupUuid string `json:"group_uuid,omitempty"`

	// Id The id of the conversion.
	Id                   int                  `json:"id,omitempty"`
	LabelMonetaryAccount *LabelMonetaryAccount `json:"label_monetary_account,omitempty"`

	// OrderType The order type, buying or selling.
	OrderType string  `json:"order_type,omitempty"`
	Payment   *Payment `json:"payment,omitempty"`

	// Rate The rate of the conversion.
	Rate string `json:"rate,omitempty"`

	// Status The status of the conversion.
	Status string `json:"status,omitempty"`

	// Type The type of this conversion.
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the conversion's last update.
	Updated string `json:"updated,omitempty"`
}

// CurrencyConversionListing defines model for CurrencyConversionListing.
type CurrencyConversionListing struct {
	Amount                      Amount               `json:"amount,omitempty"`
	CounterAmount               Amount               `json:"counter_amount,omitempty"`
	CounterLabelMonetaryAccount *LabelMonetaryAccount `json:"counter_label_monetary_account,omitempty"`

	// Created The timestamp of the conversion's creation.
	Created string `json:"created,omitempty"`

	// DateDeliveryExpected The expected delivery date of the conversion.
	DateDeliveryExpected string `json:"date_delivery_expected,omitempty"`

	// GroupUuid The group uuid of the conversion.
	GroupUuid string `json:"group_uuid,omitempty"`

	// Id The id of the conversion.
	Id                   int                  `json:"id,omitempty"`
	LabelMonetaryAccount *LabelMonetaryAccount `json:"label_monetary_account,omitempty"`

	// OrderType The order type, buying or selling.
	OrderType string  `json:"order_type,omitempty"`
	Payment   *Payment `json:"payment,omitempty"`

	// Rate The rate of the conversion.
	Rate string `json:"rate,omitempty"`

	// Status The status of the conversion.
	Status string `json:"status,omitempty"`

	// Type The type of this conversion.
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the conversion's last update.
	Updated string `json:"updated,omitempty"`
}

// CurrencyConversionQuote defines model for CurrencyConversionQuote.
type CurrencyConversionQuote struct {
	Amount            Amount  `json:"amount"`
	CounterpartyAlias Pointer `json:"counterparty_alias"`

	// CurrencySource The currency we are converting.
	CurrencySource string `json:"currency_source,omitempty"`

	// CurrencyTarget The currency we are converting towards.
	CurrencyTarget string `json:"currency_target,omitempty"`

	// OrderType The type of the quote, SELL or BUY.
	OrderType string `json:"order_type,omitempty"`

	// Status The status of the quote.
	Status string `json:"status,omitempty"`
}

// CurrencyConversionQuoteCreate defines model for CurrencyConversionQuoteCreate.
type CurrencyConversionQuoteCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CurrencyConversionQuoteRead defines model for CurrencyConversionQuoteRead.
type CurrencyConversionQuoteRead struct {
	AmountSource Amount `json:"amount_source,omitempty"`
	AmountTarget Amount `json:"amount_target,omitempty"`

	// Created The timestamp of the quote's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the quote.
	Id int `json:"id,omitempty"`

	// Rate The conversion rate.
	Rate string `json:"rate,omitempty"`

	// Status The status of the quote.
	Status string `json:"status,omitempty"`

	// TimeExpiry Timestamp for when this quote expires and the user should request a new one.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Updated The timestamp of the quote's last update.
	Updated string `json:"updated,omitempty"`
}

// CurrencyConversionQuoteUpdate defines model for CurrencyConversionQuoteUpdate.
type CurrencyConversionQuoteUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CurrencyConversionRead defines model for CurrencyConversionRead.
type CurrencyConversionRead struct {
	Amount                      Amount               `json:"amount,omitempty"`
	CounterAmount               Amount               `json:"counter_amount,omitempty"`
	CounterLabelMonetaryAccount *LabelMonetaryAccount `json:"counter_label_monetary_account,omitempty"`

	// Created The timestamp of the conversion's creation.
	Created string `json:"created,omitempty"`

	// DateDeliveryExpected The expected delivery date of the conversion.
	DateDeliveryExpected string `json:"date_delivery_expected,omitempty"`

	// GroupUuid The group uuid of the conversion.
	GroupUuid string `json:"group_uuid,omitempty"`

	// Id The id of the conversion.
	Id                   int                  `json:"id,omitempty"`
	LabelMonetaryAccount *LabelMonetaryAccount `json:"label_monetary_account,omitempty"`

	// OrderType The order type, buying or selling.
	OrderType string  `json:"order_type,omitempty"`
	Payment   *Payment `json:"payment,omitempty"`

	// Rate The rate of the conversion.
	Rate string `json:"rate,omitempty"`

	// Status The status of the conversion.
	Status string `json:"status,omitempty"`

	// Type The type of this conversion.
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the conversion's last update.
	Updated string `json:"updated,omitempty"`
}

// Customer defines model for Customer.
type Customer struct {
	// BillingAccountId The primary billing account account's id.
	BillingAccountId string `json:"billing_account_id,omitempty"`

	// Created The timestamp of the customer object's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the customer.
	Id int `json:"id,omitempty"`

	// InvoiceNotificationPreference The preferred notification type for invoices.
	InvoiceNotificationPreference string `json:"invoice_notification_preference,omitempty"`

	// Updated The timestamp of the customer object's last update.
	Updated string `json:"updated,omitempty"`
}

// CustomerLimit defines model for CustomerLimit.
type CustomerLimit struct {
	LimitAmountMonthly Amount `json:"limit_amount_monthly,omitempty"`

	// LimitCardDebitMaestro The limit of Maestro cards.
	LimitCardDebitMaestro int `json:"limit_card_debit_maestro,omitempty"`

	// LimitCardDebitMastercard The limit of MasterCard cards.
	LimitCardDebitMastercard int `json:"limit_card_debit_mastercard,omitempty"`

	// LimitCardDebitWildcard DEPRECTATED: The limit of wildcards, e.g. Maestro or MasterCard cards.
	LimitCardDebitWildcard int `json:"limit_card_debit_wildcard,omitempty"`

	// LimitCardReplacement The limit of free replacement cards.
	LimitCardReplacement int `json:"limit_card_replacement,omitempty"`

	// LimitCardWildcard The limit of wildcards, e.g. Maestro or MasterCard cards.
	LimitCardWildcard int `json:"limit_card_wildcard,omitempty"`

	// LimitMonetaryAccount The limit of monetary accounts.
	LimitMonetaryAccount int `json:"limit_monetary_account,omitempty"`

	// LimitMonetaryAccountRemaining The amount of additional monetary accounts you can create.
	LimitMonetaryAccountRemaining int    `json:"limit_monetary_account_remaining,omitempty"`
	SpentAmountMonthly            Amount `json:"spent_amount_monthly,omitempty"`
}

// CustomerLimitListing defines model for CustomerLimitListing.
type CustomerLimitListing struct {
	LimitAmountMonthly Amount `json:"limit_amount_monthly,omitempty"`

	// LimitCardDebitMaestro The limit of Maestro cards.
	LimitCardDebitMaestro int `json:"limit_card_debit_maestro,omitempty"`

	// LimitCardDebitMastercard The limit of MasterCard cards.
	LimitCardDebitMastercard int `json:"limit_card_debit_mastercard,omitempty"`

	// LimitCardDebitWildcard DEPRECTATED: The limit of wildcards, e.g. Maestro or MasterCard cards.
	LimitCardDebitWildcard int `json:"limit_card_debit_wildcard,omitempty"`

	// LimitCardReplacement The limit of free replacement cards.
	LimitCardReplacement int `json:"limit_card_replacement,omitempty"`

	// LimitCardWildcard The limit of wildcards, e.g. Maestro or MasterCard cards.
	LimitCardWildcard int `json:"limit_card_wildcard,omitempty"`

	// LimitMonetaryAccount The limit of monetary accounts.
	LimitMonetaryAccount int `json:"limit_monetary_account,omitempty"`

	// LimitMonetaryAccountRemaining The amount of additional monetary accounts you can create.
	LimitMonetaryAccountRemaining int    `json:"limit_monetary_account_remaining,omitempty"`
	SpentAmountMonthly            Amount `json:"spent_amount_monthly,omitempty"`
}

// DeviceListing defines model for DeviceListing.
type DeviceListing struct {
	DeviceServer *DeviceServer `json:"DeviceServer,omitempty"`
}

// DeviceRead defines model for DeviceRead.
type DeviceRead struct {
	DeviceServer *DeviceServer `json:"DeviceServer,omitempty"`
}

// DeviceServer defines model for DeviceServer.
type DeviceServer struct {
	// Description The description of the DeviceServer. This is only for your own reference when reading the DeviceServer again.
	Description string `json:"description"`

	// PermittedIps An array of IPs (v4 or v6) this DeviceServer will be able to do calls from. These will be linked to the API key.
	PermittedIps []string `json:"permitted_ips,omitempty"`

	// Secret The API key. You can request an API key in the bunq app.
	Secret string `json:"secret,omitempty"`
}

// DeviceServerCreate defines model for DeviceServerCreate.
type DeviceServerCreate struct {
	Id *BunqId `json:"id,omitempty"`
}

// DeviceServerListing defines model for DeviceServerListing.
type DeviceServerListing struct {
	// Created The timestamp of the DeviceServer's creation.
	Created string `json:"created,omitempty"`

	// Description The description of the DeviceServer.
	Description string `json:"description,omitempty"`

	// Id The id of the DeviceServer as created on the server.
	Id int `json:"id,omitempty"`

	// Ip The ip address which was used to create the DeviceServer.
	Ip string `json:"ip,omitempty"`

	// Status The status of the DeviceServer. Can be ACTIVE, BLOCKED, NEEDS_CONFIRMATION or OBSOLETE.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the DeviceServer's last update.
	Updated string `json:"updated,omitempty"`
}

// DeviceServerRead defines model for DeviceServerRead.
type DeviceServerRead struct {
	// Created The timestamp of the DeviceServer's creation.
	Created string `json:"created,omitempty"`

	// Description The description of the DeviceServer.
	Description string `json:"description,omitempty"`

	// Id The id of the DeviceServer as created on the server.
	Id int `json:"id,omitempty"`

	// Ip The ip address which was used to create the DeviceServer.
	Ip string `json:"ip,omitempty"`

	// Status The status of the DeviceServer. Can be ACTIVE, BLOCKED, NEEDS_CONFIRMATION or OBSOLETE.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the DeviceServer's last update.
	Updated string `json:"updated,omitempty"`
}

// DraftPayment defines model for DraftPayment.
type DraftPayment struct {
	// Entries The list of entries in the DraftPayment. Each entry will result in a payment when the DraftPayment is accepted.
	Entries []DraftPaymentEntry `json:"entries"`

	// NumberOfRequiredAccepts The number of accepts that are required for the draft payment to receive status ACCEPTED. Currently only 1 is valid.
	NumberOfRequiredAccepts int `json:"number_of_required_accepts,omitempty"`

	// PreviousUpdatedTimestamp The last updated_timestamp that you received for this DraftPayment. This needs to be provided to prevent race conditions.
	PreviousUpdatedTimestamp string   `json:"previous_updated_timestamp,omitempty"`
	Schedule                 *Schedule `json:"schedule,omitempty"`

	// Status The status of the DraftPayment.
	Status string `json:"status,omitempty"`
}

// DraftPaymentAnchorObject defines model for DraftPaymentAnchorObject.
type DraftPaymentAnchorObject struct {
	Payment      *Payment      `json:"Payment,omitempty"`
	PaymentBatch *PaymentBatch `json:"PaymentBatch,omitempty"`
}

// DraftPaymentCreate defines model for DraftPaymentCreate.
type DraftPaymentCreate struct {
	// Id The id of the created DrafPayment.
	Id int `json:"id,omitempty"`
}

// DraftPaymentEntry defines model for DraftPaymentEntry.
type DraftPaymentEntry struct {
	Alias  *LabelMonetaryAccount `json:"alias,omitempty"`
	Amount Amount               `json:"amount,omitempty"`

	// Attachment The Attachments attached to the DraftPayment.
	Attachment        []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount               `json:"counterparty_alias,omitempty"`

	// Description The description for the DraftPayment. Maximum 140 characters for DraftPayments to external IBANs, 9000 characters for DraftPayments to only other bunq MonetaryAccounts.
	Description string `json:"description,omitempty"`

	// Id The id of the draft payment entry.
	Id int `json:"id,omitempty"`

	// MerchantReference Optional data to be included with the Payment specific to the merchant.
	MerchantReference string `json:"merchant_reference,omitempty"`

	// Type The type of the draft payment entry.
	Type string `json:"type,omitempty"`
}

// DraftPaymentListing defines model for DraftPaymentListing.
type DraftPaymentListing struct {
	// Entries The entries in the DraftPayment.
	Entries []DraftPaymentEntry `json:"entries,omitempty"`

	// Id The id of the created DrafPayment.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the DraftPayment applies to.
	MonetaryAccountId int                      `json:"monetary_account_id,omitempty"`
	Object            *DraftPaymentAnchorObject `json:"object,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// Responses All responses to this draft payment.
	Responses []DraftPaymentResponse `json:"responses,omitempty"`
	Schedule  *Schedule               `json:"schedule,omitempty"`

	// Status The status of the DraftPayment.
	Status string `json:"status,omitempty"`

	// Type The type of the DraftPayment.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// DraftPaymentRead defines model for DraftPaymentRead.
type DraftPaymentRead struct {
	// Entries The entries in the DraftPayment.
	Entries []DraftPaymentEntry `json:"entries,omitempty"`

	// Id The id of the created DrafPayment.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the DraftPayment applies to.
	MonetaryAccountId int                      `json:"monetary_account_id,omitempty"`
	Object            *DraftPaymentAnchorObject `json:"object,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// Responses All responses to this draft payment.
	Responses []DraftPaymentResponse `json:"responses,omitempty"`
	Schedule  *Schedule               `json:"schedule,omitempty"`

	// Status The status of the DraftPayment.
	Status string `json:"status,omitempty"`

	// Type The type of the DraftPayment.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// DraftPaymentResponse defines model for DraftPaymentResponse.
type DraftPaymentResponse struct {
	// Status The status with which was responded.
	Status           string    `json:"status,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// DraftPaymentUpdate defines model for DraftPaymentUpdate.
type DraftPaymentUpdate struct {
	// Id The id of the created DrafPayment.
	Id int `json:"id,omitempty"`
}

// Error defines model for Error.
type Error = []struct {
	// ErrorDescription The error description in English.
	ErrorDescription string `json:"error_description,omitempty"`

	// ErrorDescriptionTranslated The error description translated to the user's language.
	ErrorDescriptionTranslated string `json:"error_description_translated,omitempty"`
}

// Event defines model for Event.
type Event struct {
	// Action The performed action. Can be: CREATE or UPDATE.
	Action string `json:"action,omitempty"`

	// Created The timestamp of the event's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the event.
	Id int `json:"id,omitempty"`

	// IsEventLatestForObject Indicator whether this is the latest event for the object.
	IsEventLatestForObject bool `json:"is_event_latest_for_object,omitempty"`

	// IsEventReassignable Indicator whether this is event can be reassigned to another Monetary Account.
	IsEventReassignable bool `json:"is_event_reassignable,omitempty"`

	// MonetaryAccountId The id of the monetary account the event applied to (if it was a monetary account event).
	MonetaryAccountId string      `json:"monetary_account_id,omitempty"`
	Object            *EventObject `json:"object,omitempty"`
	ObjectDataAtEvent *EventObject `json:"object_data_at_event,omitempty"`

	// Status The event status. Can be: FINALIZED or AWAITING_REPLY. An example of FINALIZED event is a payment received event, while an AWAITING_REPLY event is a request received event.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the event's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the user the event applied to (if it was a user event).
	UserId string `json:"user_id,omitempty"`
}

// EventListing defines model for EventListing.
type EventListing struct {
	// Action The performed action. Can be: CREATE or UPDATE.
	Action string `json:"action,omitempty"`

	// Created The timestamp of the event's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the event.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the event applied to (if it was a monetary account event).
	MonetaryAccountId string      `json:"monetary_account_id,omitempty"`
	Object            *EventObject `json:"object,omitempty"`

	// Status The event status. Can be: FINALIZED or AWAITING_REPLY. An example of FINALIZED event is a payment received event, while an AWAITING_REPLY event is a request received event.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the event's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the user the event applied to (if it was a user event).
	UserId string `json:"user_id,omitempty"`
}

// EventObject defines model for EventObject.
type EventObject struct {
	BankSwitchServiceNetherlandsIncomingPayment *BankSwitchServiceNetherlandsIncomingPayment `json:"BankSwitchServiceNetherlandsIncomingPayment,omitempty"`
	BunqMeFundraiserResult                      *BunqMeFundraiserResult                      `json:"BunqMeFundraiserResult,omitempty"`
	BunqMeTab                                   *BunqMeTab                                   `json:"BunqMeTab,omitempty"`
	BunqMeTabResultResponse                     *BunqMeTabResultResponse                     `json:"BunqMeTabResultResponse,omitempty"`
	Card                                        *Card                                        `json:"Card,omitempty"`
	CardDebit                                   *CardDebit                                   `json:"CardDebit,omitempty"`
	DraftPayment                                *DraftPayment                                `json:"DraftPayment,omitempty"`
	FeatureAnnouncement                         *FeatureAnnouncement                         `json:"FeatureAnnouncement,omitempty"`
	IdealMerchantTransaction                    *IdealMerchantTransaction                    `json:"IdealMerchantTransaction,omitempty"`
	Invoice                                     *Invoice                                     `json:"Invoice,omitempty"`
	MasterCardAction                            *MasterCardAction                            `json:"MasterCardAction,omitempty"`
	Payment                                     *Payment                                     `json:"Payment,omitempty"`
	PaymentBatch                                *PaymentBatch                                `json:"PaymentBatch,omitempty"`
	RequestInquiry                              *RequestInquiry                              `json:"RequestInquiry,omitempty"`
	RequestInquiryBatch                         *RequestInquiryBatch                         `json:"RequestInquiryBatch,omitempty"`
	RequestResponse                             *RequestResponse                             `json:"RequestResponse,omitempty"`
	ScheduledInstance                           *ScheduleInstance                            `json:"ScheduledInstance,omitempty"`
	ScheduledPayment                            *SchedulePayment                             `json:"ScheduledPayment,omitempty"`
	ScheduledPaymentBatch                       *SchedulePaymentBatch                        `json:"ScheduledPaymentBatch,omitempty"`
	ShareInviteBankInquiry                      *ShareInviteMonetaryAccountInquiry           `json:"ShareInviteBankInquiry,omitempty"`
	ShareInviteBankResponse                     *ShareInviteMonetaryAccountResponse          `json:"ShareInviteBankResponse,omitempty"`
	SofortMerchantTransaction                   *SofortMerchantTransaction                   `json:"SofortMerchantTransaction,omitempty"`
	TransferwisePayment                         *TransferwiseTransfer                        `json:"TransferwisePayment,omitempty"`
}

// EventRead defines model for EventRead.
type EventRead struct {
	// Action The performed action. Can be: CREATE or UPDATE.
	Action string `json:"action,omitempty"`

	// Created The timestamp of the event's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the event.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the event applied to (if it was a monetary account event).
	MonetaryAccountId string      `json:"monetary_account_id,omitempty"`
	Object            *EventObject `json:"object,omitempty"`

	// Status The event status. Can be: FINALIZED or AWAITING_REPLY. An example of FINALIZED event is a payment received event, while an AWAITING_REPLY event is a request received event.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the event's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the user the event applied to (if it was a user event).
	UserId string `json:"user_id,omitempty"`
}

// ExportAnnualOverview defines model for ExportAnnualOverview.
type ExportAnnualOverview struct {
	// Year The year for which the overview is.
	Year int `json:"year"`
}

// ExportAnnualOverviewContentListing defines model for ExportAnnualOverviewContentListing.
type ExportAnnualOverviewContentListing = map[string]interface{}

// ExportAnnualOverviewCreate defines model for ExportAnnualOverviewCreate.
type ExportAnnualOverviewCreate struct {
	// Id The id of the annual overview as created on the server.
	Id int `json:"id,omitempty"`
}

// ExportAnnualOverviewDelete defines model for ExportAnnualOverviewDelete.
type ExportAnnualOverviewDelete = map[string]interface{}

// ExportAnnualOverviewListing defines model for ExportAnnualOverviewListing.
type ExportAnnualOverviewListing struct {
	AliasUser *LabelUser `json:"alias_user,omitempty"`

	// Created The timestamp of the annual overview 's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the annual overview as created on the server.
	Id int `json:"id,omitempty"`

	// Updated The timestamp of the annual overview 's last update.
	Updated string `json:"updated,omitempty"`

	// Year The year for which the overview is.
	Year int `json:"year,omitempty"`
}

// ExportAnnualOverviewRead defines model for ExportAnnualOverviewRead.
type ExportAnnualOverviewRead struct {
	AliasUser *LabelUser `json:"alias_user,omitempty"`

	// Created The timestamp of the annual overview 's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the annual overview as created on the server.
	Id int `json:"id,omitempty"`

	// Updated The timestamp of the annual overview 's last update.
	Updated string `json:"updated,omitempty"`

	// Year The year for which the overview is.
	Year int `json:"year,omitempty"`
}

// ExportRib defines model for ExportRib.
type ExportRib = map[string]interface{}

// ExportRibContentListing defines model for ExportRibContentListing.
type ExportRibContentListing = map[string]interface{}

// ExportRibCreate defines model for ExportRibCreate.
type ExportRibCreate struct {
	// Id The id of the rib as created on the server.
	Id int `json:"id,omitempty"`
}

// ExportRibDelete defines model for ExportRibDelete.
type ExportRibDelete = map[string]interface{}

// ExportRibListing defines model for ExportRibListing.
type ExportRibListing struct {
	// Created The timestamp of the RIB's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the rib as created on the server.
	Id int `json:"id,omitempty"`

	// Updated The timestamp of the RIB's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportRibRead defines model for ExportRibRead.
type ExportRibRead struct {
	// Created The timestamp of the RIB's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the rib as created on the server.
	Id int `json:"id,omitempty"`

	// Updated The timestamp of the RIB's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatement defines model for ExportStatement.
type ExportStatement struct {
	// DateEnd The end date for making statements.
	DateEnd string `json:"date_end"`

	// DateStart The start date for making statements.
	DateStart string `json:"date_start"`

	// IncludeAttachment Only for PDF exports. Includes attachments to mutations in the export, such as scanned receipts.
	IncludeAttachment bool `json:"include_attachment,omitempty"`

	// RegionalFormat Required for CSV exports. The regional format of the statement, can be UK_US (comma-separated) or EUROPEAN (semicolon-separated).
	RegionalFormat string `json:"regional_format,omitempty"`

	// StatementFormat The format type of statement. Allowed values: MT940, CSV, PDF.
	StatementFormat string `json:"statement_format"`
}

// ExportStatementCardContentListing defines model for ExportStatementCardContentListing.
type ExportStatementCardContentListing = map[string]interface{}

// ExportStatementCardCsv defines model for ExportStatementCardCsv.
type ExportStatementCardCsv struct {
	// DateEnd The end date for making statements.
	DateEnd string `json:"date_end"`

	// DateStart The start date for making statements.
	DateStart string `json:"date_start"`

	// RegionalFormat Required for CSV exports. The regional format of the statement, can be UK_US (comma-separated) or EUROPEAN (semicolon-separated).
	RegionalFormat string `json:"regional_format"`
}

// ExportStatementCardCsvCreate defines model for ExportStatementCardCsvCreate.
type ExportStatementCardCsvCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// ExportStatementCardCsvDelete defines model for ExportStatementCardCsvDelete.
type ExportStatementCardCsvDelete = map[string]interface{}

// ExportStatementCardCsvListing defines model for ExportStatementCardCsvListing.
type ExportStatementCardCsvListing struct {
	// CardId The card for which this statement was created.
	CardId int `json:"card_id,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// RegionalFormat The regional format of a CSV statement.
	RegionalFormat string `json:"regional_format,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementCardCsvRead defines model for ExportStatementCardCsvRead.
type ExportStatementCardCsvRead struct {
	// CardId The card for which this statement was created.
	CardId int `json:"card_id,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// RegionalFormat The regional format of a CSV statement.
	RegionalFormat string `json:"regional_format,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementCardListing defines model for ExportStatementCardListing.
type ExportStatementCardListing struct {
	// CardId The card for which this statement was created.
	CardId int `json:"card_id,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// RegionalFormat The regional format of a CSV statement.
	RegionalFormat string `json:"regional_format,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementCardPdf defines model for ExportStatementCardPdf.
type ExportStatementCardPdf struct {
	// DateEnd The end date for making statements.
	DateEnd string `json:"date_end"`

	// DateStart The start date for making statements.
	DateStart string `json:"date_start"`
}

// ExportStatementCardPdfCreate defines model for ExportStatementCardPdfCreate.
type ExportStatementCardPdfCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// ExportStatementCardPdfDelete defines model for ExportStatementCardPdfDelete.
type ExportStatementCardPdfDelete = map[string]interface{}

// ExportStatementCardPdfListing defines model for ExportStatementCardPdfListing.
type ExportStatementCardPdfListing struct {
	// CardId The card for which this statement was created.
	CardId int `json:"card_id,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementCardPdfRead defines model for ExportStatementCardPdfRead.
type ExportStatementCardPdfRead struct {
	// CardId The card for which this statement was created.
	CardId int `json:"card_id,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementCardRead defines model for ExportStatementCardRead.
type ExportStatementCardRead struct {
	// CardId The card for which this statement was created.
	CardId int `json:"card_id,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// RegionalFormat The regional format of a CSV statement.
	RegionalFormat string `json:"regional_format,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementContentListing defines model for ExportStatementContentListing.
type ExportStatementContentListing = map[string]interface{}

// ExportStatementCreate defines model for ExportStatementCreate.
type ExportStatementCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// ExportStatementDelete defines model for ExportStatementDelete.
type ExportStatementDelete = map[string]interface{}

// ExportStatementListing defines model for ExportStatementListing.
type ExportStatementListing struct {
	AliasMonetaryAccount *LabelMonetaryAccount `json:"alias_monetary_account,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// RegionalFormat The regional format of a CSV statement.
	RegionalFormat string `json:"regional_format,omitempty"`

	// StatementFormat The format of statement.
	StatementFormat string `json:"statement_format,omitempty"`

	// StatementNumber MT940 Statement number. Unique per monetary account.
	StatementNumber int `json:"statement_number,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementPayment defines model for ExportStatementPayment.
type ExportStatementPayment = map[string]interface{}

// ExportStatementPaymentContentListing defines model for ExportStatementPaymentContentListing.
type ExportStatementPaymentContentListing = map[string]interface{}

// ExportStatementPaymentCreate defines model for ExportStatementPaymentCreate.
type ExportStatementPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// ExportStatementPaymentRead defines model for ExportStatementPaymentRead.
type ExportStatementPaymentRead struct {
	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the single payment statement model.
	Id int `json:"id,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// ExportStatementRead defines model for ExportStatementRead.
type ExportStatementRead struct {
	AliasMonetaryAccount *LabelMonetaryAccount `json:"alias_monetary_account,omitempty"`

	// Created The timestamp of the statement model's creation.
	Created string `json:"created,omitempty"`

	// DateEnd The date until which statement shows transactions.
	DateEnd string `json:"date_end,omitempty"`

	// DateStart The date from when this statement shows transactions.
	DateStart string `json:"date_start,omitempty"`

	// Id The id of the customer statement model.
	Id int `json:"id,omitempty"`

	// RegionalFormat The regional format of a CSV statement.
	RegionalFormat string `json:"regional_format,omitempty"`

	// StatementFormat The format of statement.
	StatementFormat string `json:"statement_format,omitempty"`

	// StatementNumber MT940 Statement number. Unique per monetary account.
	StatementNumber int `json:"statement_number,omitempty"`

	// Status The status of the export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the statement model's last update.
	Updated string `json:"updated,omitempty"`
}

// FeatureAnnouncement defines model for FeatureAnnouncement.
type FeatureAnnouncement struct {
	Avatar *Avatar `json:"avatar,omitempty"`

	// SubTitle The event overview subtitle of the feature display
	SubTitle string `json:"sub_title,omitempty"`

	// Title The event overview title of the feature display
	Title string `json:"title,omitempty"`

	// Type The type of the feature announcement so apps can override with their own stuff if desired
	Type string `json:"type,omitempty"`
}

// FeatureAnnouncementRead defines model for FeatureAnnouncementRead.
type FeatureAnnouncementRead struct {
	Avatar *Avatar `json:"avatar,omitempty"`

	// SubTitle The event overview subtitle of the feature display
	SubTitle string `json:"sub_title,omitempty"`

	// Title The event overview title of the feature display
	Title string `json:"title,omitempty"`

	// Type The type of the feature announcement so apps can override with their own stuff if desired
	Type string `json:"type,omitempty"`
}

// Fulfillment defines model for Fulfillment.
type Fulfillment struct {
	// AllStatusAllowed The allowed statusses for this fulfillment.
	AllStatusAllowed []string `json:"all_status_allowed,omitempty"`

	// Reason The reason why this fulfillment is requested.
	Reason string `json:"reason,omitempty"`

	// ReasonTranslated The translated reason why this fulfillment is requested.
	ReasonTranslated string `json:"reason_translated,omitempty"`

	// Status Status of this fulfillment.
	Status string `json:"status,omitempty"`

	// TimeMandatory Time when the information fulfillment becomes mandatory.
	TimeMandatory string `json:"time_mandatory,omitempty"`

	// Type Type of the information fulfillment.
	Type string `json:"type,omitempty"`

	// UserId The user id this fulfillment is required for.
	UserId int `json:"user_id,omitempty"`
}

// Geolocation defines model for Geolocation.
type Geolocation struct {
	// Altitude The altitude for a geolocation restriction.
	Altitude *float32 `json:"altitude,omitempty"`

	// Latitude The latitude for a geolocation restriction.
	Latitude *float32 `json:"latitude,omitempty"`

	// Longitude The longitude for a geolocation restriction.
	Longitude *float32 `json:"longitude,omitempty"`

	// Radius The radius for a geolocation restriction.
	Radius *float32 `json:"radius,omitempty"`
}

// GinmonTransaction defines model for GinmonTransaction.
type GinmonTransaction struct {
	AmountBilling               Amount               `json:"amount_billing,omitempty"`
	AmountBillingOriginal       Amount               `json:"amount_billing_original,omitempty"`
	CounterLabelMonetaryAccount *LabelMonetaryAccount `json:"counter_label_monetary_account,omitempty"`

	// EventId The id of the event of transaction.
	EventId int `json:"event_id,omitempty"`

	// ExternalIdentifier External identifier of this order at Ginmon.
	ExternalIdentifier string `json:"external_identifier,omitempty"`

	// Isin The ISIN of the security.
	Isin                 string               `json:"isin,omitempty"`
	LabelMonetaryAccount *LabelMonetaryAccount `json:"label_monetary_account,omitempty"`
	LabelUser            *LabelUser            `json:"label_user,omitempty"`

	// Status The status of the transaction.
	Status string `json:"status,omitempty"`

	// StatusDescription The status of the transaction.
	StatusDescription string `json:"status_description,omitempty"`

	// StatusDescriptionTranslated The translated status of the transaction.
	StatusDescriptionTranslated string `json:"status_description_translated,omitempty"`
}

// IdealMerchantTransaction defines model for IdealMerchantTransaction.
type IdealMerchantTransaction struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountGuaranteed  Amount               `json:"amount_guaranteed,omitempty"`
	AmountRequested   Amount               `json:"amount_requested,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Expiration When the transaction will expire.
	Expiration string `json:"expiration,omitempty"`

	// Issuer The BIC of the issuer.
	Issuer string `json:"issuer,omitempty"`

	// IssuerAuthenticationUrl The URL to visit to
	IssuerAuthenticationUrl string `json:"issuer_authentication_url,omitempty"`

	// IssuerName The Name of the issuer.
	IssuerName string `json:"issuer_name,omitempty"`

	// MonetaryAccountId The id of the monetary account this ideal merchant transaction links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// PurchaseIdentifier The 'purchase ID' of the iDEAL transaction.
	PurchaseIdentifier string `json:"purchase_identifier,omitempty"`

	// Status The status of the transaction.
	Status string `json:"status,omitempty"`

	// StatusTimestamp When the status was last updated.
	StatusTimestamp string `json:"status_timestamp,omitempty"`

	// TransactionIdentifier The 'transaction ID' of the iDEAL transaction.
	TransactionIdentifier string `json:"transaction_identifier,omitempty"`
}

// IdealMerchantTransactionCreate defines model for IdealMerchantTransactionCreate.
type IdealMerchantTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// IdealMerchantTransactionListing defines model for IdealMerchantTransactionListing.
type IdealMerchantTransactionListing struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountGuaranteed  Amount               `json:"amount_guaranteed,omitempty"`
	AmountRequested   Amount               `json:"amount_requested,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Expiration When the transaction will expire.
	Expiration string `json:"expiration,omitempty"`

	// Issuer The BIC of the issuer.
	Issuer string `json:"issuer,omitempty"`

	// IssuerAuthenticationUrl The URL to visit to
	IssuerAuthenticationUrl string `json:"issuer_authentication_url,omitempty"`

	// IssuerName The Name of the issuer.
	IssuerName string `json:"issuer_name,omitempty"`

	// MonetaryAccountId The id of the monetary account this ideal merchant transaction links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// PurchaseIdentifier The 'purchase ID' of the iDEAL transaction.
	PurchaseIdentifier string `json:"purchase_identifier,omitempty"`

	// Status The status of the transaction.
	Status string `json:"status,omitempty"`

	// StatusTimestamp When the status was last updated.
	StatusTimestamp string `json:"status_timestamp,omitempty"`

	// TransactionIdentifier The 'transaction ID' of the iDEAL transaction.
	TransactionIdentifier string `json:"transaction_identifier,omitempty"`
}

// IdealMerchantTransactionRead defines model for IdealMerchantTransactionRead.
type IdealMerchantTransactionRead struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountGuaranteed  Amount               `json:"amount_guaranteed,omitempty"`
	AmountRequested   Amount               `json:"amount_requested,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Expiration When the transaction will expire.
	Expiration string `json:"expiration,omitempty"`

	// Issuer The BIC of the issuer.
	Issuer string `json:"issuer,omitempty"`

	// IssuerAuthenticationUrl The URL to visit to
	IssuerAuthenticationUrl string `json:"issuer_authentication_url,omitempty"`

	// IssuerName The Name of the issuer.
	IssuerName string `json:"issuer_name,omitempty"`

	// MonetaryAccountId The id of the monetary account this ideal merchant transaction links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// PurchaseIdentifier The 'purchase ID' of the iDEAL transaction.
	PurchaseIdentifier string `json:"purchase_identifier,omitempty"`

	// Status The status of the transaction.
	Status string `json:"status,omitempty"`

	// StatusTimestamp When the status was last updated.
	StatusTimestamp string `json:"status_timestamp,omitempty"`

	// TransactionIdentifier The 'transaction ID' of the iDEAL transaction.
	TransactionIdentifier string `json:"transaction_identifier,omitempty"`
}

// Image defines model for Image.
type Image struct {
	// AttachmentPublicUuid The public UUID of the public attachment containing the image.
	AttachmentPublicUuid string `json:"attachment_public_uuid,omitempty"`

	// ContentType The content-type as a MIME filetype.
	ContentType string `json:"content_type,omitempty"`

	// Height The image height in pixels.
	Height int `json:"height,omitempty"`

	// Urls The URLs where the file can be downloaded.
	Urls []AttachmentUrl `json:"urls,omitempty"`

	// Width The image width in pixels.
	Width int `json:"width,omitempty"`
}

// InsightEventListing defines model for InsightEventListing.
type InsightEventListing struct {
	// Action The performed action. Can be: CREATE or UPDATE.
	Action string `json:"action,omitempty"`

	// Created The timestamp of the event's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the event.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the event applied to (if it was a monetary account event).
	MonetaryAccountId string      `json:"monetary_account_id,omitempty"`
	Object            *EventObject `json:"object,omitempty"`

	// Status The event status. Can be: FINALIZED or AWAITING_REPLY. An example of FINALIZED event is a payment received event, while an AWAITING_REPLY event is a request received event.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the event's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the user the event applied to (if it was a user event).
	UserId string `json:"user_id,omitempty"`
}

// InsightListing defines model for InsightListing.
type InsightListing struct {
	AmountTotal Amount `json:"amount_total,omitempty"`

	// Category The category.
	Category string `json:"category,omitempty"`

	// CategoryColor The color of the category.
	CategoryColor string `json:"category_color,omitempty"`

	// CategoryIcon The icon of the category.
	CategoryIcon string `json:"category_icon,omitempty"`

	// CategoryTranslated The translated category.
	CategoryTranslated string `json:"category_translated,omitempty"`

	// NumberOfTransactions The number of the transactions in the category.
	NumberOfTransactions int `json:"number_of_transactions,omitempty"`
}

// InsightPreferenceDateListing defines model for InsightPreferenceDateListing.
type InsightPreferenceDateListing struct {
	// DayOfMonth The day of month at which budgeting/insights should start.
	DayOfMonth int `json:"day_of_month,omitempty"`
}

// Installation defines model for Installation.
type Installation struct {
	// ClientPublicKey Your public key. This is the public part of the key pair that you are going to use to create value of the "X-Bunq-Client-Signature" header for all future API calls.
	ClientPublicKey string `json:"client_public_key,omitempty"`
}

// InstallationCreate defines model for InstallationCreate.
type InstallationCreate struct {
	Id              *BunqId                      `json:"Id,omitempty"`
	ServerPublicKey *InstallationServerPublicKey `json:"ServerPublicKey,omitempty"`
	Token           *InstallationToken           `json:"Token,omitempty"`
}

// InstallationListing defines model for InstallationListing.
type InstallationListing struct {
	// Id The id of the Installation as created on the server. You can use this id to request the server's public key again.
	Id int `json:"id,omitempty"`
}

// InstallationRead defines model for InstallationRead.
type InstallationRead struct {
	// Id The id of the Installation as created on the server. You can use this id to request the server's public key again.
	Id int `json:"id,omitempty"`
}

// InstallationServerPublicKey defines model for InstallationServerPublicKey.
type InstallationServerPublicKey struct {
	// ServerPublicKey The server's public key for this Installation. You should use this key to verify the "X-Bunq-Server-Signature" header for each response from the server.
	ServerPublicKey string `json:"server_public_key,omitempty"`
}

// InstallationServerPublicKeyListing defines model for InstallationServerPublicKeyListing.
type InstallationServerPublicKeyListing struct {
	// ServerPublicKey The server's public key for this Installation.
	ServerPublicKey string `json:"server_public_key,omitempty"`
}

// InstallationToken defines model for InstallationToken.
type InstallationToken struct {
	// Created The timestamp of the Token's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the Token.
	Id int `json:"id,omitempty"`

	// Token The installation token is the token the client has to provide in the "X-Bunq-Client-Authentication" header for the creation of a DeviceServer and SessionServer.
	Token string `json:"token,omitempty"`

	// Updated The timestamp of the Token's last update.
	Updated string `json:"updated,omitempty"`
}

// Invoice defines model for Invoice.
type Invoice struct {
	Address *Address              `json:"address,omitempty"`
	Alias   *LabelMonetaryAccount `json:"alias,omitempty"`

	// Category The category to display to the user.
	Category string `json:"category,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string               `json:"chamber_of_commerce_number,omitempty"`
	CounterpartyAddress     *Address              `json:"counterparty_address,omitempty"`
	CounterpartyAlias       *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the invoice object's creation.
	Created string `json:"created,omitempty"`

	// Description The description provided by the admin.
	Description string `json:"description,omitempty"`

	// ExternalUrl The external url provided by the admin.
	ExternalUrl string `json:"external_url,omitempty"`

	// Group The invoice item groups.
	Group []InvoiceItemGroup `json:"group,omitempty"`

	// Id The id of the invoice object.
	Id int `json:"id,omitempty"`

	// InvoiceDate The invoice date.
	InvoiceDate string `json:"invoice_date,omitempty"`

	// InvoiceNumber The invoice number.
	InvoiceNumber string `json:"invoice_number,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// Status The invoice status.
	Status            string `json:"status,omitempty"`
	TotalVat          Amount `json:"total_vat,omitempty"`
	TotalVatExclusive Amount `json:"total_vat_exclusive,omitempty"`
	TotalVatInclusive Amount `json:"total_vat_inclusive,omitempty"`

	// Updated The timestamp of the invoice object's last update.
	Updated string `json:"updated,omitempty"`

	// VatNumber The company's chamber of commerce number.
	VatNumber string `json:"vat_number,omitempty"`
}

// InvoiceByUserListing defines model for InvoiceByUserListing.
type InvoiceByUserListing struct {
	Address *Address              `json:"address,omitempty"`
	Alias   *LabelMonetaryAccount `json:"alias,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string               `json:"chamber_of_commerce_number,omitempty"`
	CounterpartyAddress     *Address              `json:"counterparty_address,omitempty"`
	CounterpartyAlias       *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the invoice object's creation.
	Created string `json:"created,omitempty"`

	// Group The invoice item groups.
	Group []InvoiceItemGroup `json:"group,omitempty"`

	// Id The id of the invoice object.
	Id int `json:"id,omitempty"`

	// InvoiceDate The invoice date.
	InvoiceDate string `json:"invoice_date,omitempty"`

	// InvoiceNumber The invoice number.
	InvoiceNumber string `json:"invoice_number,omitempty"`

	// Status The invoice status.
	Status            string `json:"status,omitempty"`
	TotalVat          Amount `json:"total_vat,omitempty"`
	TotalVatExclusive Amount `json:"total_vat_exclusive,omitempty"`
	TotalVatInclusive Amount `json:"total_vat_inclusive,omitempty"`

	// Updated The timestamp of the invoice object's last update.
	Updated string `json:"updated,omitempty"`

	// VatNumber The company's chamber of commerce number.
	VatNumber string `json:"vat_number,omitempty"`
}

// InvoiceByUserRead defines model for InvoiceByUserRead.
type InvoiceByUserRead struct {
	Address *Address              `json:"address,omitempty"`
	Alias   *LabelMonetaryAccount `json:"alias,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string               `json:"chamber_of_commerce_number,omitempty"`
	CounterpartyAddress     *Address              `json:"counterparty_address,omitempty"`
	CounterpartyAlias       *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the invoice object's creation.
	Created string `json:"created,omitempty"`

	// Group The invoice item groups.
	Group []InvoiceItemGroup `json:"group,omitempty"`

	// Id The id of the invoice object.
	Id int `json:"id,omitempty"`

	// InvoiceDate The invoice date.
	InvoiceDate string `json:"invoice_date,omitempty"`

	// InvoiceNumber The invoice number.
	InvoiceNumber string `json:"invoice_number,omitempty"`

	// Status The invoice status.
	Status            string `json:"status,omitempty"`
	TotalVat          Amount `json:"total_vat,omitempty"`
	TotalVatExclusive Amount `json:"total_vat_exclusive,omitempty"`
	TotalVatInclusive Amount `json:"total_vat_inclusive,omitempty"`

	// Updated The timestamp of the invoice object's last update.
	Updated string `json:"updated,omitempty"`

	// VatNumber The company's chamber of commerce number.
	VatNumber string `json:"vat_number,omitempty"`
}

// InvoiceExportPdf defines model for InvoiceExportPdf.
type InvoiceExportPdf = map[string]interface{}

// InvoiceExportPdfContentListing defines model for InvoiceExportPdfContentListing.
type InvoiceExportPdfContentListing = map[string]interface{}

// InvoiceExportPdfCreate defines model for InvoiceExportPdfCreate.
type InvoiceExportPdfCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// InvoiceExportPdfDelete defines model for InvoiceExportPdfDelete.
type InvoiceExportPdfDelete = map[string]interface{}

// InvoiceExportPdfRead defines model for InvoiceExportPdfRead.
type InvoiceExportPdfRead struct {
	// Created The timestamp of the invoice export's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the invoice export model.
	Id int `json:"id,omitempty"`

	// Status The status of the invoice export.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the invoice export's last update.
	Updated string `json:"updated,omitempty"`
}

// InvoiceExportPdfUpdate defines model for InvoiceExportPdfUpdate.
type InvoiceExportPdfUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// InvoiceItem defines model for InvoiceItem.
type InvoiceItem struct {
	// BillingDate The billing date of the item.
	BillingDate string `json:"billing_date,omitempty"`

	// Id The id of the invoice item.
	Id int `json:"id,omitempty"`

	// Quantity The number of items priced.
	Quantity          int    `json:"quantity,omitempty"`
	TotalVatExclusive Amount `json:"total_vat_exclusive,omitempty"`
	TotalVatInclusive Amount `json:"total_vat_inclusive,omitempty"`

	// TypeDescription The price description.
	TypeDescription string `json:"type_description,omitempty"`

	// TypeDescriptionTranslated The translated price description.
	TypeDescriptionTranslated string `json:"type_description_translated,omitempty"`
	UnitVatExclusive          Amount `json:"unit_vat_exclusive,omitempty"`
	UnitVatInclusive          Amount `json:"unit_vat_inclusive,omitempty"`

	// Vat The VAT tax fraction.
	Vat int `json:"vat,omitempty"`
}

// InvoiceItemGroup defines model for InvoiceItemGroup.
type InvoiceItemGroup struct {
	// InstanceDescription The identifier of the invoice item group.
	InstanceDescription string `json:"instance_description,omitempty"`

	// Item The invoice items in the group.
	Item                []InvoiceItem `json:"item,omitempty"`
	ProductVatExclusive Amount        `json:"product_vat_exclusive,omitempty"`
	ProductVatInclusive Amount        `json:"product_vat_inclusive,omitempty"`

	// Type The type of the invoice item group.
	Type string `json:"type,omitempty"`

	// TypeDescription The description of the type of the invoice item group.
	TypeDescription string `json:"type_description,omitempty"`

	// TypeDescriptionTranslated The translated description of the type of the invoice item group.
	TypeDescriptionTranslated string `json:"type_description_translated,omitempty"`
}

// InvoiceListing defines model for InvoiceListing.
type InvoiceListing struct {
	Address *Address              `json:"address,omitempty"`
	Alias   *LabelMonetaryAccount `json:"alias,omitempty"`

	// Category The category to display to the user.
	Category string `json:"category,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string               `json:"chamber_of_commerce_number,omitempty"`
	CounterpartyAddress     *Address              `json:"counterparty_address,omitempty"`
	CounterpartyAlias       *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the invoice object's creation.
	Created string `json:"created,omitempty"`

	// Group The invoice item groups.
	Group []InvoiceItemGroup `json:"group,omitempty"`

	// Id The id of the invoice object.
	Id int `json:"id,omitempty"`

	// InvoiceDate The invoice date.
	InvoiceDate string `json:"invoice_date,omitempty"`

	// InvoiceNumber The invoice number.
	InvoiceNumber string `json:"invoice_number,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// Status The invoice status.
	Status            string `json:"status,omitempty"`
	TotalVat          Amount `json:"total_vat,omitempty"`
	TotalVatExclusive Amount `json:"total_vat_exclusive,omitempty"`
	TotalVatInclusive Amount `json:"total_vat_inclusive,omitempty"`

	// Updated The timestamp of the invoice object's last update.
	Updated string `json:"updated,omitempty"`

	// VatNumber The company's chamber of commerce number.
	VatNumber string `json:"vat_number,omitempty"`
}

// InvoiceRead defines model for InvoiceRead.
type InvoiceRead struct {
	Address *Address              `json:"address,omitempty"`
	Alias   *LabelMonetaryAccount `json:"alias,omitempty"`

	// Category The category to display to the user.
	Category string `json:"category,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string               `json:"chamber_of_commerce_number,omitempty"`
	CounterpartyAddress     *Address              `json:"counterparty_address,omitempty"`
	CounterpartyAlias       *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the invoice object's creation.
	Created string `json:"created,omitempty"`

	// Group The invoice item groups.
	Group []InvoiceItemGroup `json:"group,omitempty"`

	// Id The id of the invoice object.
	Id int `json:"id,omitempty"`

	// InvoiceDate The invoice date.
	InvoiceDate string `json:"invoice_date,omitempty"`

	// InvoiceNumber The invoice number.
	InvoiceNumber string `json:"invoice_number,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// Status The invoice status.
	Status            string `json:"status,omitempty"`
	TotalVat          Amount `json:"total_vat,omitempty"`
	TotalVatExclusive Amount `json:"total_vat_exclusive,omitempty"`
	TotalVatInclusive Amount `json:"total_vat_inclusive,omitempty"`

	// Updated The timestamp of the invoice object's last update.
	Updated string `json:"updated,omitempty"`

	// VatNumber The company's chamber of commerce number.
	VatNumber string `json:"vat_number,omitempty"`
}

// Issuer defines model for Issuer.
type Issuer struct {
	// Bic The BIC code.
	Bic string `json:"bic,omitempty"`

	// Name The name of the bank.
	Name string `json:"name,omitempty"`
}

// LabelCard defines model for LabelCard.
type LabelCard struct {
	// ExpiryDate The date this card will expire.
	ExpiryDate string    `json:"expiry_date,omitempty"`
	LabelUser  *LabelUser `json:"label_user,omitempty"`

	// SecondLine The second line on the card.
	SecondLine string `json:"second_line,omitempty"`

	// Status The status of the card.
	Status string `json:"status,omitempty"`

	// Type The type of the card.
	Type string `json:"type,omitempty"`

	// Uuid The public UUID.
	Uuid string `json:"uuid,omitempty"`
}

// LabelMonetaryAccount defines model for LabelMonetaryAccount.
type LabelMonetaryAccount struct {
	Avatar *Avatar  `json:"avatar,omitempty"`
	BunqMe *Pointer `json:"bunq_me,omitempty"`

	// Country The country of the user. Formatted as a ISO 3166-1 alpha-2 country code.
	Country string `json:"country,omitempty"`

	// DisplayName The name to display with this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Iban The IBAN of the monetary account.
	Iban string `json:"iban,omitempty"`

	// IsLight Whether or not the monetary account is light.
	IsLight   bool      `json:"is_light,omitempty"`
	LabelUser *LabelUser `json:"label_user,omitempty"`

	// MerchantCategoryCode The merchant category code.
	MerchantCategoryCode string `json:"merchant_category_code,omitempty"`

	// SwiftAccountNumber The account number used for a SWIFT payment. May or may not be an IBAN.
	SwiftAccountNumber string `json:"swift_account_number,omitempty"`

	// SwiftBic The BIC used for a SWIFT payment.
	SwiftBic string `json:"swift_bic,omitempty"`

	// TransferwiseAccountNumber The account number used for a Transferwise payment. May or may not be an IBAN.
	TransferwiseAccountNumber string `json:"transferwise_account_number,omitempty"`

	// TransferwiseBankCode The bank code used for a Transferwise payment. May or may not be a BIC.
	TransferwiseBankCode string `json:"transferwise_bank_code,omitempty"`
}

// LabelUser defines model for LabelUser.
type LabelUser struct {
	Avatar *Avatar `json:"avatar,omitempty"`

	// Country The country of the user. 000 stands for "unknown"
	Country string `json:"country,omitempty"`

	// DisplayName The name to be displayed for this user, as it was given on the request.
	DisplayName string `json:"display_name,omitempty"`

	// PublicNickName The current nickname of the user.
	PublicNickName string `json:"public_nick_name,omitempty"`

	// Uuid The public UUID of the label-user.
	Uuid string `json:"uuid,omitempty"`
}

// MasterCardAction defines model for MasterCardAction.
type MasterCardAction struct {
	// AdditionalAuthenticationStatus The status of the additional authentication performed (3ds) by the user for this transaction.
	AdditionalAuthenticationStatus string               `json:"additional_authentication_status,omitempty"`
	Alias                          *LabelMonetaryAccount `json:"alias,omitempty"`

	// AllMastercardActionRefund A reference to the Refunds if they exist.
	AllMastercardActionRefund []MasterCardActionRefund `json:"all_mastercard_action_refund,omitempty"`
	AmountBilling             Amount                   `json:"amount_billing,omitempty"`
	AmountConverted           Amount                   `json:"amount_converted,omitempty"`
	AmountFee                 Amount                   `json:"amount_fee,omitempty"`
	AmountLocal               Amount                   `json:"amount_local,omitempty"`
	AmountOriginalBilling     Amount                   `json:"amount_original_billing,omitempty"`
	AmountOriginalLocal       Amount                   `json:"amount_original_local,omitempty"`

	// AppliedLimit The type of the limit applied to validate if this MasterCardAction was within the spending limits. The returned string matches the limit types as defined in the card endpoint.
	AppliedLimit string `json:"applied_limit,omitempty"`

	// AuthorisationStatus The status in the authorisation process.
	AuthorisationStatus string `json:"authorisation_status,omitempty"`

	// AuthorisationType The type of transaction that was delivered using the card.
	AuthorisationType string                          `json:"authorisation_type,omitempty"`
	Blacklist         *UserBlocklistMasterCardMerchant `json:"blacklist,omitempty"`
	Blocklist         *UserBlocklistMasterCardMerchant `json:"blocklist,omitempty"`

	// CardAuthorisationIdResponse The response code by which authorised transaction can be identified as authorised by bunq.
	CardAuthorisationIdResponse string `json:"card_authorisation_id_response,omitempty"`

	// CardId The id of the card this action links to.
	CardId                int                `json:"card_id,omitempty"`
	CardTokenizationEvent *Event              `json:"card_tokenization_event,omitempty"`
	CashbackPayoutItem    *CashbackPayoutItem `json:"cashback_payout_item,omitempty"`

	// City The city where the message originates from as announced by the terminal.
	City string `json:"city,omitempty"`

	// ClearingExpiryTime The time when the processing of the clearing is expired, refunding the authorisation.
	ClearingExpiryTime string `json:"clearing_expiry_time,omitempty"`

	// ClearingStatus The clearing status of the authorisation. Can be 'PENDING', 'FIRST_PRESENTMENT_COMPLETE' or 'REFUND_LENIENCY'.
	ClearingStatus             string                     `json:"clearing_status,omitempty"`
	CompanyEmployeeCardReceipt *CompanyEmployeeCardReceipt `json:"company_employee_card_receipt,omitempty"`
	CounterpartyAlias          *LabelMonetaryAccount       `json:"counterparty_alias,omitempty"`

	// Decision Why the transaction was denied, if it was denied, or just ALLOWED.
	Decision string `json:"decision,omitempty"`

	// DecisionDescription Empty if allowed, otherwise a textual explanation of why it was denied.
	DecisionDescription string `json:"decision_description,omitempty"`

	// DecisionDescriptionTranslated Empty if allowed, otherwise a textual explanation of why it was denied in user's language.
	DecisionDescriptionTranslated string `json:"decision_description_translated,omitempty"`

	// DecisionTogetherUrl Empty if allowed or if no relevant Together topic exists, otherwise contains the URL for a Together topic with more information about the decision.
	DecisionTogetherUrl string `json:"decision_together_url,omitempty"`

	// Description The description for this transaction to display.
	Description string `json:"description,omitempty"`

	// EligibleWhitelistId The whitelist id for this action or null.
	EligibleWhitelistId int `json:"eligible_whitelist_id,omitempty"`

	// Id The id of the MastercardAction.
	Id                     int                    `json:"id,omitempty"`
	LabelCard              *LabelCard              `json:"label_card,omitempty"`
	MastercardActionReport *MasterCardActionReport `json:"mastercard_action_report,omitempty"`

	// MaturityDate The maturity date.
	MaturityDate string `json:"maturity_date,omitempty"`

	// MerchantCategoryCode The MCC provided.
	MerchantCategoryCode string `json:"merchant_category_code,omitempty"`

	// MerchantId The identification string of the merchant.
	MerchantId string `json:"merchant_id,omitempty"`

	// MonetaryAccountId The id of the monetary account this action links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// PanEntryModeUser The type of entry mode the user used. Can be 'ATM', 'ICC', 'MAGNETIC_STRIPE' or 'E_COMMERCE'.
	PanEntryModeUser string `json:"pan_entry_mode_user,omitempty"`

	// PaymentStatus The payment status of the transaction. For example PAYMENT_SUCCESSFUL, for a successful payment.
	PaymentStatus string `json:"payment_status,omitempty"`

	// PinStatus Status checking the provided PIN.
	PinStatus     string        `json:"pin_status,omitempty"`
	PointMutation *PointMutation `json:"point_mutation,omitempty"`

	// PosCardHolderPresence The Card Holder Presence type of the POS.
	PosCardHolderPresence string `json:"pos_card_holder_presence,omitempty"`

	// PosCardPresence The Card Presence type of the POS.
	PosCardPresence string `json:"pos_card_presence,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// ReservationExpiryTime If this is a reservation, the moment the reservation will expire.
	ReservationExpiryTime string `json:"reservation_expiry_time,omitempty"`

	// SecureCodeId The secure code id for this mastercard action or null.
	SecureCodeId int `json:"secure_code_id,omitempty"`

	// SettlementStatus The setlement status in the authorisation process.
	SettlementStatus string `json:"settlement_status,omitempty"`

	// TokenStatus If this is a tokenisation action, this shows the status of the token.
	TokenStatus string `json:"token_status,omitempty"`

	// WalletProviderId The ID of the wallet provider as defined by MasterCard. 420 = bunq Android app with Tap&Pay; 103 = Apple Pay.
	WalletProviderId string `json:"wallet_provider_id,omitempty"`
}

// MasterCardActionListing defines model for MasterCardActionListing.
type MasterCardActionListing struct {
	// AdditionalAuthenticationStatus The status of the additional authentication performed (3ds) by the user for this transaction.
	AdditionalAuthenticationStatus string               `json:"additional_authentication_status,omitempty"`
	Alias                          *LabelMonetaryAccount `json:"alias,omitempty"`

	// AllMastercardActionRefund A reference to the Refunds if they exist.
	AllMastercardActionRefund []MasterCardActionRefund `json:"all_mastercard_action_refund,omitempty"`
	AmountBilling             Amount                   `json:"amount_billing,omitempty"`
	AmountConverted           Amount                   `json:"amount_converted,omitempty"`
	AmountFee                 Amount                   `json:"amount_fee,omitempty"`
	AmountLocal               Amount                   `json:"amount_local,omitempty"`
	AmountOriginalBilling     Amount                   `json:"amount_original_billing,omitempty"`
	AmountOriginalLocal       Amount                   `json:"amount_original_local,omitempty"`

	// AppliedLimit The type of the limit applied to validate if this MasterCardAction was within the spending limits. The returned string matches the limit types as defined in the card endpoint.
	AppliedLimit string `json:"applied_limit,omitempty"`

	// AuthorisationStatus The status in the authorisation process.
	AuthorisationStatus string `json:"authorisation_status,omitempty"`

	// AuthorisationType The type of transaction that was delivered using the card.
	AuthorisationType string                          `json:"authorisation_type,omitempty"`
	Blacklist         *UserBlocklistMasterCardMerchant `json:"blacklist,omitempty"`
	Blocklist         *UserBlocklistMasterCardMerchant `json:"blocklist,omitempty"`

	// CardAuthorisationIdResponse The response code by which authorised transaction can be identified as authorised by bunq.
	CardAuthorisationIdResponse string `json:"card_authorisation_id_response,omitempty"`

	// CardId The id of the card this action links to.
	CardId                int                `json:"card_id,omitempty"`
	CardTokenizationEvent *Event              `json:"card_tokenization_event,omitempty"`
	CashbackPayoutItem    *CashbackPayoutItem `json:"cashback_payout_item,omitempty"`

	// City The city where the message originates from as announced by the terminal.
	City string `json:"city,omitempty"`

	// ClearingExpiryTime The time when the processing of the clearing is expired, refunding the authorisation.
	ClearingExpiryTime string `json:"clearing_expiry_time,omitempty"`

	// ClearingStatus The clearing status of the authorisation. Can be 'PENDING', 'FIRST_PRESENTMENT_COMPLETE' or 'REFUND_LENIENCY'.
	ClearingStatus             string                     `json:"clearing_status,omitempty"`
	CompanyEmployeeCardReceipt *CompanyEmployeeCardReceipt `json:"company_employee_card_receipt,omitempty"`
	CounterpartyAlias          *LabelMonetaryAccount       `json:"counterparty_alias,omitempty"`

	// Decision Why the transaction was denied, if it was denied, or just ALLOWED.
	Decision string `json:"decision,omitempty"`

	// DecisionDescription Empty if allowed, otherwise a textual explanation of why it was denied.
	DecisionDescription string `json:"decision_description,omitempty"`

	// DecisionDescriptionTranslated Empty if allowed, otherwise a textual explanation of why it was denied in user's language.
	DecisionDescriptionTranslated string `json:"decision_description_translated,omitempty"`

	// DecisionTogetherUrl Empty if allowed or if no relevant Together topic exists, otherwise contains the URL for a Together topic with more information about the decision.
	DecisionTogetherUrl string `json:"decision_together_url,omitempty"`

	// Description The description for this transaction to display.
	Description string `json:"description,omitempty"`

	// EligibleWhitelistId The whitelist id for this action or null.
	EligibleWhitelistId int `json:"eligible_whitelist_id,omitempty"`

	// Id The id of the MastercardAction.
	Id                     int                    `json:"id,omitempty"`
	LabelCard              *LabelCard              `json:"label_card,omitempty"`
	MastercardActionReport *MasterCardActionReport `json:"mastercard_action_report,omitempty"`

	// MaturityDate The maturity date.
	MaturityDate string `json:"maturity_date,omitempty"`

	// MerchantCategoryCode The MCC provided.
	MerchantCategoryCode string `json:"merchant_category_code,omitempty"`

	// MerchantId The identification string of the merchant.
	MerchantId string `json:"merchant_id,omitempty"`

	// MonetaryAccountId The id of the monetary account this action links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// PanEntryModeUser The type of entry mode the user used. Can be 'ATM', 'ICC', 'MAGNETIC_STRIPE' or 'E_COMMERCE'.
	PanEntryModeUser string `json:"pan_entry_mode_user,omitempty"`

	// PaymentStatus The payment status of the transaction. For example PAYMENT_SUCCESSFUL, for a successful payment.
	PaymentStatus string `json:"payment_status,omitempty"`

	// PinStatus Status checking the provided PIN.
	PinStatus     string        `json:"pin_status,omitempty"`
	PointMutation *PointMutation `json:"point_mutation,omitempty"`

	// PosCardHolderPresence The Card Holder Presence type of the POS.
	PosCardHolderPresence string `json:"pos_card_holder_presence,omitempty"`

	// PosCardPresence The Card Presence type of the POS.
	PosCardPresence string `json:"pos_card_presence,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// ReservationExpiryTime If this is a reservation, the moment the reservation will expire.
	ReservationExpiryTime string `json:"reservation_expiry_time,omitempty"`

	// SecureCodeId The secure code id for this mastercard action or null.
	SecureCodeId int `json:"secure_code_id,omitempty"`

	// SettlementStatus The setlement status in the authorisation process.
	SettlementStatus string `json:"settlement_status,omitempty"`

	// TokenStatus If this is a tokenisation action, this shows the status of the token.
	TokenStatus string `json:"token_status,omitempty"`

	// WalletProviderId The ID of the wallet provider as defined by MasterCard. 420 = bunq Android app with Tap&Pay; 103 = Apple Pay.
	WalletProviderId string `json:"wallet_provider_id,omitempty"`
}

// MasterCardActionRead defines model for MasterCardActionRead.
type MasterCardActionRead struct {
	// AdditionalAuthenticationStatus The status of the additional authentication performed (3ds) by the user for this transaction.
	AdditionalAuthenticationStatus string               `json:"additional_authentication_status,omitempty"`
	Alias                          *LabelMonetaryAccount `json:"alias,omitempty"`

	// AllMastercardActionRefund A reference to the Refunds if they exist.
	AllMastercardActionRefund []MasterCardActionRefund `json:"all_mastercard_action_refund,omitempty"`
	AmountBilling             Amount                   `json:"amount_billing,omitempty"`
	AmountConverted           Amount                   `json:"amount_converted,omitempty"`
	AmountFee                 Amount                   `json:"amount_fee,omitempty"`
	AmountLocal               Amount                   `json:"amount_local,omitempty"`
	AmountOriginalBilling     Amount                   `json:"amount_original_billing,omitempty"`
	AmountOriginalLocal       Amount                   `json:"amount_original_local,omitempty"`

	// AppliedLimit The type of the limit applied to validate if this MasterCardAction was within the spending limits. The returned string matches the limit types as defined in the card endpoint.
	AppliedLimit string `json:"applied_limit,omitempty"`

	// AuthorisationStatus The status in the authorisation process.
	AuthorisationStatus string `json:"authorisation_status,omitempty"`

	// AuthorisationType The type of transaction that was delivered using the card.
	AuthorisationType string                          `json:"authorisation_type,omitempty"`
	Blacklist         *UserBlocklistMasterCardMerchant `json:"blacklist,omitempty"`
	Blocklist         *UserBlocklistMasterCardMerchant `json:"blocklist,omitempty"`

	// CardAuthorisationIdResponse The response code by which authorised transaction can be identified as authorised by bunq.
	CardAuthorisationIdResponse string `json:"card_authorisation_id_response,omitempty"`

	// CardId The id of the card this action links to.
	CardId                int                `json:"card_id,omitempty"`
	CardTokenizationEvent *Event              `json:"card_tokenization_event,omitempty"`
	CashbackPayoutItem    *CashbackPayoutItem `json:"cashback_payout_item,omitempty"`

	// City The city where the message originates from as announced by the terminal.
	City string `json:"city,omitempty"`

	// ClearingExpiryTime The time when the processing of the clearing is expired, refunding the authorisation.
	ClearingExpiryTime string `json:"clearing_expiry_time,omitempty"`

	// ClearingStatus The clearing status of the authorisation. Can be 'PENDING', 'FIRST_PRESENTMENT_COMPLETE' or 'REFUND_LENIENCY'.
	ClearingStatus             string                     `json:"clearing_status,omitempty"`
	CompanyEmployeeCardReceipt *CompanyEmployeeCardReceipt `json:"company_employee_card_receipt,omitempty"`
	CounterpartyAlias          *LabelMonetaryAccount       `json:"counterparty_alias,omitempty"`

	// Decision Why the transaction was denied, if it was denied, or just ALLOWED.
	Decision string `json:"decision,omitempty"`

	// DecisionDescription Empty if allowed, otherwise a textual explanation of why it was denied.
	DecisionDescription string `json:"decision_description,omitempty"`

	// DecisionDescriptionTranslated Empty if allowed, otherwise a textual explanation of why it was denied in user's language.
	DecisionDescriptionTranslated string `json:"decision_description_translated,omitempty"`

	// DecisionTogetherUrl Empty if allowed or if no relevant Together topic exists, otherwise contains the URL for a Together topic with more information about the decision.
	DecisionTogetherUrl string `json:"decision_together_url,omitempty"`

	// Description The description for this transaction to display.
	Description string `json:"description,omitempty"`

	// EligibleWhitelistId The whitelist id for this action or null.
	EligibleWhitelistId int `json:"eligible_whitelist_id,omitempty"`

	// Id The id of the MastercardAction.
	Id                     int                    `json:"id,omitempty"`
	LabelCard              *LabelCard              `json:"label_card,omitempty"`
	MastercardActionReport *MasterCardActionReport `json:"mastercard_action_report,omitempty"`

	// MaturityDate The maturity date.
	MaturityDate string `json:"maturity_date,omitempty"`

	// MerchantCategoryCode The MCC provided.
	MerchantCategoryCode string `json:"merchant_category_code,omitempty"`

	// MerchantId The identification string of the merchant.
	MerchantId string `json:"merchant_id,omitempty"`

	// MonetaryAccountId The id of the monetary account this action links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// PanEntryModeUser The type of entry mode the user used. Can be 'ATM', 'ICC', 'MAGNETIC_STRIPE' or 'E_COMMERCE'.
	PanEntryModeUser string `json:"pan_entry_mode_user,omitempty"`

	// PaymentStatus The payment status of the transaction. For example PAYMENT_SUCCESSFUL, for a successful payment.
	PaymentStatus string `json:"payment_status,omitempty"`

	// PinStatus Status checking the provided PIN.
	PinStatus     string        `json:"pin_status,omitempty"`
	PointMutation *PointMutation `json:"point_mutation,omitempty"`

	// PosCardHolderPresence The Card Holder Presence type of the POS.
	PosCardHolderPresence string `json:"pos_card_holder_presence,omitempty"`

	// PosCardPresence The Card Presence type of the POS.
	PosCardPresence string `json:"pos_card_presence,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// ReservationExpiryTime If this is a reservation, the moment the reservation will expire.
	ReservationExpiryTime string `json:"reservation_expiry_time,omitempty"`

	// SecureCodeId The secure code id for this mastercard action or null.
	SecureCodeId int `json:"secure_code_id,omitempty"`

	// SettlementStatus The setlement status in the authorisation process.
	SettlementStatus string `json:"settlement_status,omitempty"`

	// TokenStatus If this is a tokenisation action, this shows the status of the token.
	TokenStatus string `json:"token_status,omitempty"`

	// WalletProviderId The ID of the wallet provider as defined by MasterCard. 420 = bunq Android app with Tap&Pay; 103 = Apple Pay.
	WalletProviderId string `json:"wallet_provider_id,omitempty"`
}

// MasterCardActionReference defines model for MasterCardActionReference.
type MasterCardActionReference struct {
	// EventId The id of the event.
	EventId int `json:"event_id,omitempty"`
}

// MasterCardActionRefund defines model for MasterCardActionRefund.
type MasterCardActionRefund struct {
	AdditionalInformation *AdditionalInformation `json:"additional_information,omitempty"`
	Alias                 *LabelMonetaryAccount  `json:"alias,omitempty"`
	Amount                Amount                `json:"amount,omitempty"`

	// Attachment The Attachments to attach to the refund request.
	Attachment []AttachmentMasterCardActionRefund `json:"attachment,omitempty"`

	// Category The category of the refund, required for chargeback.
	Category string `json:"category,omitempty"`

	// Comment Comment about the refund.
	Comment           string               `json:"comment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the refund's creation.
	Created string `json:"created,omitempty"`

	// Description The description for this transaction to display.
	Description string `json:"description,omitempty"`

	// Id The id of the refund.
	Id               int       `json:"id,omitempty"`
	LabelCard        *LabelCard `json:"label_card,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// MastercardActionId The id of mastercard action being refunded.
	MastercardActionId int `json:"mastercard_action_id,omitempty"`

	// Reason The reason of the refund. Can be REFUND_EXPIRED_TRANSACTION, REFUND_REQUESTED, REFUND_MERCHANT, REFUND_CHARGEBACK.
	Reason string `json:"reason,omitempty"`

	// ReferenceMastercardActionEvent The reference to the object this refund applies to.
	ReferenceMastercardActionEvent []MasterCardActionReference `json:"reference_mastercard_action_event,omitempty"`

	// Status The status of the refunded mastercard action. Can be AUTO_APPROVED, AUTO_APPROVED_WAITING_FOR_EXPIRY, PENDING_APPROVAL, APPROVED, REFUNDED, DENIED or FAILED
	Status string `json:"status,omitempty"`

	// StatusDescription Description of the refund's current status.
	StatusDescription string `json:"status_description,omitempty"`

	// StatusDescriptionTranslated Description of the refund's current status, translated in user's language.
	StatusDescriptionTranslated string `json:"status_description_translated,omitempty"`

	// StatusTogetherUrl Together topic concerning the refund's current status.
	StatusTogetherUrl string `json:"status_together_url,omitempty"`

	// SubType The sub type of this refund indicating whether the chargeback will be FULL or PARTIAL.
	SubType string `json:"sub_type,omitempty"`

	// TermsAndConditions Proof that the user acknowledged the terms and conditions for chargebacks.
	TermsAndConditions string `json:"terms_and_conditions,omitempty"`

	// TimeRefund The time the refund will take place.
	TimeRefund string `json:"time_refund,omitempty"`

	// Type Type of this refund. Can de REFUND or CHARGEBACK
	Type string `json:"type,omitempty"`

	// Updated The timestamp of the refund's last update.
	Updated string `json:"updated,omitempty"`
}

// MasterCardActionReport defines model for MasterCardActionReport.
type MasterCardActionReport struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// MastercardActionId The id of mastercard action being reported.
	MastercardActionId int `json:"mastercard_action_id,omitempty"`

	// MerchantId The reported merchant.
	MerchantId string `json:"merchant_id,omitempty"`

	// MerchantName The name of the merchant.
	MerchantName string `json:"merchant_name,omitempty"`

	// Status The id of mastercard action being reported.
	Status string `json:"status,omitempty"`

	// Type The id of mastercard action being reported.
	Type string `json:"type,omitempty"`
}

// MasterCardIdentityCheckChallengeRequestUser defines model for MasterCardIdentityCheckChallengeRequestUser.
type MasterCardIdentityCheckChallengeRequestUser struct {
	// Status The status of the identity check. Can be ACCEPTED_PENDING_RESPONSE or REJECTED_PENDING_RESPONSE.
	Status string `json:"status"`
}

// MasterCardIdentityCheckChallengeRequestUserRead defines model for MasterCardIdentityCheckChallengeRequestUserRead.
type MasterCardIdentityCheckChallengeRequestUserRead struct {
	// Amount The transaction amount.
	Amount string `json:"amount,omitempty"`

	// CardId The ID of the card used for the authentication request of the identity check.
	CardId            int                  `json:"card_id,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// DecisionDescription Textual explanation of the decision.
	DecisionDescription string `json:"decision_description,omitempty"`

	// DecisionDescriptionTranslated Textual explanation of the decision in user's language.
	DecisionDescriptionTranslated string `json:"decision_description_translated,omitempty"`

	// Description The description of the purchase. NULL if no description is given.
	Description string `json:"description,omitempty"`

	// EventId The ID of the latest event for the identity check.
	EventId int `json:"event_id,omitempty"`

	// ExpiryTime When the identity check expires.
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Status The status of the secure code. Can be PENDING, ACCEPTED, REJECTED, EXPIRED.
	Status string `json:"status,omitempty"`

	// UrlMerchantApp The return url for the merchant app after the challenge is accepted or rejected.
	UrlMerchantApp string `json:"url_merchant_app,omitempty"`
}

// MasterCardIdentityCheckChallengeRequestUserUpdate defines model for MasterCardIdentityCheckChallengeRequestUserUpdate.
type MasterCardIdentityCheckChallengeRequestUserUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MasterCardPaymentListing defines model for MasterCardPaymentListing.
type MasterCardPaymentListing = map[string]interface{}

// MonetaryAccount defines model for MonetaryAccount.
type MonetaryAccount struct {
	MonetaryAccountBank            *MonetaryAccountBank            `json:"MonetaryAccountBank,omitempty"`
	MonetaryAccountCard            *MonetaryAccountCard            `json:"MonetaryAccountCard,omitempty"`
	MonetaryAccountExternal        *MonetaryAccountExternal        `json:"MonetaryAccountExternal,omitempty"`
	MonetaryAccountExternalSavings *MonetaryAccountExternalSavings `json:"MonetaryAccountExternalSavings,omitempty"`
	MonetaryAccountInvestment      *MonetaryAccountInvestment      `json:"MonetaryAccountInvestment,omitempty"`
	MonetaryAccountJoint           *MonetaryAccountJoint           `json:"MonetaryAccountJoint,omitempty"`
	MonetaryAccountLight           *MonetaryAccountLight           `json:"MonetaryAccountLight,omitempty"`
	MonetaryAccountSavings         *MonetaryAccountSavings         `json:"MonetaryAccountSavings,omitempty"`
	MonetaryAccountSwitchService   *MonetaryAccountSwitchService   `json:"MonetaryAccountSwitchService,omitempty"`

	// Alias The aliases for the MonetaryAccount.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner                []CoOwner                 `json:"all_co_owner,omitempty"`
	Balance                   Amount                    `json:"balance,omitempty"`
	BirdeeInvestmentPortfolio *BirdeeInvestmentPortfolio `json:"birdee_investment_portfolio,omitempty"`

	// Budget The budgets of the MonetaryAccount.
	Budget        []MonetaryAccountBudget `json:"budget,omitempty"`
	CoOwnerInvite *CoOwnerInviteResponse   `json:"co_owner_invite,omitempty"`

	// Fulfillments The fulfillments for this MonetaryAccount.
	Fulfillments []Fulfillment `json:"fulfillments,omitempty"`

	// MonetaryAccountProfile The profiles of the account.
	MonetaryAccountProfile []MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OpenBankingAccount     *OpenBankingAccount       `json:"open_banking_account,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccount.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccount. Can be any user provided message.
	ReasonDescription string                             `json:"reason_description,omitempty"`
	RelationUser      *RelationUser                       `json:"relation_user,omitempty"`
	Setting           *MonetaryAccountSetting             `json:"setting,omitempty"`
	Share             *ShareInviteMonetaryAccountResponse `json:"share,omitempty"`
}

// MonetaryAccountBank defines model for MonetaryAccountBank.
type MonetaryAccountBank struct {
	// Alias The Aliases for the MonetaryAccountBank.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`

	// AvatarUuid The UUID of the Avatar of the MonetaryAccountBank.
	AvatarUuid string `json:"avatar_uuid,omitempty"`
	Balance    Amount `json:"balance,omitempty"`

	// CountryIban The country of the monetary account IBAN.
	CountryIban string `json:"country_iban,omitempty"`

	// Created The timestamp of the MonetaryAccountBank's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountBank as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountBank. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountBank.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountBank's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountBank. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountBank providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountBank's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountBank.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountBankCreate defines model for MonetaryAccountBankCreate.
type MonetaryAccountBankCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountBankListing defines model for MonetaryAccountBankListing.
type MonetaryAccountBankListing struct {
	// Alias The Aliases for the MonetaryAccountBank.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`
	Balance       Amount   `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountBank's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountBank as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountBank. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountBank.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountBank's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountBank. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountBank providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountBank's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountBank.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountBankRead defines model for MonetaryAccountBankRead.
type MonetaryAccountBankRead struct {
	// Alias The Aliases for the MonetaryAccountBank.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`
	Balance       Amount   `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountBank's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountBank as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountBank. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountBank.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountBank's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountBank. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountBank providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountBank's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountBank.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountBankUpdate defines model for MonetaryAccountBankUpdate.
type MonetaryAccountBankUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountBudget defines model for MonetaryAccountBudget.
type MonetaryAccountBudget struct {
	// AllCategory DEPRECATED. The list of categories on which the user wants to set the budget.
	AllCategory []string `json:"all_category,omitempty"`
	Amount      Amount    `json:"amount"`

	// MonetaryAccountSourceFundingId DEPRECATED. The monetary account's ID from/to which the missing/exceeding funds will be transferred.
	MonetaryAccountSourceFundingId int `json:"monetary_account_source_funding_id,omitempty"`

	// PaymentDayOfMonth DEPRECATED. The day of the month for the automatic top-up.
	PaymentDayOfMonth int `json:"payment_day_of_month,omitempty"`

	// RecurrenceType DEPRECATED. The recurrence type for the automatic top-up.
	RecurrenceType string `json:"recurrence_type,omitempty"`
}

// MonetaryAccountCard defines model for MonetaryAccountCard.
type MonetaryAccountCard struct {
	// Alias The Aliases for the MonetaryAccountCard.
	Alias       []Pointer `json:"alias,omitempty"`
	Balance     Amount    `json:"balance,omitempty"`
	BalanceReal Amount    `json:"balance_real,omitempty"`

	// Created The timestamp of the MonetaryAccountCard's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountCard as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountCard. Defaults to 'prepaid credit card'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountCard.
	Id             int    `json:"id,omitempty"`
	OverdraftLimit Amount `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountCard's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Status The status of the MonetaryAccountCard.
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountCard providing extra information regarding the status.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountCard's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountCard.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountCardListing defines model for MonetaryAccountCardListing.
type MonetaryAccountCardListing struct {
	// Alias The Aliases for the MonetaryAccountCard.
	Alias       []Pointer `json:"alias,omitempty"`
	Balance     Amount    `json:"balance,omitempty"`
	BalanceReal Amount    `json:"balance_real,omitempty"`

	// Created The timestamp of the MonetaryAccountCard's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountCard as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountCard. Defaults to 'prepaid credit card'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountCard.
	Id             int    `json:"id,omitempty"`
	OverdraftLimit Amount `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountCard's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Status The status of the MonetaryAccountCard.
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountCard providing extra information regarding the status.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountCard's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountCard.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountCardRead defines model for MonetaryAccountCardRead.
type MonetaryAccountCardRead struct {
	// Alias The Aliases for the MonetaryAccountCard.
	Alias       []Pointer `json:"alias,omitempty"`
	Balance     Amount    `json:"balance,omitempty"`
	BalanceReal Amount    `json:"balance_real,omitempty"`

	// Created The timestamp of the MonetaryAccountCard's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountCard as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountCard. Defaults to 'prepaid credit card'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountCard.
	Id             int    `json:"id,omitempty"`
	OverdraftLimit Amount `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountCard's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Status The status of the MonetaryAccountCard.
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountCard providing extra information regarding the status.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountCard's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountCard.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountCardUpdate defines model for MonetaryAccountCardUpdate.
type MonetaryAccountCardUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountExternal defines model for MonetaryAccountExternal.
type MonetaryAccountExternal struct {
	// Alias The Aliases for the MonetaryAccountExternal.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`

	// AvatarUuid The UUID of the Avatar of the MonetaryAccountExternal.
	AvatarUuid string `json:"avatar_uuid,omitempty"`
	Balance    Amount `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountExternal's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountExternal as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountExternal. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountExternal.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OpenBankingAccount     *OpenBankingAccount     `json:"open_banking_account,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountExternal's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountExternal, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternal. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`

	// Service The external service the Monetary Account is connected with.
	Service string                 `json:"service,omitempty"`
	Setting *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountExternal. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountExternal providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountExternal's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountExternal.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountExternalCreate defines model for MonetaryAccountExternalCreate.
type MonetaryAccountExternalCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountExternalListing defines model for MonetaryAccountExternalListing.
type MonetaryAccountExternalListing struct {
	// Alias The Aliases for the MonetaryAccountExternal.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`
	Balance       Amount   `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountExternal's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountExternal as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountExternal. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountExternal.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OpenBankingAccount     *OpenBankingAccount     `json:"open_banking_account,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountExternal's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountExternal, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternal. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`

	// Service The external service the Monetary Account is connected with.
	Service string                 `json:"service,omitempty"`
	Setting *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountExternal. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountExternal providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountExternal's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountExternal.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountExternalRead defines model for MonetaryAccountExternalRead.
type MonetaryAccountExternalRead struct {
	// Alias The Aliases for the MonetaryAccountExternal.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`
	Balance       Amount   `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountExternal's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountExternal as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountExternal. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountExternal.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OpenBankingAccount     *OpenBankingAccount     `json:"open_banking_account,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountExternal's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountExternal, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternal. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`

	// Service The external service the Monetary Account is connected with.
	Service string                 `json:"service,omitempty"`
	Setting *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountExternal. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountExternal providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountExternal's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountExternal.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountExternalSavings defines model for MonetaryAccountExternalSavings.
type MonetaryAccountExternalSavings struct {
	// Alias The Aliases for the MonetaryAccountExternalSavings.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`

	// AvatarUuid The UUID of the Avatar of the MonetaryAccountExternalSavings.
	AvatarUuid string `json:"avatar_uuid,omitempty"`
	Balance    Amount `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountExternalSavings's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountExternalSavings as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountExternalSavings. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountExternalSavings.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`

	// NumberOfPaymentRemaining The number of payments that can be made from this savings account
	NumberOfPaymentRemaining *float32 `json:"number_of_payment_remaining,omitempty"`

	// PublicUuid The MonetaryAccountExternalSavings's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountExternalSavings, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternalSavings. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`
	SavingsGoal       Amount `json:"savings_goal,omitempty"`

	// SavingsGoalProgress The progress in percentages for the Savings Goal set for this MonetaryAccountExternalSavings.
	SavingsGoalProgress int `json:"savings_goal_progress,omitempty"`

	// Service The service the MonetaryAccountExternalSavings is connected with.
	Service string                 `json:"service,omitempty"`
	Setting *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountExternalSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountExternalSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountExternalSavings's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountExternalSavings.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountExternalSavingsCreate defines model for MonetaryAccountExternalSavingsCreate.
type MonetaryAccountExternalSavingsCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountExternalSavingsListing defines model for MonetaryAccountExternalSavingsListing.
type MonetaryAccountExternalSavingsListing struct {
	// Alias The Aliases for the MonetaryAccountExternalSavings.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`
	Balance       Amount   `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountExternalSavings's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountExternalSavings as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountExternalSavings. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountExternalSavings.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`

	// NumberOfPaymentRemaining The number of payments that can be made from this savings account
	NumberOfPaymentRemaining *float32 `json:"number_of_payment_remaining,omitempty"`

	// PublicUuid The MonetaryAccountExternalSavings's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountExternalSavings, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternalSavings. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`
	SavingsGoal       Amount `json:"savings_goal,omitempty"`

	// SavingsGoalProgress The progress in percentages for the Savings Goal set for this MonetaryAccountExternalSavings.
	SavingsGoalProgress int                    `json:"savings_goal_progress,omitempty"`
	Setting             *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountExternalSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountExternalSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountExternalSavings's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountExternalSavings.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountExternalSavingsRead defines model for MonetaryAccountExternalSavingsRead.
type MonetaryAccountExternalSavingsRead struct {
	// Alias The Aliases for the MonetaryAccountExternalSavings.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`
	Avatar        *Avatar   `json:"avatar,omitempty"`
	Balance       Amount   `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountExternalSavings's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountExternalSavings as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountExternalSavings. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountExternalSavings.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`

	// NumberOfPaymentRemaining The number of payments that can be made from this savings account
	NumberOfPaymentRemaining *float32 `json:"number_of_payment_remaining,omitempty"`

	// PublicUuid The MonetaryAccountExternalSavings's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountExternalSavings, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternalSavings. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`
	SavingsGoal       Amount `json:"savings_goal,omitempty"`

	// SavingsGoalProgress The progress in percentages for the Savings Goal set for this MonetaryAccountExternalSavings.
	SavingsGoalProgress int                    `json:"savings_goal_progress,omitempty"`
	Setting             *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountExternalSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountExternalSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountExternalSavings's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountExternalSavings.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountExternalSavingsUpdate defines model for MonetaryAccountExternalSavingsUpdate.
type MonetaryAccountExternalSavingsUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountExternalUpdate defines model for MonetaryAccountExternalUpdate.
type MonetaryAccountExternalUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountInvestment defines model for MonetaryAccountInvestment.
type MonetaryAccountInvestment struct {
	// Alias The Aliases for the MonetaryAccountInvestment.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId        []BunqId `json:"all_auto_save_id,omitempty"`
	AmountDepositInitial Amount   `json:"amount_deposit_initial,omitempty"`
	Avatar               *Avatar   `json:"avatar,omitempty"`

	// AvatarUuid The UUID of the Avatar of the MonetaryAccountInvestment.
	AvatarUuid                string                    `json:"avatar_uuid,omitempty"`
	Balance                   Amount                    `json:"balance,omitempty"`
	BirdeeInvestmentPortfolio *BirdeeInvestmentPortfolio `json:"birdee_investment_portfolio,omitempty"`

	// Created The timestamp of the MonetaryAccountInvestment's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountInvestment as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountInvestment. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// DisplayName The legal name of the user / company using this monetary account.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the MonetaryAccountInvestment.
	Id int `json:"id,omitempty"`

	// MonetaryAccountDepositInitialId ID of the MA to be used for the initial deposit to the investment account.
	MonetaryAccountDepositInitialId int                    `json:"monetary_account_deposit_initial_id,omitempty"`
	MonetaryAccountProfile          *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`

	// Provider The provider of the investment service.
	Provider string `json:"provider,omitempty"`

	// PublicUuid The MonetaryAccountInvestment's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountInvestment, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountInvestment. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountInvestment. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountInvestment providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountInvestment's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountInvestment.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountJoint defines model for MonetaryAccountJoint.
type MonetaryAccountJoint struct {
	// Alias The Aliases for the MonetaryAccountJoint.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner []CoOwner `json:"all_co_owner,omitempty"`
	Avatar     *Avatar    `json:"avatar,omitempty"`

	// AvatarUuid The UUID of the Avatar of the MonetaryAccountJoint.
	AvatarUuid string `json:"avatar_uuid,omitempty"`
	Balance    Amount `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountJoint's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountJoint as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountJoint. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountJoint.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountJoint's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountJoint, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountJoint. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountJoint. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountJoint providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountJoint's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountJoint.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountJointCreate defines model for MonetaryAccountJointCreate.
type MonetaryAccountJointCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountJointListing defines model for MonetaryAccountJointListing.
type MonetaryAccountJointListing struct {
	// Alias The Aliases for the MonetaryAccountJoint.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner []CoOwner `json:"all_co_owner,omitempty"`
	Avatar     *Avatar    `json:"avatar,omitempty"`
	Balance    Amount    `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountJoint's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountJoint as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountJoint. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountJoint.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountJoint's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountJoint, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountJoint. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountJoint. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountJoint providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountJoint's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountJoint.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountJointRead defines model for MonetaryAccountJointRead.
type MonetaryAccountJointRead struct {
	// Alias The Aliases for the MonetaryAccountJoint.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner []CoOwner `json:"all_co_owner,omitempty"`
	Avatar     *Avatar    `json:"avatar,omitempty"`
	Balance    Amount    `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountJoint's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountJoint as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountJoint. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountJoint.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`
	OverdraftLimit         Amount                 `json:"overdraft_limit,omitempty"`

	// PublicUuid The MonetaryAccountJoint's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountJoint, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountJoint. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountJoint. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountJoint providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountJoint's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountJoint.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountJointUpdate defines model for MonetaryAccountJointUpdate.
type MonetaryAccountJointUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountLight defines model for MonetaryAccountLight.
type MonetaryAccountLight struct {
	// Alias The Aliases for the MonetaryAccountLight.
	Alias  []Pointer `json:"alias,omitempty"`
	Avatar *Avatar    `json:"avatar,omitempty"`

	// AvatarUuid The UUID of the Avatar of the MonetaryAccountLight.
	AvatarUuid                  string `json:"avatar_uuid,omitempty"`
	Balance                     Amount `json:"balance,omitempty"`
	BalanceMaximum              Amount `json:"balance_maximum,omitempty"`
	BudgetMonthMaximum          Amount `json:"budget_month_maximum,omitempty"`
	BudgetMonthUsed             Amount `json:"budget_month_used,omitempty"`
	BudgetWithdrawalYearMaximum Amount `json:"budget_withdrawal_year_maximum,omitempty"`
	BudgetWithdrawalYearUsed    Amount `json:"budget_withdrawal_year_used,omitempty"`
	BudgetYearMaximum           Amount `json:"budget_year_maximum,omitempty"`
	BudgetYearUsed              Amount `json:"budget_year_used,omitempty"`

	// Created The timestamp of the MonetaryAccountLight's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountLight as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountLight. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountLight.
	Id int `json:"id,omitempty"`

	// PublicUuid The MonetaryAccountLight's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message.
	ReasonDescription string                 `json:"reason_description,omitempty"`
	Setting           *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountLight. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountLight providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountLight's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountLight.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountListing defines model for MonetaryAccountListing.
type MonetaryAccountListing struct {
	MonetaryAccountBank            *MonetaryAccountBank            `json:"MonetaryAccountBank,omitempty"`
	MonetaryAccountCard            *MonetaryAccountCard            `json:"MonetaryAccountCard,omitempty"`
	MonetaryAccountExternal        *MonetaryAccountExternal        `json:"MonetaryAccountExternal,omitempty"`
	MonetaryAccountExternalSavings *MonetaryAccountExternalSavings `json:"MonetaryAccountExternalSavings,omitempty"`
	MonetaryAccountInvestment      *MonetaryAccountInvestment      `json:"MonetaryAccountInvestment,omitempty"`
	MonetaryAccountJoint           *MonetaryAccountJoint           `json:"MonetaryAccountJoint,omitempty"`
	MonetaryAccountLight           *MonetaryAccountLight           `json:"MonetaryAccountLight,omitempty"`
	MonetaryAccountSavings         *MonetaryAccountSavings         `json:"MonetaryAccountSavings,omitempty"`
	MonetaryAccountSwitchService   *MonetaryAccountSwitchService   `json:"MonetaryAccountSwitchService,omitempty"`
}

// MonetaryAccountProfile defines model for MonetaryAccountProfile.
type MonetaryAccountProfile struct {
	ProfileDrain *MonetaryAccountProfileDrain `json:"profile_drain,omitempty"`
	ProfileFill  *MonetaryAccountProfileFill  `json:"profile_fill,omitempty"`
}

// MonetaryAccountProfileDrain defines model for MonetaryAccountProfileDrain.
type MonetaryAccountProfileDrain struct {
	BalancePreferred     Amount               `json:"balance_preferred,omitempty"`
	BalanceThresholdHigh Amount               `json:"balance_threshold_high,omitempty"`
	SavingsAccountAlias  *LabelMonetaryAccount `json:"savings_account_alias,omitempty"`

	// Status The status of the profile.
	Status string `json:"status,omitempty"`
}

// MonetaryAccountProfileFill defines model for MonetaryAccountProfileFill.
type MonetaryAccountProfileFill struct {
	BalancePreferred    Amount `json:"balance_preferred,omitempty"`
	BalanceThresholdLow Amount `json:"balance_threshold_low,omitempty"`
	Issuer              *Issuer `json:"issuer,omitempty"`

	// Status The status of the profile.
	Status string `json:"status,omitempty"`
}

// MonetaryAccountRead defines model for MonetaryAccountRead.
type MonetaryAccountRead struct {
	MonetaryAccountBank            *MonetaryAccountBank            `json:"MonetaryAccountBank,omitempty"`
	MonetaryAccountCard            *MonetaryAccountCard            `json:"MonetaryAccountCard,omitempty"`
	MonetaryAccountExternal        *MonetaryAccountExternal        `json:"MonetaryAccountExternal,omitempty"`
	MonetaryAccountExternalSavings *MonetaryAccountExternalSavings `json:"MonetaryAccountExternalSavings,omitempty"`
	MonetaryAccountInvestment      *MonetaryAccountInvestment      `json:"MonetaryAccountInvestment,omitempty"`
	MonetaryAccountJoint           *MonetaryAccountJoint           `json:"MonetaryAccountJoint,omitempty"`
	MonetaryAccountLight           *MonetaryAccountLight           `json:"MonetaryAccountLight,omitempty"`
	MonetaryAccountSavings         *MonetaryAccountSavings         `json:"MonetaryAccountSavings,omitempty"`
	MonetaryAccountSwitchService   *MonetaryAccountSwitchService   `json:"MonetaryAccountSwitchService,omitempty"`
}

// MonetaryAccountSavings defines model for MonetaryAccountSavings.
type MonetaryAccountSavings struct {
	// Alias The Aliases for the MonetaryAccountSavings.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner []CoOwner `json:"all_co_owner,omitempty"`
	Avatar     *Avatar    `json:"avatar,omitempty"`

	// AvatarUuid The UUID of the Avatar of the MonetaryAccountSavings.
	AvatarUuid string `json:"avatar_uuid,omitempty"`
	Balance    Amount `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountSavings's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountSavings as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountSavings. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountSavings.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`

	// NumberOfPaymentRemaining The number of payments that can be made from this savings account
	NumberOfPaymentRemaining *float32 `json:"number_of_payment_remaining,omitempty"`

	// PublicUuid The MonetaryAccountSavings's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountSavings, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountSavings. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`
	SavingsGoal       Amount `json:"savings_goal,omitempty"`

	// SavingsGoalProgress The progress in percentages for the Savings Goal set for this MonetaryAccountSavings.
	SavingsGoalProgress int                    `json:"savings_goal_progress,omitempty"`
	Setting             *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountSavings's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountSavings.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountSavingsCreate defines model for MonetaryAccountSavingsCreate.
type MonetaryAccountSavingsCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountSavingsListing defines model for MonetaryAccountSavingsListing.
type MonetaryAccountSavingsListing struct {
	// Alias The Aliases for the MonetaryAccountSavings.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner []CoOwner `json:"all_co_owner,omitempty"`
	Avatar     *Avatar    `json:"avatar,omitempty"`
	Balance    Amount    `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountSavings's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountSavings as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountSavings. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountSavings.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`

	// NumberOfPaymentRemaining The number of payments that can be made from this savings account
	NumberOfPaymentRemaining *float32 `json:"number_of_payment_remaining,omitempty"`

	// PublicUuid The MonetaryAccountSavings's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountSavings, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountSavings. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`
	SavingsGoal       Amount `json:"savings_goal,omitempty"`

	// SavingsGoalProgress The progress in percentages for the Savings Goal set for this MonetaryAccountSavings.
	SavingsGoalProgress int                    `json:"savings_goal_progress,omitempty"`
	Setting             *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountSavings's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountSavings.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountSavingsRead defines model for MonetaryAccountSavingsRead.
type MonetaryAccountSavingsRead struct {
	// Alias The Aliases for the MonetaryAccountSavings.
	Alias []Pointer `json:"alias,omitempty"`

	// AllAutoSaveId The ids of the AutoSave.
	AllAutoSaveId []BunqId `json:"all_auto_save_id,omitempty"`

	// AllCoOwner The users the account will be joint with.
	AllCoOwner []CoOwner `json:"all_co_owner,omitempty"`
	Avatar     *Avatar    `json:"avatar,omitempty"`
	Balance    Amount    `json:"balance,omitempty"`

	// Created The timestamp of the MonetaryAccountSavings's creation.
	Created string `json:"created,omitempty"`

	// Currency The currency of the MonetaryAccountSavings as an ISO 4217 formatted currency code.
	Currency   string `json:"currency,omitempty"`
	DailyLimit Amount `json:"daily_limit,omitempty"`

	// Description The description of the MonetaryAccountSavings. Defaults to 'bunq account'.
	Description string `json:"description,omitempty"`

	// Id The id of the MonetaryAccountSavings.
	Id                     int                    `json:"id,omitempty"`
	MonetaryAccountProfile *MonetaryAccountProfile `json:"monetary_account_profile,omitempty"`

	// NumberOfPaymentRemaining The number of payments that can be made from this savings account
	NumberOfPaymentRemaining *float32 `json:"number_of_payment_remaining,omitempty"`

	// PublicUuid The MonetaryAccountSavings's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Reason The reason for voluntarily cancelling (closing) the MonetaryAccountSavings, can only be OTHER.
	Reason string `json:"reason,omitempty"`

	// ReasonDescription The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountSavings. Can be any user provided message.
	ReasonDescription string `json:"reason_description,omitempty"`
	SavingsGoal       Amount `json:"savings_goal,omitempty"`

	// SavingsGoalProgress The progress in percentages for the Savings Goal set for this MonetaryAccountSavings.
	SavingsGoalProgress int                    `json:"savings_goal_progress,omitempty"`
	Setting             *MonetaryAccountSetting `json:"setting,omitempty"`

	// Status The status of the MonetaryAccountSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the MonetaryAccountSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the MonetaryAccountSavings's last update.
	Updated string `json:"updated,omitempty"`

	// UserId The id of the User who owns the MonetaryAccountSavings.
	UserId int `json:"user_id,omitempty"`
}

// MonetaryAccountSavingsUpdate defines model for MonetaryAccountSavingsUpdate.
type MonetaryAccountSavingsUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// MonetaryAccountSetting defines model for MonetaryAccountSetting.
type MonetaryAccountSetting struct {
	// Color The color chosen for the MonetaryAccount.
	Color string `json:"color,omitempty"`

	// DefaultAvatarStatus The status of the avatar. Can be either AVATAR_DEFAULT, AVATAR_CUSTOM or AVATAR_UNDETERMINED.
	DefaultAvatarStatus string `json:"default_avatar_status,omitempty"`

	// Icon The icon chosen for the MonetaryAccount.
	Icon string `json:"icon,omitempty"`

	// RestrictionChat The chat restriction. Possible values are ALLOW_INCOMING or BLOCK_INCOMING
	RestrictionChat string `json:"restriction_chat,omitempty"`

	// SddExpirationAction The preference for this monetary account on whether to automatically accept or reject expiring SDDs.
	SddExpirationAction string `json:"sdd_expiration_action,omitempty"`
}

// MonetaryAccountSwitchService defines model for MonetaryAccountSwitchService.
type MonetaryAccountSwitchService struct {
	// Created The timestamp of the monetary account's creation.
	Created string `json:"created,omitempty"`

	// Description The description for the bank account.
	Description string `json:"description,omitempty"`

	// Id The id of the monetary account.
	Id int `json:"id,omitempty"`

	// Status The status of the account.
	Status string `json:"status,omitempty"`

	// SubStatus The sub-status of the account.
	SubStatus string `json:"sub_status,omitempty"`
}

// NoteAttachmentAdyenCardTransaction defines model for NoteAttachmentAdyenCardTransaction.
type NoteAttachmentAdyenCardTransaction struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentAdyenCardTransactionCreate defines model for NoteAttachmentAdyenCardTransactionCreate.
type NoteAttachmentAdyenCardTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentAdyenCardTransactionDelete defines model for NoteAttachmentAdyenCardTransactionDelete.
type NoteAttachmentAdyenCardTransactionDelete = map[string]interface{}

// NoteAttachmentAdyenCardTransactionListing defines model for NoteAttachmentAdyenCardTransactionListing.
type NoteAttachmentAdyenCardTransactionListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentAdyenCardTransactionRead defines model for NoteAttachmentAdyenCardTransactionRead.
type NoteAttachmentAdyenCardTransactionRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentAdyenCardTransactionUpdate defines model for NoteAttachmentAdyenCardTransactionUpdate.
type NoteAttachmentAdyenCardTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentBankSwitchServiceNetherlandsIncomingPayment defines model for NoteAttachmentBankSwitchServiceNetherlandsIncomingPayment.
type NoteAttachmentBankSwitchServiceNetherlandsIncomingPayment struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentCreate defines model for NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentCreate.
type NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentDelete defines model for NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentDelete.
type NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentDelete = map[string]interface{}

// NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing defines model for NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing.
type NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentRead defines model for NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentRead.
type NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentUpdate defines model for NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentUpdate.
type NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentBunqMeFundraiserResult defines model for NoteAttachmentBunqMeFundraiserResult.
type NoteAttachmentBunqMeFundraiserResult struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentBunqMeFundraiserResultCreate defines model for NoteAttachmentBunqMeFundraiserResultCreate.
type NoteAttachmentBunqMeFundraiserResultCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentBunqMeFundraiserResultDelete defines model for NoteAttachmentBunqMeFundraiserResultDelete.
type NoteAttachmentBunqMeFundraiserResultDelete = map[string]interface{}

// NoteAttachmentBunqMeFundraiserResultListing defines model for NoteAttachmentBunqMeFundraiserResultListing.
type NoteAttachmentBunqMeFundraiserResultListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentBunqMeFundraiserResultRead defines model for NoteAttachmentBunqMeFundraiserResultRead.
type NoteAttachmentBunqMeFundraiserResultRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentBunqMeFundraiserResultUpdate defines model for NoteAttachmentBunqMeFundraiserResultUpdate.
type NoteAttachmentBunqMeFundraiserResultUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentDraftPayment defines model for NoteAttachmentDraftPayment.
type NoteAttachmentDraftPayment struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentDraftPaymentCreate defines model for NoteAttachmentDraftPaymentCreate.
type NoteAttachmentDraftPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentDraftPaymentDelete defines model for NoteAttachmentDraftPaymentDelete.
type NoteAttachmentDraftPaymentDelete = map[string]interface{}

// NoteAttachmentDraftPaymentListing defines model for NoteAttachmentDraftPaymentListing.
type NoteAttachmentDraftPaymentListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentDraftPaymentRead defines model for NoteAttachmentDraftPaymentRead.
type NoteAttachmentDraftPaymentRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentDraftPaymentUpdate defines model for NoteAttachmentDraftPaymentUpdate.
type NoteAttachmentDraftPaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentIdealMerchantTransaction defines model for NoteAttachmentIdealMerchantTransaction.
type NoteAttachmentIdealMerchantTransaction struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentIdealMerchantTransactionCreate defines model for NoteAttachmentIdealMerchantTransactionCreate.
type NoteAttachmentIdealMerchantTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentIdealMerchantTransactionDelete defines model for NoteAttachmentIdealMerchantTransactionDelete.
type NoteAttachmentIdealMerchantTransactionDelete = map[string]interface{}

// NoteAttachmentIdealMerchantTransactionListing defines model for NoteAttachmentIdealMerchantTransactionListing.
type NoteAttachmentIdealMerchantTransactionListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentIdealMerchantTransactionRead defines model for NoteAttachmentIdealMerchantTransactionRead.
type NoteAttachmentIdealMerchantTransactionRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentIdealMerchantTransactionUpdate defines model for NoteAttachmentIdealMerchantTransactionUpdate.
type NoteAttachmentIdealMerchantTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentMasterCardAction defines model for NoteAttachmentMasterCardAction.
type NoteAttachmentMasterCardAction struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description"`
}

// NoteAttachmentMasterCardActionCreate defines model for NoteAttachmentMasterCardActionCreate.
type NoteAttachmentMasterCardActionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentMasterCardActionDelete defines model for NoteAttachmentMasterCardActionDelete.
type NoteAttachmentMasterCardActionDelete = map[string]interface{}

// NoteAttachmentMasterCardActionListing defines model for NoteAttachmentMasterCardActionListing.
type NoteAttachmentMasterCardActionListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentMasterCardActionRead defines model for NoteAttachmentMasterCardActionRead.
type NoteAttachmentMasterCardActionRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentMasterCardActionUpdate defines model for NoteAttachmentMasterCardActionUpdate.
type NoteAttachmentMasterCardActionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentOpenBankingMerchantTransaction defines model for NoteAttachmentOpenBankingMerchantTransaction.
type NoteAttachmentOpenBankingMerchantTransaction struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentOpenBankingMerchantTransactionCreate defines model for NoteAttachmentOpenBankingMerchantTransactionCreate.
type NoteAttachmentOpenBankingMerchantTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentOpenBankingMerchantTransactionDelete defines model for NoteAttachmentOpenBankingMerchantTransactionDelete.
type NoteAttachmentOpenBankingMerchantTransactionDelete = map[string]interface{}

// NoteAttachmentOpenBankingMerchantTransactionListing defines model for NoteAttachmentOpenBankingMerchantTransactionListing.
type NoteAttachmentOpenBankingMerchantTransactionListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentOpenBankingMerchantTransactionRead defines model for NoteAttachmentOpenBankingMerchantTransactionRead.
type NoteAttachmentOpenBankingMerchantTransactionRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentOpenBankingMerchantTransactionUpdate defines model for NoteAttachmentOpenBankingMerchantTransactionUpdate.
type NoteAttachmentOpenBankingMerchantTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentPayment defines model for NoteAttachmentPayment.
type NoteAttachmentPayment struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentPaymentBatch defines model for NoteAttachmentPaymentBatch.
type NoteAttachmentPaymentBatch struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentPaymentBatchCreate defines model for NoteAttachmentPaymentBatchCreate.
type NoteAttachmentPaymentBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentPaymentBatchDelete defines model for NoteAttachmentPaymentBatchDelete.
type NoteAttachmentPaymentBatchDelete = map[string]interface{}

// NoteAttachmentPaymentBatchListing defines model for NoteAttachmentPaymentBatchListing.
type NoteAttachmentPaymentBatchListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentPaymentBatchRead defines model for NoteAttachmentPaymentBatchRead.
type NoteAttachmentPaymentBatchRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentPaymentBatchUpdate defines model for NoteAttachmentPaymentBatchUpdate.
type NoteAttachmentPaymentBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentPaymentCreate defines model for NoteAttachmentPaymentCreate.
type NoteAttachmentPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentPaymentDelayed defines model for NoteAttachmentPaymentDelayed.
type NoteAttachmentPaymentDelayed struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentPaymentDelayedCreate defines model for NoteAttachmentPaymentDelayedCreate.
type NoteAttachmentPaymentDelayedCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentPaymentDelayedDelete defines model for NoteAttachmentPaymentDelayedDelete.
type NoteAttachmentPaymentDelayedDelete = map[string]interface{}

// NoteAttachmentPaymentDelayedListing defines model for NoteAttachmentPaymentDelayedListing.
type NoteAttachmentPaymentDelayedListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentPaymentDelayedRead defines model for NoteAttachmentPaymentDelayedRead.
type NoteAttachmentPaymentDelayedRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentPaymentDelayedUpdate defines model for NoteAttachmentPaymentDelayedUpdate.
type NoteAttachmentPaymentDelayedUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentPaymentDelete defines model for NoteAttachmentPaymentDelete.
type NoteAttachmentPaymentDelete = map[string]interface{}

// NoteAttachmentPaymentListing defines model for NoteAttachmentPaymentListing.
type NoteAttachmentPaymentListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentPaymentRead defines model for NoteAttachmentPaymentRead.
type NoteAttachmentPaymentRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentPaymentUpdate defines model for NoteAttachmentPaymentUpdate.
type NoteAttachmentPaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentRequestInquiry defines model for NoteAttachmentRequestInquiry.
type NoteAttachmentRequestInquiry struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentRequestInquiryBatch defines model for NoteAttachmentRequestInquiryBatch.
type NoteAttachmentRequestInquiryBatch struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentRequestInquiryBatchCreate defines model for NoteAttachmentRequestInquiryBatchCreate.
type NoteAttachmentRequestInquiryBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentRequestInquiryBatchDelete defines model for NoteAttachmentRequestInquiryBatchDelete.
type NoteAttachmentRequestInquiryBatchDelete = map[string]interface{}

// NoteAttachmentRequestInquiryBatchListing defines model for NoteAttachmentRequestInquiryBatchListing.
type NoteAttachmentRequestInquiryBatchListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentRequestInquiryBatchRead defines model for NoteAttachmentRequestInquiryBatchRead.
type NoteAttachmentRequestInquiryBatchRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentRequestInquiryBatchUpdate defines model for NoteAttachmentRequestInquiryBatchUpdate.
type NoteAttachmentRequestInquiryBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentRequestInquiryCreate defines model for NoteAttachmentRequestInquiryCreate.
type NoteAttachmentRequestInquiryCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentRequestInquiryDelete defines model for NoteAttachmentRequestInquiryDelete.
type NoteAttachmentRequestInquiryDelete = map[string]interface{}

// NoteAttachmentRequestInquiryListing defines model for NoteAttachmentRequestInquiryListing.
type NoteAttachmentRequestInquiryListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentRequestInquiryRead defines model for NoteAttachmentRequestInquiryRead.
type NoteAttachmentRequestInquiryRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentRequestInquiryUpdate defines model for NoteAttachmentRequestInquiryUpdate.
type NoteAttachmentRequestInquiryUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentRequestResponse defines model for NoteAttachmentRequestResponse.
type NoteAttachmentRequestResponse struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentRequestResponseCreate defines model for NoteAttachmentRequestResponseCreate.
type NoteAttachmentRequestResponseCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentRequestResponseDelete defines model for NoteAttachmentRequestResponseDelete.
type NoteAttachmentRequestResponseDelete = map[string]interface{}

// NoteAttachmentRequestResponseListing defines model for NoteAttachmentRequestResponseListing.
type NoteAttachmentRequestResponseListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentRequestResponseRead defines model for NoteAttachmentRequestResponseRead.
type NoteAttachmentRequestResponseRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentRequestResponseUpdate defines model for NoteAttachmentRequestResponseUpdate.
type NoteAttachmentRequestResponseUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentScheduleInstance defines model for NoteAttachmentScheduleInstance.
type NoteAttachmentScheduleInstance struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentScheduleInstanceCreate defines model for NoteAttachmentScheduleInstanceCreate.
type NoteAttachmentScheduleInstanceCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentScheduleInstanceDelete defines model for NoteAttachmentScheduleInstanceDelete.
type NoteAttachmentScheduleInstanceDelete = map[string]interface{}

// NoteAttachmentScheduleInstanceListing defines model for NoteAttachmentScheduleInstanceListing.
type NoteAttachmentScheduleInstanceListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentScheduleInstanceRead defines model for NoteAttachmentScheduleInstanceRead.
type NoteAttachmentScheduleInstanceRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentScheduleInstanceUpdate defines model for NoteAttachmentScheduleInstanceUpdate.
type NoteAttachmentScheduleInstanceUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentSchedulePayment defines model for NoteAttachmentSchedulePayment.
type NoteAttachmentSchedulePayment struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentSchedulePaymentBatch defines model for NoteAttachmentSchedulePaymentBatch.
type NoteAttachmentSchedulePaymentBatch struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentSchedulePaymentBatchCreate defines model for NoteAttachmentSchedulePaymentBatchCreate.
type NoteAttachmentSchedulePaymentBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentSchedulePaymentBatchDelete defines model for NoteAttachmentSchedulePaymentBatchDelete.
type NoteAttachmentSchedulePaymentBatchDelete = map[string]interface{}

// NoteAttachmentSchedulePaymentBatchListing defines model for NoteAttachmentSchedulePaymentBatchListing.
type NoteAttachmentSchedulePaymentBatchListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentSchedulePaymentBatchRead defines model for NoteAttachmentSchedulePaymentBatchRead.
type NoteAttachmentSchedulePaymentBatchRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentSchedulePaymentBatchUpdate defines model for NoteAttachmentSchedulePaymentBatchUpdate.
type NoteAttachmentSchedulePaymentBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentSchedulePaymentCreate defines model for NoteAttachmentSchedulePaymentCreate.
type NoteAttachmentSchedulePaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentSchedulePaymentDelete defines model for NoteAttachmentSchedulePaymentDelete.
type NoteAttachmentSchedulePaymentDelete = map[string]interface{}

// NoteAttachmentSchedulePaymentListing defines model for NoteAttachmentSchedulePaymentListing.
type NoteAttachmentSchedulePaymentListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentSchedulePaymentRead defines model for NoteAttachmentSchedulePaymentRead.
type NoteAttachmentSchedulePaymentRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentSchedulePaymentUpdate defines model for NoteAttachmentSchedulePaymentUpdate.
type NoteAttachmentSchedulePaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentScheduleRequest defines model for NoteAttachmentScheduleRequest.
type NoteAttachmentScheduleRequest struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentScheduleRequestBatch defines model for NoteAttachmentScheduleRequestBatch.
type NoteAttachmentScheduleRequestBatch struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentScheduleRequestBatchCreate defines model for NoteAttachmentScheduleRequestBatchCreate.
type NoteAttachmentScheduleRequestBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentScheduleRequestBatchDelete defines model for NoteAttachmentScheduleRequestBatchDelete.
type NoteAttachmentScheduleRequestBatchDelete = map[string]interface{}

// NoteAttachmentScheduleRequestBatchListing defines model for NoteAttachmentScheduleRequestBatchListing.
type NoteAttachmentScheduleRequestBatchListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentScheduleRequestBatchRead defines model for NoteAttachmentScheduleRequestBatchRead.
type NoteAttachmentScheduleRequestBatchRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentScheduleRequestBatchUpdate defines model for NoteAttachmentScheduleRequestBatchUpdate.
type NoteAttachmentScheduleRequestBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentScheduleRequestCreate defines model for NoteAttachmentScheduleRequestCreate.
type NoteAttachmentScheduleRequestCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentScheduleRequestDelete defines model for NoteAttachmentScheduleRequestDelete.
type NoteAttachmentScheduleRequestDelete = map[string]interface{}

// NoteAttachmentScheduleRequestListing defines model for NoteAttachmentScheduleRequestListing.
type NoteAttachmentScheduleRequestListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentScheduleRequestRead defines model for NoteAttachmentScheduleRequestRead.
type NoteAttachmentScheduleRequestRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentScheduleRequestUpdate defines model for NoteAttachmentScheduleRequestUpdate.
type NoteAttachmentScheduleRequestUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentSofortMerchantTransaction defines model for NoteAttachmentSofortMerchantTransaction.
type NoteAttachmentSofortMerchantTransaction struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentSofortMerchantTransactionCreate defines model for NoteAttachmentSofortMerchantTransactionCreate.
type NoteAttachmentSofortMerchantTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentSofortMerchantTransactionDelete defines model for NoteAttachmentSofortMerchantTransactionDelete.
type NoteAttachmentSofortMerchantTransactionDelete = map[string]interface{}

// NoteAttachmentSofortMerchantTransactionListing defines model for NoteAttachmentSofortMerchantTransactionListing.
type NoteAttachmentSofortMerchantTransactionListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentSofortMerchantTransactionRead defines model for NoteAttachmentSofortMerchantTransactionRead.
type NoteAttachmentSofortMerchantTransactionRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentSofortMerchantTransactionUpdate defines model for NoteAttachmentSofortMerchantTransactionUpdate.
type NoteAttachmentSofortMerchantTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentWhitelistResult defines model for NoteAttachmentWhitelistResult.
type NoteAttachmentWhitelistResult struct {
	// AttachmentId The reference to the uploaded file to attach to this note.
	AttachmentId int `json:"attachment_id,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`
}

// NoteAttachmentWhitelistResultCreate defines model for NoteAttachmentWhitelistResultCreate.
type NoteAttachmentWhitelistResultCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteAttachmentWhitelistResultDelete defines model for NoteAttachmentWhitelistResultDelete.
type NoteAttachmentWhitelistResultDelete = map[string]interface{}

// NoteAttachmentWhitelistResultListing defines model for NoteAttachmentWhitelistResultListing.
type NoteAttachmentWhitelistResultListing struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentWhitelistResultRead defines model for NoteAttachmentWhitelistResultRead.
type NoteAttachmentWhitelistResultRead struct {
	// Attachment The attachment attached to the note.
	Attachment []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Description Optional description of the attachment.
	Description string `json:"description,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteAttachmentWhitelistResultUpdate defines model for NoteAttachmentWhitelistResultUpdate.
type NoteAttachmentWhitelistResultUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextAdyenCardTransaction defines model for NoteTextAdyenCardTransaction.
type NoteTextAdyenCardTransaction struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextAdyenCardTransactionCreate defines model for NoteTextAdyenCardTransactionCreate.
type NoteTextAdyenCardTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextAdyenCardTransactionDelete defines model for NoteTextAdyenCardTransactionDelete.
type NoteTextAdyenCardTransactionDelete = map[string]interface{}

// NoteTextAdyenCardTransactionListing defines model for NoteTextAdyenCardTransactionListing.
type NoteTextAdyenCardTransactionListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextAdyenCardTransactionRead defines model for NoteTextAdyenCardTransactionRead.
type NoteTextAdyenCardTransactionRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextAdyenCardTransactionUpdate defines model for NoteTextAdyenCardTransactionUpdate.
type NoteTextAdyenCardTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextBankSwitchServiceNetherlandsIncomingPayment defines model for NoteTextBankSwitchServiceNetherlandsIncomingPayment.
type NoteTextBankSwitchServiceNetherlandsIncomingPayment struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextBankSwitchServiceNetherlandsIncomingPaymentCreate defines model for NoteTextBankSwitchServiceNetherlandsIncomingPaymentCreate.
type NoteTextBankSwitchServiceNetherlandsIncomingPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextBankSwitchServiceNetherlandsIncomingPaymentDelete defines model for NoteTextBankSwitchServiceNetherlandsIncomingPaymentDelete.
type NoteTextBankSwitchServiceNetherlandsIncomingPaymentDelete = map[string]interface{}

// NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing defines model for NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing.
type NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextBankSwitchServiceNetherlandsIncomingPaymentRead defines model for NoteTextBankSwitchServiceNetherlandsIncomingPaymentRead.
type NoteTextBankSwitchServiceNetherlandsIncomingPaymentRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextBankSwitchServiceNetherlandsIncomingPaymentUpdate defines model for NoteTextBankSwitchServiceNetherlandsIncomingPaymentUpdate.
type NoteTextBankSwitchServiceNetherlandsIncomingPaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextBunqMeFundraiserResult defines model for NoteTextBunqMeFundraiserResult.
type NoteTextBunqMeFundraiserResult struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextBunqMeFundraiserResultCreate defines model for NoteTextBunqMeFundraiserResultCreate.
type NoteTextBunqMeFundraiserResultCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextBunqMeFundraiserResultDelete defines model for NoteTextBunqMeFundraiserResultDelete.
type NoteTextBunqMeFundraiserResultDelete = map[string]interface{}

// NoteTextBunqMeFundraiserResultListing defines model for NoteTextBunqMeFundraiserResultListing.
type NoteTextBunqMeFundraiserResultListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextBunqMeFundraiserResultRead defines model for NoteTextBunqMeFundraiserResultRead.
type NoteTextBunqMeFundraiserResultRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextBunqMeFundraiserResultUpdate defines model for NoteTextBunqMeFundraiserResultUpdate.
type NoteTextBunqMeFundraiserResultUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextDraftPayment defines model for NoteTextDraftPayment.
type NoteTextDraftPayment struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextDraftPaymentCreate defines model for NoteTextDraftPaymentCreate.
type NoteTextDraftPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextDraftPaymentDelete defines model for NoteTextDraftPaymentDelete.
type NoteTextDraftPaymentDelete = map[string]interface{}

// NoteTextDraftPaymentListing defines model for NoteTextDraftPaymentListing.
type NoteTextDraftPaymentListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextDraftPaymentRead defines model for NoteTextDraftPaymentRead.
type NoteTextDraftPaymentRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextDraftPaymentUpdate defines model for NoteTextDraftPaymentUpdate.
type NoteTextDraftPaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextIdealMerchantTransaction defines model for NoteTextIdealMerchantTransaction.
type NoteTextIdealMerchantTransaction struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextIdealMerchantTransactionCreate defines model for NoteTextIdealMerchantTransactionCreate.
type NoteTextIdealMerchantTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextIdealMerchantTransactionDelete defines model for NoteTextIdealMerchantTransactionDelete.
type NoteTextIdealMerchantTransactionDelete = map[string]interface{}

// NoteTextIdealMerchantTransactionListing defines model for NoteTextIdealMerchantTransactionListing.
type NoteTextIdealMerchantTransactionListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextIdealMerchantTransactionRead defines model for NoteTextIdealMerchantTransactionRead.
type NoteTextIdealMerchantTransactionRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextIdealMerchantTransactionUpdate defines model for NoteTextIdealMerchantTransactionUpdate.
type NoteTextIdealMerchantTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextMasterCardAction defines model for NoteTextMasterCardAction.
type NoteTextMasterCardAction struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextMasterCardActionCreate defines model for NoteTextMasterCardActionCreate.
type NoteTextMasterCardActionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextMasterCardActionDelete defines model for NoteTextMasterCardActionDelete.
type NoteTextMasterCardActionDelete = map[string]interface{}

// NoteTextMasterCardActionListing defines model for NoteTextMasterCardActionListing.
type NoteTextMasterCardActionListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextMasterCardActionRead defines model for NoteTextMasterCardActionRead.
type NoteTextMasterCardActionRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextMasterCardActionUpdate defines model for NoteTextMasterCardActionUpdate.
type NoteTextMasterCardActionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextOpenBankingMerchantTransaction defines model for NoteTextOpenBankingMerchantTransaction.
type NoteTextOpenBankingMerchantTransaction struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextOpenBankingMerchantTransactionCreate defines model for NoteTextOpenBankingMerchantTransactionCreate.
type NoteTextOpenBankingMerchantTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextOpenBankingMerchantTransactionDelete defines model for NoteTextOpenBankingMerchantTransactionDelete.
type NoteTextOpenBankingMerchantTransactionDelete = map[string]interface{}

// NoteTextOpenBankingMerchantTransactionListing defines model for NoteTextOpenBankingMerchantTransactionListing.
type NoteTextOpenBankingMerchantTransactionListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextOpenBankingMerchantTransactionRead defines model for NoteTextOpenBankingMerchantTransactionRead.
type NoteTextOpenBankingMerchantTransactionRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextOpenBankingMerchantTransactionUpdate defines model for NoteTextOpenBankingMerchantTransactionUpdate.
type NoteTextOpenBankingMerchantTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextPayment defines model for NoteTextPayment.
type NoteTextPayment struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextPaymentBatch defines model for NoteTextPaymentBatch.
type NoteTextPaymentBatch struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextPaymentBatchCreate defines model for NoteTextPaymentBatchCreate.
type NoteTextPaymentBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextPaymentBatchDelete defines model for NoteTextPaymentBatchDelete.
type NoteTextPaymentBatchDelete = map[string]interface{}

// NoteTextPaymentBatchListing defines model for NoteTextPaymentBatchListing.
type NoteTextPaymentBatchListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextPaymentBatchRead defines model for NoteTextPaymentBatchRead.
type NoteTextPaymentBatchRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextPaymentBatchUpdate defines model for NoteTextPaymentBatchUpdate.
type NoteTextPaymentBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextPaymentCreate defines model for NoteTextPaymentCreate.
type NoteTextPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextPaymentDelayed defines model for NoteTextPaymentDelayed.
type NoteTextPaymentDelayed struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextPaymentDelayedCreate defines model for NoteTextPaymentDelayedCreate.
type NoteTextPaymentDelayedCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextPaymentDelayedDelete defines model for NoteTextPaymentDelayedDelete.
type NoteTextPaymentDelayedDelete = map[string]interface{}

// NoteTextPaymentDelayedListing defines model for NoteTextPaymentDelayedListing.
type NoteTextPaymentDelayedListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextPaymentDelayedRead defines model for NoteTextPaymentDelayedRead.
type NoteTextPaymentDelayedRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextPaymentDelayedUpdate defines model for NoteTextPaymentDelayedUpdate.
type NoteTextPaymentDelayedUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextPaymentDelete defines model for NoteTextPaymentDelete.
type NoteTextPaymentDelete = map[string]interface{}

// NoteTextPaymentListing defines model for NoteTextPaymentListing.
type NoteTextPaymentListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextPaymentRead defines model for NoteTextPaymentRead.
type NoteTextPaymentRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextPaymentUpdate defines model for NoteTextPaymentUpdate.
type NoteTextPaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextRequestInquiry defines model for NoteTextRequestInquiry.
type NoteTextRequestInquiry struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextRequestInquiryBatch defines model for NoteTextRequestInquiryBatch.
type NoteTextRequestInquiryBatch struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextRequestInquiryBatchCreate defines model for NoteTextRequestInquiryBatchCreate.
type NoteTextRequestInquiryBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextRequestInquiryBatchDelete defines model for NoteTextRequestInquiryBatchDelete.
type NoteTextRequestInquiryBatchDelete = map[string]interface{}

// NoteTextRequestInquiryBatchListing defines model for NoteTextRequestInquiryBatchListing.
type NoteTextRequestInquiryBatchListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextRequestInquiryBatchRead defines model for NoteTextRequestInquiryBatchRead.
type NoteTextRequestInquiryBatchRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextRequestInquiryBatchUpdate defines model for NoteTextRequestInquiryBatchUpdate.
type NoteTextRequestInquiryBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextRequestInquiryCreate defines model for NoteTextRequestInquiryCreate.
type NoteTextRequestInquiryCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextRequestInquiryDelete defines model for NoteTextRequestInquiryDelete.
type NoteTextRequestInquiryDelete = map[string]interface{}

// NoteTextRequestInquiryListing defines model for NoteTextRequestInquiryListing.
type NoteTextRequestInquiryListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextRequestInquiryRead defines model for NoteTextRequestInquiryRead.
type NoteTextRequestInquiryRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextRequestInquiryUpdate defines model for NoteTextRequestInquiryUpdate.
type NoteTextRequestInquiryUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextRequestResponse defines model for NoteTextRequestResponse.
type NoteTextRequestResponse struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextRequestResponseCreate defines model for NoteTextRequestResponseCreate.
type NoteTextRequestResponseCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextRequestResponseDelete defines model for NoteTextRequestResponseDelete.
type NoteTextRequestResponseDelete = map[string]interface{}

// NoteTextRequestResponseListing defines model for NoteTextRequestResponseListing.
type NoteTextRequestResponseListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextRequestResponseRead defines model for NoteTextRequestResponseRead.
type NoteTextRequestResponseRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextRequestResponseUpdate defines model for NoteTextRequestResponseUpdate.
type NoteTextRequestResponseUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextScheduleInstance defines model for NoteTextScheduleInstance.
type NoteTextScheduleInstance struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextScheduleInstanceCreate defines model for NoteTextScheduleInstanceCreate.
type NoteTextScheduleInstanceCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextScheduleInstanceDelete defines model for NoteTextScheduleInstanceDelete.
type NoteTextScheduleInstanceDelete = map[string]interface{}

// NoteTextScheduleInstanceListing defines model for NoteTextScheduleInstanceListing.
type NoteTextScheduleInstanceListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextScheduleInstanceRead defines model for NoteTextScheduleInstanceRead.
type NoteTextScheduleInstanceRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextScheduleInstanceUpdate defines model for NoteTextScheduleInstanceUpdate.
type NoteTextScheduleInstanceUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextSchedulePayment defines model for NoteTextSchedulePayment.
type NoteTextSchedulePayment struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextSchedulePaymentBatch defines model for NoteTextSchedulePaymentBatch.
type NoteTextSchedulePaymentBatch struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextSchedulePaymentBatchCreate defines model for NoteTextSchedulePaymentBatchCreate.
type NoteTextSchedulePaymentBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextSchedulePaymentBatchDelete defines model for NoteTextSchedulePaymentBatchDelete.
type NoteTextSchedulePaymentBatchDelete = map[string]interface{}

// NoteTextSchedulePaymentBatchListing defines model for NoteTextSchedulePaymentBatchListing.
type NoteTextSchedulePaymentBatchListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextSchedulePaymentBatchRead defines model for NoteTextSchedulePaymentBatchRead.
type NoteTextSchedulePaymentBatchRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextSchedulePaymentBatchUpdate defines model for NoteTextSchedulePaymentBatchUpdate.
type NoteTextSchedulePaymentBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextSchedulePaymentCreate defines model for NoteTextSchedulePaymentCreate.
type NoteTextSchedulePaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextSchedulePaymentDelete defines model for NoteTextSchedulePaymentDelete.
type NoteTextSchedulePaymentDelete = map[string]interface{}

// NoteTextSchedulePaymentListing defines model for NoteTextSchedulePaymentListing.
type NoteTextSchedulePaymentListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextSchedulePaymentRead defines model for NoteTextSchedulePaymentRead.
type NoteTextSchedulePaymentRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextSchedulePaymentUpdate defines model for NoteTextSchedulePaymentUpdate.
type NoteTextSchedulePaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextScheduleRequest defines model for NoteTextScheduleRequest.
type NoteTextScheduleRequest struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextScheduleRequestBatch defines model for NoteTextScheduleRequestBatch.
type NoteTextScheduleRequestBatch struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextScheduleRequestBatchCreate defines model for NoteTextScheduleRequestBatchCreate.
type NoteTextScheduleRequestBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextScheduleRequestBatchDelete defines model for NoteTextScheduleRequestBatchDelete.
type NoteTextScheduleRequestBatchDelete = map[string]interface{}

// NoteTextScheduleRequestBatchListing defines model for NoteTextScheduleRequestBatchListing.
type NoteTextScheduleRequestBatchListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextScheduleRequestBatchRead defines model for NoteTextScheduleRequestBatchRead.
type NoteTextScheduleRequestBatchRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextScheduleRequestBatchUpdate defines model for NoteTextScheduleRequestBatchUpdate.
type NoteTextScheduleRequestBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextScheduleRequestCreate defines model for NoteTextScheduleRequestCreate.
type NoteTextScheduleRequestCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextScheduleRequestDelete defines model for NoteTextScheduleRequestDelete.
type NoteTextScheduleRequestDelete = map[string]interface{}

// NoteTextScheduleRequestListing defines model for NoteTextScheduleRequestListing.
type NoteTextScheduleRequestListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextScheduleRequestRead defines model for NoteTextScheduleRequestRead.
type NoteTextScheduleRequestRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextScheduleRequestUpdate defines model for NoteTextScheduleRequestUpdate.
type NoteTextScheduleRequestUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextSofortMerchantTransaction defines model for NoteTextSofortMerchantTransaction.
type NoteTextSofortMerchantTransaction struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextSofortMerchantTransactionCreate defines model for NoteTextSofortMerchantTransactionCreate.
type NoteTextSofortMerchantTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextSofortMerchantTransactionDelete defines model for NoteTextSofortMerchantTransactionDelete.
type NoteTextSofortMerchantTransactionDelete = map[string]interface{}

// NoteTextSofortMerchantTransactionListing defines model for NoteTextSofortMerchantTransactionListing.
type NoteTextSofortMerchantTransactionListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextSofortMerchantTransactionRead defines model for NoteTextSofortMerchantTransactionRead.
type NoteTextSofortMerchantTransactionRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextSofortMerchantTransactionUpdate defines model for NoteTextSofortMerchantTransactionUpdate.
type NoteTextSofortMerchantTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextWhitelistResult defines model for NoteTextWhitelistResult.
type NoteTextWhitelistResult struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`
}

// NoteTextWhitelistResultCreate defines model for NoteTextWhitelistResultCreate.
type NoteTextWhitelistResultCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NoteTextWhitelistResultDelete defines model for NoteTextWhitelistResultDelete.
type NoteTextWhitelistResultDelete = map[string]interface{}

// NoteTextWhitelistResultListing defines model for NoteTextWhitelistResultListing.
type NoteTextWhitelistResultListing struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextWhitelistResultRead defines model for NoteTextWhitelistResultRead.
type NoteTextWhitelistResultRead struct {
	// Content The content of the note.
	Content string `json:"content,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the note.
	Id               int       `json:"id,omitempty"`
	LabelUserCreator *LabelUser `json:"label_user_creator,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// NoteTextWhitelistResultUpdate defines model for NoteTextWhitelistResultUpdate.
type NoteTextWhitelistResultUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NotificationFilter defines model for NotificationFilter.
type NotificationFilter struct {
	// Category The notification category that will match this notification filter. Possible choices are BILLING, CARD_TRANSACTION_FAILED, CARD_TRANSACTION_SUCCESSFUL, CHAT, DRAFT_PAYMENT, IDEAL, SOFORT, MONETARY_ACCOUNT_PROFILE, MUTATION, PAYMENT, PROMOTION, REQUEST, SCHEDULE_RESULT, SCHEDULE_STATUS, SHARE, SUPPORT, TAB_RESULT, USER_APPROVAL.
	Category string `json:"category,omitempty"`

	// NotificationDeliveryMethod The delivery method via which notifications that match this notification filter will be delivered. Possible choices are PUSH for delivery via push notification and URL for delivery via URL callback.
	NotificationDeliveryMethod string `json:"notification_delivery_method,omitempty"`

	// NotificationTarget The target of notifications that match this notification filter. For URL notification filters this is the URL to which the callback will be made. For PUSH notifications filters this should always be null.
	NotificationTarget string `json:"notification_target,omitempty"`
}

// NotificationFilterEmail defines model for NotificationFilterEmail.
type NotificationFilterEmail struct {
	// NotificationFilters The types of notifications that will result in a email notification for this user.
	NotificationFilters []NotificationFilterEmail `json:"notification_filters,omitempty"`
}

// NotificationFilterEmailCreate defines model for NotificationFilterEmailCreate.
type NotificationFilterEmailCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NotificationFilterEmailListing defines model for NotificationFilterEmailListing.
type NotificationFilterEmailListing struct {
	// NotificationFilters The types of notifications that will result in a email notification for this user.
	NotificationFilters []NotificationFilterEmail `json:"notification_filters,omitempty"`
}

// NotificationFilterFailure defines model for NotificationFilterFailure.
type NotificationFilterFailure struct {
	// NotificationFilterFailedIds The IDs to retry.
	NotificationFilterFailedIds string `json:"notification_filter_failed_ids,omitempty"`
}

// NotificationFilterFailureCreate defines model for NotificationFilterFailureCreate.
type NotificationFilterFailureCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NotificationFilterFailureListing defines model for NotificationFilterFailureListing.
type NotificationFilterFailureListing struct {
	// Category The category of the failed notification.
	Category string `json:"category,omitempty"`

	// EventType The event type of the failed notification.
	EventType string `json:"event_type,omitempty"`

	// ExceptionMessage The exception bunq encountered when processing the callback.
	ExceptionMessage string `json:"exception_message,omitempty"`

	// NotificationFilters The types of notifications that will result in a url notification for this user.
	NotificationFilters []NotificationFilter `json:"notification_filters,omitempty"`

	// ObjectId The object id used to generate the body of the notification.
	ObjectId int `json:"object_id,omitempty"`

	// ResponseCode The response code (or null) received from the endpoint.
	ResponseCode int `json:"response_code,omitempty"`
}

// NotificationFilterPush defines model for NotificationFilterPush.
type NotificationFilterPush struct {
	// NotificationFilters The types of notifications that will result in a push notification for this user.
	NotificationFilters []NotificationFilterPush `json:"notification_filters,omitempty"`
}

// NotificationFilterPushCreate defines model for NotificationFilterPushCreate.
type NotificationFilterPushCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NotificationFilterPushListing defines model for NotificationFilterPushListing.
type NotificationFilterPushListing struct {
	// NotificationFilters The types of notifications that will result in a push notification for this user.
	NotificationFilters []NotificationFilterPush `json:"notification_filters,omitempty"`
}

// NotificationFilterUrl defines model for NotificationFilterUrl.
type NotificationFilterUrl struct {
	// NotificationFilters The types of notifications that will result in a url notification for this user.
	NotificationFilters []NotificationFilterUrl `json:"notification_filters,omitempty"`
}

// NotificationFilterUrlCreate defines model for NotificationFilterUrlCreate.
type NotificationFilterUrlCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NotificationFilterUrlListing defines model for NotificationFilterUrlListing.
type NotificationFilterUrlListing struct {
	// NotificationFilters The types of notifications that will result in a url notification for this user.
	NotificationFilters []NotificationFilterUrl `json:"notification_filters,omitempty"`
}

// NotificationFilterUrlMonetaryAccount defines model for NotificationFilterUrlMonetaryAccount.
type NotificationFilterUrlMonetaryAccount struct {
	// NotificationFilters The types of notifications that will result in a url notification for this monetary account.
	NotificationFilters []NotificationFilterUrl `json:"notification_filters,omitempty"`
}

// NotificationFilterUrlMonetaryAccountCreate defines model for NotificationFilterUrlMonetaryAccountCreate.
type NotificationFilterUrlMonetaryAccountCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// NotificationFilterUrlMonetaryAccountListing defines model for NotificationFilterUrlMonetaryAccountListing.
type NotificationFilterUrlMonetaryAccountListing struct {
	// NotificationFilters The types of notifications that will result in a url notification for this monetary account.
	NotificationFilters []NotificationFilterUrl `json:"notification_filters,omitempty"`
}

// OauthCallbackUrl defines model for OauthCallbackUrl.
type OauthCallbackUrl struct {
	// Url The URL for this callback.
	Url string `json:"url"`
}

// OauthCallbackUrlCreate defines model for OauthCallbackUrlCreate.
type OauthCallbackUrlCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// OauthCallbackUrlDelete defines model for OauthCallbackUrlDelete.
type OauthCallbackUrlDelete = map[string]interface{}

// OauthCallbackUrlListing defines model for OauthCallbackUrlListing.
type OauthCallbackUrlListing struct {
	// Url The URL for this callback.
	Url string `json:"url,omitempty"`
}

// OauthCallbackUrlRead defines model for OauthCallbackUrlRead.
type OauthCallbackUrlRead struct {
	// Url The URL for this callback.
	Url string `json:"url,omitempty"`
}

// OauthCallbackUrlUpdate defines model for OauthCallbackUrlUpdate.
type OauthCallbackUrlUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// OauthClient defines model for OauthClient.
type OauthClient struct {
	// Status The status of the Oauth Client, can be ACTIVE or CANCELLED.
	Status string `json:"status,omitempty"`
}

// OauthClientCreate defines model for OauthClientCreate.
type OauthClientCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// OauthClientListing defines model for OauthClientListing.
type OauthClientListing struct {
	// CallbackUrl The callback URLs which are bound to this Oauth Client
	CallbackUrl []OauthCallbackUrl `json:"callback_url,omitempty"`

	// ClientId The Client ID associated with this Oauth Client
	ClientId string `json:"client_id,omitempty"`

	// DisplayName The display name of this Oauth Client
	DisplayName string `json:"display_name,omitempty"`

	// Id Id of the client.
	Id int `json:"id,omitempty"`

	// Secret Secret associated with this Oauth Client
	Secret string `json:"secret,omitempty"`

	// Status The status of the pack group, can be ACTIVE, CANCELLED or CANCELLED_PENDING.
	Status string `json:"status,omitempty"`
}

// OauthClientRead defines model for OauthClientRead.
type OauthClientRead struct {
	// CallbackUrl The callback URLs which are bound to this Oauth Client
	CallbackUrl []OauthCallbackUrl `json:"callback_url,omitempty"`

	// ClientId The Client ID associated with this Oauth Client
	ClientId string `json:"client_id,omitempty"`

	// DisplayName The display name of this Oauth Client
	DisplayName string `json:"display_name,omitempty"`

	// Id Id of the client.
	Id int `json:"id,omitempty"`

	// Secret Secret associated with this Oauth Client
	Secret string `json:"secret,omitempty"`

	// Status The status of the pack group, can be ACTIVE, CANCELLED or CANCELLED_PENDING.
	Status string `json:"status,omitempty"`
}

// OauthClientUpdate defines model for OauthClientUpdate.
type OauthClientUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// OpenBankingAccount defines model for OpenBankingAccount.
type OpenBankingAccount struct {
	BalanceAvailable Amount `json:"balance_available,omitempty"`
	BalanceBooked    Amount `json:"balance_booked,omitempty"`

	// Iban The iban of this account.
	Iban         string                  `json:"iban,omitempty"`
	ProviderBank *OpenBankingProviderBank `json:"provider_bank,omitempty"`

	// Status The status of this account.
	Status string `json:"status,omitempty"`

	// TimeSyncedLast The timestamp of the last time the account was synced with our open banking partner.
	TimeSyncedLast string `json:"time_synced_last,omitempty"`
}

// OpenBankingProviderBank defines model for OpenBankingProviderBank.
type OpenBankingProviderBank struct {
	// AccountInformationServiceStatus Whether we support Open Banking budgeting using the bank provider.
	AccountInformationServiceStatus string `json:"account_information_service_status,omitempty"`

	// AiiaProviderId The external identifier for this bank.
	AiiaProviderId string `json:"aiia_provider_id,omitempty"`

	// AllPaymentMethodAllowedDomestic All payment methods allowed for Domestic payments.
	AllPaymentMethodAllowedDomestic []string `json:"all_payment_method_allowed_domestic,omitempty"`

	// AllPaymentMethodAllowedSepa All payment methods allowed for Sepa payments.
	AllPaymentMethodAllowedSepa []string `json:"all_payment_method_allowed_sepa,omitempty"`

	// AudienceBusinessStatus Whether business banking is supported by the provider.
	AudienceBusinessStatus bool `json:"audience_business_status,omitempty"`

	// AudiencePrivateStatus Whether personal banking is supported by the provider.
	AudiencePrivateStatus bool   `json:"audience_private_status,omitempty"`
	Avatar                *Avatar `json:"avatar,omitempty"`

	// Country Country of provider
	Country string `json:"country,omitempty"`

	// Name The name of the bank provider.
	Name string `json:"name,omitempty"`

	// PaymentInformationServiceStatus Whether we support top ups using the bank provider.
	PaymentInformationServiceStatus string `json:"payment_information_service_status,omitempty"`
}

// Payment defines model for Payment.
type Payment struct {
	AddressBilling  *Address              `json:"address_billing,omitempty"`
	AddressShipping *Address              `json:"address_shipping,omitempty"`
	Alias           *LabelMonetaryAccount `json:"alias,omitempty"`

	// AllowBunqto Whether or not sending a bunq.to payment is allowed.
	AllowBunqto bool   `json:"allow_bunqto,omitempty"`
	Amount      Amount `json:"amount,omitempty"`

	// Attachment The Attachments attached to the Payment.
	Attachment           []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`
	BalanceAfterMutation Amount                             `json:"balance_after_mutation,omitempty"`

	// BatchId The id of the PaymentBatch if this Payment was part of one.
	BatchId int `json:"batch_id,omitempty"`

	// BunqtoExpiry When bunq.to payment is about to expire.
	BunqtoExpiry string `json:"bunqto_expiry,omitempty"`

	// BunqtoShareUrl The status of the bunq.to payment.
	BunqtoShareUrl string `json:"bunqto_share_url,omitempty"`

	// BunqtoStatus The status of the bunq.to payment.
	BunqtoStatus string `json:"bunqto_status,omitempty"`

	// BunqtoSubStatus The sub status of the bunq.to payment.
	BunqtoSubStatus string `json:"bunqto_sub_status,omitempty"`

	// BunqtoTimeResponded The timestamp of when the bunq.to payment was responded to.
	BunqtoTimeResponded string               `json:"bunqto_time_responded,omitempty"`
	CounterpartyAlias   LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp when the Payment was done.
	Created string `json:"created,omitempty"`

	// Description The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.
	Description string      `json:"description,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the created Payment.
	Id int `json:"id,omitempty"`

	// MerchantReference Optional data included with the Payment specific to the merchant.
	MerchantReference string `json:"merchant_reference,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the Payment was made to or from (depending on whether this is an incoming or outgoing Payment).
	MonetaryAccountId           int                         `json:"monetary_account_id,omitempty"`
	PaymentArrivalExpected      *PaymentArrivalExpected      `json:"payment_arrival_expected,omitempty"`
	PaymentAutoAllocateInstance *PaymentAutoAllocateInstance `json:"payment_auto_allocate_instance,omitempty"`
	PaymentSuspendedOutgoing    *PaymentSuspendedOutgoing    `json:"payment_suspended_outgoing,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// ScheduledId The id of the JobScheduled if the Payment was scheduled.
	ScheduledId int `json:"scheduled_id,omitempty"`

	// SubType The sub-type of the Payment, can be PAYMENT, WITHDRAWAL, REVERSAL, REQUEST, BILLING, SCT, SDD or NLO.
	SubType string `json:"sub_type,omitempty"`

	// Type The type of Payment, can be BUNQ, EBA_SCT, EBA_SDD, IDEAL, SWIFT or FIS (card).
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the Payment was last updated (will be updated when chat messages are received).
	Updated string `json:"updated,omitempty"`
}

// PaymentArrivalExpected defines model for PaymentArrivalExpected.
type PaymentArrivalExpected struct {
	// Status Indicates when we expect the payment to arrive.
	Status string `json:"status,omitempty"`

	// Time The time when the payment is expected to arrive.
	Time string `json:"time,omitempty"`
}

// PaymentAutoAllocate defines model for PaymentAutoAllocate.
type PaymentAutoAllocate struct {
	// Definition The definition of how the money should be allocated.
	Definition []PaymentAutoAllocateDefinition `json:"definition,omitempty"`

	// PaymentId The payment that should be used to define the triggers for the payment auto allocate.
	PaymentId int `json:"payment_id,omitempty"`

	// Type Whether a payment should be sorted ONCE or RECURRING.
	Type string `json:"type"`
}

// PaymentAutoAllocateCreate defines model for PaymentAutoAllocateCreate.
type PaymentAutoAllocateCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentAutoAllocateDefinition defines model for PaymentAutoAllocateDefinition.
type PaymentAutoAllocateDefinition struct {
	Amount            Amount  `json:"amount,omitempty"`
	CounterpartyAlias *Pointer `json:"counterparty_alias,omitempty"`

	// Created The timestamp when the PaymentAutoAllocateDefinition was created.
	Created string `json:"created,omitempty"`

	// Description The description for the payment.
	Description string `json:"description,omitempty"`

	// Fraction The percentage of the triggering payment's amount to allocate.
	Fraction int `json:"fraction,omitempty"`

	// Id The id of the PaymentAutoAllocateDefinition.
	Id int `json:"id,omitempty"`

	// Type The type of definition.
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the PaymentAutoAllocateDefinition was last updated.
	Updated string `json:"updated,omitempty"`
}

// PaymentAutoAllocateDefinitionListing defines model for PaymentAutoAllocateDefinitionListing.
type PaymentAutoAllocateDefinitionListing struct {
	Amount            Amount  `json:"amount,omitempty"`
	CounterpartyAlias *Pointer `json:"counterparty_alias,omitempty"`

	// Created The timestamp when the PaymentAutoAllocateDefinition was created.
	Created string `json:"created,omitempty"`

	// Description The description for the payment.
	Description string `json:"description,omitempty"`

	// Fraction The percentage of the triggering payment's amount to allocate.
	Fraction int `json:"fraction,omitempty"`

	// Id The id of the PaymentAutoAllocateDefinition.
	Id int `json:"id,omitempty"`

	// Updated The timestamp when the PaymentAutoAllocateDefinition was last updated.
	Updated string `json:"updated,omitempty"`
}

// PaymentAutoAllocateDelete defines model for PaymentAutoAllocateDelete.
type PaymentAutoAllocateDelete = map[string]interface{}

// PaymentAutoAllocateInstance defines model for PaymentAutoAllocateInstance.
type PaymentAutoAllocateInstance struct {
	// AllGinmonTransactionOrder All Ginmon transaction orders executed with this instance.
	AllGinmonTransactionOrder []GinmonTransaction `json:"all_ginmon_transaction_order,omitempty"`

	// Created The timestamp when the PaymentAutoAllocateInstance was created.
	Created string `json:"created,omitempty"`

	// ErrorMessage The error message, if the payment auto allocating failed.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// Id The id of the PaymentAutoAllocateInstance.
	Id int `json:"id,omitempty"`

	// PaymentAutoAllocateId The ID of the payment auto allocate this instance belongs to.
	PaymentAutoAllocateId int          `json:"payment_auto_allocate_id,omitempty"`
	PaymentBatch          *PaymentBatch `json:"payment_batch,omitempty"`

	// PaymentId The ID of the payment that triggered the allocating of the payments.
	PaymentId int `json:"payment_id,omitempty"`

	// Status The status of the payment auto allocate instance. SUCCEEDED or FAILED.
	Status string `json:"status,omitempty"`

	// Updated The timestamp when the PaymentAutoAllocateInstance was last updated.
	Updated string `json:"updated,omitempty"`
}

// PaymentAutoAllocateInstanceListing defines model for PaymentAutoAllocateInstanceListing.
type PaymentAutoAllocateInstanceListing struct {
	// AllGinmonTransactionOrder All Ginmon transaction orders executed with this instance.
	AllGinmonTransactionOrder []GinmonTransaction `json:"all_ginmon_transaction_order,omitempty"`

	// Created The timestamp when the PaymentAutoAllocateInstance was created.
	Created string `json:"created,omitempty"`

	// ErrorMessage The error message, if the payment auto allocating failed.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// Id The id of the PaymentAutoAllocateInstance.
	Id int `json:"id,omitempty"`

	// PaymentAutoAllocateId The ID of the payment auto allocate this instance belongs to.
	PaymentAutoAllocateId int          `json:"payment_auto_allocate_id,omitempty"`
	PaymentBatch          *PaymentBatch `json:"payment_batch,omitempty"`

	// PaymentId The ID of the payment that triggered the allocating of the payments.
	PaymentId int `json:"payment_id,omitempty"`

	// Status The status of the payment auto allocate instance. SUCCEEDED or FAILED.
	Status string `json:"status,omitempty"`

	// Updated The timestamp when the PaymentAutoAllocateInstance was last updated.
	Updated string `json:"updated,omitempty"`
}

// PaymentAutoAllocateInstanceRead defines model for PaymentAutoAllocateInstanceRead.
type PaymentAutoAllocateInstanceRead struct {
	// AllGinmonTransactionOrder All Ginmon transaction orders executed with this instance.
	AllGinmonTransactionOrder []GinmonTransaction `json:"all_ginmon_transaction_order,omitempty"`

	// Created The timestamp when the PaymentAutoAllocateInstance was created.
	Created string `json:"created,omitempty"`

	// ErrorMessage The error message, if the payment auto allocating failed.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// Id The id of the PaymentAutoAllocateInstance.
	Id int `json:"id,omitempty"`

	// PaymentAutoAllocateId The ID of the payment auto allocate this instance belongs to.
	PaymentAutoAllocateId int          `json:"payment_auto_allocate_id,omitempty"`
	PaymentBatch          *PaymentBatch `json:"payment_batch,omitempty"`

	// PaymentId The ID of the payment that triggered the allocating of the payments.
	PaymentId int `json:"payment_id,omitempty"`

	// Status The status of the payment auto allocate instance. SUCCEEDED or FAILED.
	Status string `json:"status,omitempty"`

	// Updated The timestamp when the PaymentAutoAllocateInstance was last updated.
	Updated string `json:"updated,omitempty"`
}

// PaymentAutoAllocateListing defines model for PaymentAutoAllocateListing.
type PaymentAutoAllocateListing struct {
	// Created The timestamp when the PaymentAutoAllocate was created.
	Created string `json:"created,omitempty"`

	// Id The id of the PaymentAutoAllocate.
	Id              int     `json:"id,omitempty"`
	Payment         *Payment `json:"payment,omitempty"`
	PaymentLatest   *Payment `json:"payment_latest,omitempty"`
	PaymentOriginal *Payment `json:"payment_original,omitempty"`

	// Status The status.
	Status        string `json:"status,omitempty"`
	TriggerAmount Amount `json:"trigger_amount,omitempty"`

	// Type The type.
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the PaymentAutoAllocate was last updated.
	Updated string `json:"updated,omitempty"`
}

// PaymentAutoAllocateRead defines model for PaymentAutoAllocateRead.
type PaymentAutoAllocateRead struct {
	// Created The timestamp when the PaymentAutoAllocate was created.
	Created string `json:"created,omitempty"`

	// Id The id of the PaymentAutoAllocate.
	Id              int     `json:"id,omitempty"`
	Payment         *Payment `json:"payment,omitempty"`
	PaymentLatest   *Payment `json:"payment_latest,omitempty"`
	PaymentOriginal *Payment `json:"payment_original,omitempty"`

	// Status The status.
	Status        string `json:"status,omitempty"`
	TriggerAmount Amount `json:"trigger_amount,omitempty"`

	// Type The type.
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the PaymentAutoAllocate was last updated.
	Updated string `json:"updated,omitempty"`
}

// PaymentAutoAllocateUpdate defines model for PaymentAutoAllocateUpdate.
type PaymentAutoAllocateUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentAutoAllocateUserListing defines model for PaymentAutoAllocateUserListing.
type PaymentAutoAllocateUserListing struct {
	PaymentAutoAllocate *PaymentAutoAllocate `json:"PaymentAutoAllocate,omitempty"`
}

// PaymentBatch defines model for PaymentBatch.
type PaymentBatch struct {
	Payments *PaymentBatchAnchoredPayment `json:"payments,omitempty"`
}

// PaymentBatchAnchoredPayment defines model for PaymentBatchAnchoredPayment.
type PaymentBatchAnchoredPayment struct {
	Payment []Payment `json:"Payment,omitempty"`
}

// PaymentBatchCreate defines model for PaymentBatchCreate.
type PaymentBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentBatchListing defines model for PaymentBatchListing.
type PaymentBatchListing struct {
	Payments *PaymentBatchAnchoredPayment `json:"payments,omitempty"`
}

// PaymentBatchRead defines model for PaymentBatchRead.
type PaymentBatchRead struct {
	Payments *PaymentBatchAnchoredPayment `json:"payments,omitempty"`
}

// PaymentBatchUpdate defines model for PaymentBatchUpdate.
type PaymentBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentCreate defines model for PaymentCreate.
type PaymentCreate struct {
	Id *BunqId `json:"id,omitempty"`
}

// PaymentListing defines model for PaymentListing.
type PaymentListing struct {
	Payment struct {
		AddressBilling  *Address              `json:"address_billing,omitempty"`
		AddressShipping *Address              `json:"address_shipping,omitempty"`
		Alias           *LabelMonetaryAccount `json:"alias,omitempty"`
		Amount          Amount               `json:"amount,omitempty"`

		// Attachment The Attachments attached to the Payment.
		Attachment           []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`
		BalanceAfterMutation Amount                             `json:"balance_after_mutation,omitempty"`

		// BatchId The id of the PaymentBatch if this Payment was part of one.
		BatchId int `json:"batch_id,omitempty"`

		// BunqtoExpiry When bunq.to payment is about to expire.
		BunqtoExpiry string `json:"bunqto_expiry,omitempty"`

		// BunqtoShareUrl The status of the bunq.to payment.
		BunqtoShareUrl string `json:"bunqto_share_url,omitempty"`

		// BunqtoStatus The status of the bunq.to payment.
		BunqtoStatus string `json:"bunqto_status,omitempty"`

		// BunqtoSubStatus The sub status of the bunq.to payment.
		BunqtoSubStatus string `json:"bunqto_sub_status,omitempty"`

		// BunqtoTimeResponded The timestamp of when the bunq.to payment was responded to.
		BunqtoTimeResponded string               `json:"bunqto_time_responded,omitempty"`
		CounterpartyAlias   LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

		// Created The timestamp when the Payment was done.
		Created string `json:"created,omitempty"`

		// Description The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.
		Description string      `json:"description,omitempty"`
		Geolocation *Geolocation `json:"geolocation,omitempty"`

		// Id The id of the created Payment.
		Id int `json:"id,omitempty"`

		// MerchantReference Optional data included with the Payment specific to the merchant.
		MerchantReference string `json:"merchant_reference,omitempty"`

		// MonetaryAccountId The id of the MonetaryAccount the Payment was made to or from (depending on whether this is an incoming or outgoing Payment).
		MonetaryAccountId           int                         `json:"monetary_account_id,omitempty"`
		PaymentArrivalExpected      *PaymentArrivalExpected      `json:"payment_arrival_expected,omitempty"`
		PaymentAutoAllocateInstance *PaymentAutoAllocateInstance `json:"payment_auto_allocate_instance,omitempty"`
		PaymentSuspendedOutgoing    *PaymentSuspendedOutgoing    `json:"payment_suspended_outgoing,omitempty"`

		// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
		RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

		// ScheduledId The id of the JobScheduled if the Payment was scheduled.
		ScheduledId int `json:"scheduled_id,omitempty"`

		// SubType The sub-type of the Payment, can be PAYMENT, WITHDRAWAL, REVERSAL, REQUEST, BILLING, SCT, SDD or NLO.
		SubType string `json:"sub_type,omitempty"`

		// Type The type of Payment, can be BUNQ, EBA_SCT, EBA_SDD, IDEAL, SWIFT or FIS (card).
		Type string `json:"type,omitempty"`

		// Updated The timestamp when the Payment was last updated (will be updated when chat messages are received).
		Updated string `json:"updated,omitempty"`
	} `json:"Payment"`
}

// PaymentRead defines model for PaymentRead.
type PaymentRead struct {
	AddressBilling  *Address              `json:"address_billing,omitempty"`
	AddressShipping *Address              `json:"address_shipping,omitempty"`
	Alias           *LabelMonetaryAccount `json:"alias,omitempty"`
	Amount          Amount               `json:"amount,omitempty"`

	// Attachment The Attachments attached to the Payment.
	Attachment           []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`
	BalanceAfterMutation Amount                             `json:"balance_after_mutation,omitempty"`

	// BatchId The id of the PaymentBatch if this Payment was part of one.
	BatchId int `json:"batch_id,omitempty"`

	// BunqtoExpiry When bunq.to payment is about to expire.
	BunqtoExpiry string `json:"bunqto_expiry,omitempty"`

	// BunqtoShareUrl The status of the bunq.to payment.
	BunqtoShareUrl string `json:"bunqto_share_url,omitempty"`

	// BunqtoStatus The status of the bunq.to payment.
	BunqtoStatus string `json:"bunqto_status,omitempty"`

	// BunqtoSubStatus The sub status of the bunq.to payment.
	BunqtoSubStatus string `json:"bunqto_sub_status,omitempty"`

	// BunqtoTimeResponded The timestamp of when the bunq.to payment was responded to.
	BunqtoTimeResponded string               `json:"bunqto_time_responded,omitempty"`
	CounterpartyAlias   LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp when the Payment was done.
	Created string `json:"created,omitempty"`

	// Description The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.
	Description string      `json:"description,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the created Payment.
	Id int `json:"id,omitempty"`

	// MerchantReference Optional data included with the Payment specific to the merchant.
	MerchantReference string `json:"merchant_reference,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the Payment was made to or from (depending on whether this is an incoming or outgoing Payment).
	MonetaryAccountId           int                         `json:"monetary_account_id,omitempty"`
	PaymentArrivalExpected      *PaymentArrivalExpected      `json:"payment_arrival_expected,omitempty"`
	PaymentAutoAllocateInstance *PaymentAutoAllocateInstance `json:"payment_auto_allocate_instance,omitempty"`
	PaymentSuspendedOutgoing    *PaymentSuspendedOutgoing    `json:"payment_suspended_outgoing,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// ScheduledId The id of the JobScheduled if the Payment was scheduled.
	ScheduledId int `json:"scheduled_id,omitempty"`

	// SubType The sub-type of the Payment, can be PAYMENT, WITHDRAWAL, REVERSAL, REQUEST, BILLING, SCT, SDD or NLO.
	SubType string `json:"sub_type,omitempty"`

	// Type The type of Payment, can be BUNQ, EBA_SCT, EBA_SDD, IDEAL, SWIFT or FIS (card).
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the Payment was last updated (will be updated when chat messages are received).
	Updated string `json:"updated,omitempty"`
}

// PaymentServiceProviderCredential defines model for PaymentServiceProviderCredential.
type PaymentServiceProviderCredential struct {
	// ClientPaymentServiceProviderCertificate Payment Services Directive 2 compatible QSEAL certificate
	ClientPaymentServiceProviderCertificate string `json:"client_payment_service_provider_certificate,omitempty"`

	// ClientPaymentServiceProviderCertificateChain Intermediate and root certificate belonging to the provided certificate.
	ClientPaymentServiceProviderCertificateChain string `json:"client_payment_service_provider_certificate_chain,omitempty"`

	// ClientPublicKeySignature The Base64 encoded signature of the public key provided during installation and with the installation token appended as a nonce. Signed with the private key belonging to the QSEAL certificate.
	ClientPublicKeySignature string `json:"client_public_key_signature,omitempty"`
}

// PaymentServiceProviderCredentialCreate defines model for PaymentServiceProviderCredentialCreate.
type PaymentServiceProviderCredentialCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentServiceProviderCredentialRead defines model for PaymentServiceProviderCredentialRead.
type PaymentServiceProviderCredentialRead struct {
	// Created The timestamp of the credential object's creation.
	Created string `json:"created,omitempty"`

	// ExpiryTime When the status is PENDING_FIRST_USE: when the credential expires.
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Id The id of the credential.
	Id              int             `json:"id,omitempty"`
	PermittedDevice *PermittedDevice `json:"permitted_device,omitempty"`

	// Status The status of the credential.
	Status string `json:"status,omitempty"`

	// TokenValue When the status is PENDING_FIRST_USE: the value of the token.
	TokenValue string `json:"token_value,omitempty"`

	// Updated The timestamp of the credential object's last update.
	Updated string `json:"updated,omitempty"`
}

// PaymentServiceProviderDraftPayment defines model for PaymentServiceProviderDraftPayment.
type PaymentServiceProviderDraftPayment struct {
	Amount Amount `json:"amount"`

	// CounterpartyIban The IBAN of the counterparty.
	CounterpartyIban string `json:"counterparty_iban,omitempty"`

	// CounterpartyName The name of the counterparty.
	CounterpartyName string `json:"counterparty_name,omitempty"`

	// Description Description of the payment.
	Description string `json:"description,omitempty"`

	// SenderIban The IBAN of the sender.
	SenderIban string `json:"sender_iban"`

	// SenderName The name of the sender.
	SenderName string `json:"sender_name,omitempty"`

	// Status The new status of the Draft Payment. Can only be set to REJECTED or CANCELLED by update.
	Status string `json:"status,omitempty"`
}

// PaymentServiceProviderDraftPaymentCreate defines model for PaymentServiceProviderDraftPaymentCreate.
type PaymentServiceProviderDraftPaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentServiceProviderDraftPaymentListing defines model for PaymentServiceProviderDraftPaymentListing.
type PaymentServiceProviderDraftPaymentListing struct {
	Amount Amount `json:"amount,omitempty"`

	// ReceiverIban The sender IBAN.
	ReceiverIban string `json:"receiver_iban,omitempty"`

	// SenderIban The sender IBAN.
	SenderIban string `json:"sender_iban,omitempty"`

	// Status The status of the draft payment
	Status string `json:"status,omitempty"`
}

// PaymentServiceProviderDraftPaymentRead defines model for PaymentServiceProviderDraftPaymentRead.
type PaymentServiceProviderDraftPaymentRead struct {
	Amount Amount `json:"amount,omitempty"`

	// ReceiverIban The sender IBAN.
	ReceiverIban string `json:"receiver_iban,omitempty"`

	// SenderIban The sender IBAN.
	SenderIban string `json:"sender_iban,omitempty"`

	// Status The status of the draft payment
	Status string `json:"status,omitempty"`
}

// PaymentServiceProviderDraftPaymentUpdate defines model for PaymentServiceProviderDraftPaymentUpdate.
type PaymentServiceProviderDraftPaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentServiceProviderIssuerTransaction defines model for PaymentServiceProviderIssuerTransaction.
type PaymentServiceProviderIssuerTransaction struct {
	Amount            Amount  `json:"amount"`
	CounterpartyAlias Pointer `json:"counterparty_alias"`

	// Description The description of this transaction, to be shown to the user and to the counter party.
	Description string `json:"description"`

	// Status The status of the transaction. Can only be used for cancelling the transaction.
	Status string `json:"status,omitempty"`

	// TimeExpiry The (optional) expiration time of the transaction. Defaults to 10 minutes.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// UrlRedirect The url to which the user should be redirected once the transaction is accepted or rejected.
	UrlRedirect string `json:"url_redirect"`
}

// PaymentServiceProviderIssuerTransactionCreate defines model for PaymentServiceProviderIssuerTransactionCreate.
type PaymentServiceProviderIssuerTransactionCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentServiceProviderIssuerTransactionListing defines model for PaymentServiceProviderIssuerTransactionListing.
type PaymentServiceProviderIssuerTransactionListing struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	Amount            Amount               `json:"amount,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The time this transaction was created.
	Created string `json:"created,omitempty"`

	// Description The description of this transaction, to be shown to the user and to the counter party.
	Description string `json:"description,omitempty"`

	// Id The id of this transaction.
	Id int `json:"id,omitempty"`

	// PublicUuid The public uuid used to identify this transaction.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Status The status of the transaction. Can only be used for cancelling the transaction.
	Status string `json:"status,omitempty"`

	// TimeExpiry The (optional) expiration time of the transaction. Defaults to 10 minutes.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Updated The time this transaction was last updated.
	Updated string `json:"updated,omitempty"`

	// UrlRedirect The url to which the user should be redirected once the transaction is accepted or rejected.
	UrlRedirect string `json:"url_redirect,omitempty"`
}

// PaymentServiceProviderIssuerTransactionRead defines model for PaymentServiceProviderIssuerTransactionRead.
type PaymentServiceProviderIssuerTransactionRead struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	Amount            Amount               `json:"amount,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The time this transaction was created.
	Created string `json:"created,omitempty"`

	// Description The description of this transaction, to be shown to the user and to the counter party.
	Description string `json:"description,omitempty"`

	// Id The id of this transaction.
	Id int `json:"id,omitempty"`

	// PublicUuid The public uuid used to identify this transaction.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Status The status of the transaction. Can only be used for cancelling the transaction.
	Status string `json:"status,omitempty"`

	// TimeExpiry The (optional) expiration time of the transaction. Defaults to 10 minutes.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Updated The time this transaction was last updated.
	Updated string `json:"updated,omitempty"`

	// UrlRedirect The url to which the user should be redirected once the transaction is accepted or rejected.
	UrlRedirect string `json:"url_redirect,omitempty"`
}

// PaymentServiceProviderIssuerTransactionUpdate defines model for PaymentServiceProviderIssuerTransactionUpdate.
type PaymentServiceProviderIssuerTransactionUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PaymentSuspendedOutgoing defines model for PaymentSuspendedOutgoing.
type PaymentSuspendedOutgoing struct {
	// MonetaryAccountId The ID of the monetary account the payment was sent from.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Status The status of the payment.
	Status string `json:"status,omitempty"`

	// TimeExecution The time this payment should be executed.
	TimeExecution string `json:"time_execution,omitempty"`
}

// PermittedDevice defines model for PermittedDevice.
type PermittedDevice struct {
	// Description The description of the device that may use the credential.
	Description string `json:"description,omitempty"`

	// Ip The IP address of the device that may use the credential.
	Ip string `json:"ip,omitempty"`
}

// PermittedIp defines model for PermittedIp.
type PermittedIp struct {
	// Ip The IP address.
	Ip string `json:"ip"`

	// Status The status of the IP. May be "ACTIVE" or "INACTIVE". It is only possible to make requests from "ACTIVE" IP addresses. Only "ACTIVE" IPs will be billed.
	Status string `json:"status,omitempty"`
}

// PermittedIpCreate defines model for PermittedIpCreate.
type PermittedIpCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PermittedIpListing defines model for PermittedIpListing.
type PermittedIpListing struct {
	// Ip The IP address.
	Ip string `json:"ip,omitempty"`

	// Status The status of the IP. May be "ACTIVE" or "INACTIVE". It is only possible to make requests from "ACTIVE" IP addresses. Only "ACTIVE" IPs will be billed.
	Status string `json:"status,omitempty"`
}

// PermittedIpRead defines model for PermittedIpRead.
type PermittedIpRead struct {
	// Ip The IP address.
	Ip string `json:"ip,omitempty"`

	// Status The status of the IP. May be "ACTIVE" or "INACTIVE". It is only possible to make requests from "ACTIVE" IP addresses. Only "ACTIVE" IPs will be billed.
	Status string `json:"status,omitempty"`
}

// PermittedIpUpdate defines model for PermittedIpUpdate.
type PermittedIpUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// PointMutation defines model for PointMutation.
type PointMutation struct {
	// NumberOfPoint The number of points earned.
	NumberOfPoint int `json:"number_of_point,omitempty"`
}

// Pointer defines model for Pointer.
type Pointer struct {
	// Name The alias name.
	Name string `json:"name,omitempty"`

	// Service The pointer service. Only required for external counterparties.
	Service string `json:"service,omitempty"`

	// Type The alias type, can be: EMAIL|PHONE_NUMBER|IBAN.
	Type string `json:"type,omitempty"`

	// Value The alias value.
	Value string `json:"value,omitempty"`
}

// RelationUser defines model for RelationUser.
type RelationUser struct {
	// AllCompanyEmployeeCard Cards accessible by the company employee
	AllCompanyEmployeeCard                     []CompanyEmployeeCard                      `json:"all_company_employee_card,omitempty"`
	CompanyEmployeeSettingAdyenCardTransaction *CompanyEmployeeSettingAdyenCardTransaction `json:"company_employee_setting_adyen_card_transaction,omitempty"`
	CounterLabelUser                           *LabelUser                                  `json:"counter_label_user,omitempty"`

	// CounterUserId The counter user's ID.
	CounterUserId string `json:"counter_user_id,omitempty"`

	// CounterUserStatus The account status of a user
	CounterUserStatus string    `json:"counter_user_status,omitempty"`
	LabelUser         *LabelUser `json:"label_user,omitempty"`

	// Relationship The requested relation type.
	Relationship string `json:"relationship,omitempty"`

	// Status The request's status, only for UPDATE.
	Status string `json:"status,omitempty"`

	// UserId The user's ID.
	UserId string `json:"user_id,omitempty"`

	// UserStatus The account status of a user
	UserStatus string `json:"user_status,omitempty"`
}

// RequestInquiry defines model for RequestInquiry.
type RequestInquiry struct {
	AddressBilling  *Address `json:"address_billing,omitempty"`
	AddressShipping *Address `json:"address_shipping,omitempty"`

	// AllowAmountHigher [DEPRECATED] Whether or not the accepting user can choose to accept with a higher amount than requested. Defaults to false.
	AllowAmountHigher bool `json:"allow_amount_higher,omitempty"`

	// AllowAmountLower [DEPRECATED] Whether or not the accepting user can choose to accept with a lower amount than requested. Defaults to false.
	AllowAmountLower bool `json:"allow_amount_lower,omitempty"`

	// AllowBunqme Whether or not sending a bunq.me request is allowed.
	AllowBunqme     bool   `json:"allow_bunqme,omitempty"`
	AmountInquired  Amount `json:"amount_inquired,omitempty"`
	AmountResponded Amount `json:"amount_responded,omitempty"`

	// Attachment The attachments attached to the payment.
	Attachment []BunqId `json:"attachment,omitempty"`

	// BatchId The id of the batch if the request was part of a batch.
	BatchId int `json:"batch_id,omitempty"`

	// BunqmeShareUrl The url that points to the bunq.me request.
	BunqmeShareUrl    string               `json:"bunqme_share_url,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the payment request's creation.
	Created string `json:"created,omitempty"`

	// Description The description of the inquiry.
	Description string `json:"description,omitempty"`

	// EventId The ID of the associated event if the request was made using 'split the bill'.
	EventId     int         `json:"event_id,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the created RequestInquiry.
	Id int `json:"id,omitempty"`

	// MerchantReference The client's custom reference that was attached to the request and the mutation.
	MerchantReference string `json:"merchant_reference,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestInquiry must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the monetary account the request response applies to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// RedirectUrl The URL which the user is sent to after accepting or rejecting the Request.
	RedirectUrl           string                                   `json:"redirect_url,omitempty"`
	ReferenceSplitTheBill *RequestReferenceSplitTheBillAnchorObject `json:"reference_split_the_bill,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// ScheduledId The id of the scheduled job if the request was scheduled.
	ScheduledId int `json:"scheduled_id,omitempty"`

	// Status The status of the request.
	Status string `json:"status,omitempty"`

	// TimeExpiry The timestamp of when the payment request expired.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeResponded The timestamp of when the payment request was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Updated The timestamp of the payment request's last update.
	Updated          string    `json:"updated,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
	UserAliasRevoked *LabelUser `json:"user_alias_revoked,omitempty"`

	// WantTip [DEPRECATED] Whether or not the accepting user can give an extra tip on top of the requested Amount. Defaults to false.
	WantTip bool `json:"want_tip,omitempty"`
}

// RequestInquiryBatch defines model for RequestInquiryBatch.
type RequestInquiryBatch struct {
	// EventId The ID of the associated event if the request batch was made using 'split the bill'.
	EventId               int                                      `json:"event_id,omitempty"`
	ReferenceSplitTheBill *RequestReferenceSplitTheBillAnchorObject `json:"reference_split_the_bill,omitempty"`

	// RequestInquiries The list of requests that were made.
	RequestInquiries []RequestInquiry `json:"request_inquiries,omitempty"`

	// Status The status of the request.
	Status              string `json:"status,omitempty"`
	TotalAmountInquired Amount `json:"total_amount_inquired,omitempty"`
}

// RequestInquiryBatchCreate defines model for RequestInquiryBatchCreate.
type RequestInquiryBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// RequestInquiryBatchListing defines model for RequestInquiryBatchListing.
type RequestInquiryBatchListing struct {
	ReferenceSplitTheBill *RequestReferenceSplitTheBillAnchorObject `json:"reference_split_the_bill,omitempty"`

	// RequestInquiries The list of requests that were made.
	RequestInquiries    []RequestInquiry `json:"request_inquiries,omitempty"`
	TotalAmountInquired Amount           `json:"total_amount_inquired,omitempty"`
}

// RequestInquiryBatchRead defines model for RequestInquiryBatchRead.
type RequestInquiryBatchRead struct {
	ReferenceSplitTheBill *RequestReferenceSplitTheBillAnchorObject `json:"reference_split_the_bill,omitempty"`

	// RequestInquiries The list of requests that were made.
	RequestInquiries    []RequestInquiry `json:"request_inquiries,omitempty"`
	TotalAmountInquired Amount           `json:"total_amount_inquired,omitempty"`
}

// RequestInquiryBatchUpdate defines model for RequestInquiryBatchUpdate.
type RequestInquiryBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// RequestInquiryCreate defines model for RequestInquiryCreate.
type RequestInquiryCreate struct {
	// Id The id of the created RequestInquiry.
	Id int `json:"id,omitempty"`
}

// RequestInquiryListing defines model for RequestInquiryListing.
type RequestInquiryListing struct {
	AddressBilling  *Address `json:"address_billing,omitempty"`
	AddressShipping *Address `json:"address_shipping,omitempty"`
	AmountInquired  Amount  `json:"amount_inquired,omitempty"`
	AmountResponded Amount  `json:"amount_responded,omitempty"`

	// Attachment The attachments attached to the payment.
	Attachment []BunqId `json:"attachment,omitempty"`

	// BatchId The id of the batch if the request was part of a batch.
	BatchId int `json:"batch_id,omitempty"`

	// BunqmeShareUrl The url that points to the bunq.me request.
	BunqmeShareUrl    string               `json:"bunqme_share_url,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the payment request's creation.
	Created string `json:"created,omitempty"`

	// Description The description of the inquiry.
	Description string      `json:"description,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the created RequestInquiry.
	Id int `json:"id,omitempty"`

	// MerchantReference The client's custom reference that was attached to the request and the mutation.
	MerchantReference string `json:"merchant_reference,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestInquiry must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the monetary account the request response applies to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// RedirectUrl The URL which the user is sent to after accepting or rejecting the Request.
	RedirectUrl           string                                   `json:"redirect_url,omitempty"`
	ReferenceSplitTheBill *RequestReferenceSplitTheBillAnchorObject `json:"reference_split_the_bill,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// ScheduledId The id of the scheduled job if the request was scheduled.
	ScheduledId int `json:"scheduled_id,omitempty"`

	// Status The status of the request.
	Status string `json:"status,omitempty"`

	// TimeExpiry The timestamp of when the payment request expired.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeResponded The timestamp of when the payment request was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Updated The timestamp of the payment request's last update.
	Updated          string    `json:"updated,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
	UserAliasRevoked *LabelUser `json:"user_alias_revoked,omitempty"`
}

// RequestInquiryRead defines model for RequestInquiryRead.
type RequestInquiryRead struct {
	AddressBilling  *Address `json:"address_billing,omitempty"`
	AddressShipping *Address `json:"address_shipping,omitempty"`
	AmountInquired  Amount  `json:"amount_inquired,omitempty"`
	AmountResponded Amount  `json:"amount_responded,omitempty"`

	// Attachment The attachments attached to the payment.
	Attachment []BunqId `json:"attachment,omitempty"`

	// BatchId The id of the batch if the request was part of a batch.
	BatchId int `json:"batch_id,omitempty"`

	// BunqmeShareUrl The url that points to the bunq.me request.
	BunqmeShareUrl    string               `json:"bunqme_share_url,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the payment request's creation.
	Created string `json:"created,omitempty"`

	// Description The description of the inquiry.
	Description string      `json:"description,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the created RequestInquiry.
	Id int `json:"id,omitempty"`

	// MerchantReference The client's custom reference that was attached to the request and the mutation.
	MerchantReference string `json:"merchant_reference,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestInquiry must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the monetary account the request response applies to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// RedirectUrl The URL which the user is sent to after accepting or rejecting the Request.
	RedirectUrl           string                                   `json:"redirect_url,omitempty"`
	ReferenceSplitTheBill *RequestReferenceSplitTheBillAnchorObject `json:"reference_split_the_bill,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// ScheduledId The id of the scheduled job if the request was scheduled.
	ScheduledId int `json:"scheduled_id,omitempty"`

	// Status The status of the request.
	Status string `json:"status,omitempty"`

	// TimeExpiry The timestamp of when the payment request expired.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeResponded The timestamp of when the payment request was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Updated The timestamp of the payment request's last update.
	Updated          string    `json:"updated,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
	UserAliasRevoked *LabelUser `json:"user_alias_revoked,omitempty"`
}

// RequestInquiryReference defines model for RequestInquiryReference.
type RequestInquiryReference struct {
	// Id The id of the request inquiry (batch).
	Id int `json:"id,omitempty"`

	// Type The type of request inquiry. Can be RequestInquiry or RequestInquiryBatch.
	Type string `json:"type,omitempty"`
}

// RequestInquiryUpdate defines model for RequestInquiryUpdate.
type RequestInquiryUpdate struct {
	AddressBilling  *Address `json:"address_billing,omitempty"`
	AddressShipping *Address `json:"address_shipping,omitempty"`
	AmountInquired  Amount  `json:"amount_inquired,omitempty"`
	AmountResponded Amount  `json:"amount_responded,omitempty"`

	// Attachment The attachments attached to the payment.
	Attachment []BunqId `json:"attachment,omitempty"`

	// BatchId The id of the batch if the request was part of a batch.
	BatchId           int                  `json:"batch_id,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp of the payment request's creation.
	Created string `json:"created,omitempty"`

	// Description The description of the inquiry.
	Description string      `json:"description,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the payment request.
	Id int `json:"id,omitempty"`

	// MerchantReference The client's custom reference that was attached to the request and the mutation.
	MerchantReference string `json:"merchant_reference,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestInquiry must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the monetary account the request response applies to.
	MonetaryAccountId     int                                      `json:"monetary_account_id,omitempty"`
	ReferenceSplitTheBill *RequestReferenceSplitTheBillAnchorObject `json:"reference_split_the_bill,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// ScheduledId The id of the scheduled job if the request was scheduled.
	ScheduledId int `json:"scheduled_id,omitempty"`

	// Status The status of the request.
	Status string `json:"status,omitempty"`

	// TimeExpiry The timestamp of when the payment request expired.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeResponded The timestamp of when the payment request was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Updated The timestamp of the payment request's last update.
	Updated          string    `json:"updated,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
	UserAliasRevoked *LabelUser `json:"user_alias_revoked,omitempty"`
}

// RequestReferenceSplitTheBillAnchorObject defines model for RequestReferenceSplitTheBillAnchorObject.
type RequestReferenceSplitTheBillAnchorObject struct {
	BillingInvoice      *Invoice              `json:"BillingInvoice,omitempty"`
	CurrencyConversion  *CurrencyConversion   `json:"CurrencyConversion,omitempty"`
	DraftPayment        *DraftPayment         `json:"DraftPayment,omitempty"`
	MasterCardAction    *MasterCardAction     `json:"MasterCardAction,omitempty"`
	Payment             *Payment              `json:"Payment,omitempty"`
	PaymentBatch        *PaymentBatch         `json:"PaymentBatch,omitempty"`
	RequestResponse     *RequestResponse      `json:"RequestResponse,omitempty"`
	ScheduleInstance    *ScheduleInstance     `json:"ScheduleInstance,omitempty"`
	TransferwisePayment *TransferwiseTransfer `json:"TransferwisePayment,omitempty"`
	WhitelistResult     *WhitelistResult      `json:"WhitelistResult,omitempty"`
}

// RequestResponse defines model for RequestResponse.
type RequestResponse struct {
	AddressBilling  *Address              `json:"address_billing,omitempty"`
	AddressShipping *Address              `json:"address_shipping,omitempty"`
	Alias           *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountInquired  Amount               `json:"amount_inquired,omitempty"`
	AmountResponded Amount               `json:"amount_responded,omitempty"`

	// Attachment The Attachments attached to the RequestResponse.
	Attachment        []Attachment         `json:"attachment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp when the Request Response was created.
	Created string `json:"created,omitempty"`

	// CreditSchemeIdentifier The credit scheme id provided by the counterparty for DIRECT_DEBIT inquiries.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// CurrencyConversionQuoteId When the request is accepted on a monetary account with a different currency, a quote is expected to convert.
	CurrencyConversionQuoteId int `json:"currency_conversion_quote_id,omitempty"`

	// Description The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.
	Description string `json:"description,omitempty"`

	// EligibleWhitelistId The whitelist id for this action or null.
	EligibleWhitelistId int `json:"eligible_whitelist_id,omitempty"`

	// EventId The ID of the latest event for the request.
	EventId     int         `json:"event_id,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the Request Response.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate id provided by the counterparty for DIRECT_DEBIT inquiries.
	MandateIdentifier string `json:"mandate_identifier,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestResponse must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the RequestResponse was received on.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// MonetaryAccountPreferredId The ID of the monetary account this user prefers to pay the request from.
	MonetaryAccountPreferredId int `json:"monetary_account_preferred_id,omitempty"`

	// RedirectUrl The URL which the user is sent to after accepting or rejecting the Request.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// RegistrationAction Recommended registration action after IdealIssuerTransaction from iDEAL issuer transaction.
	RegistrationAction string `json:"registration_action,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// Status The status of the RequestResponse. Can be ACCEPTED, PENDING, REJECTED, REFUND_REQUESTED, REFUNDED or REVOKED.
	Status string `json:"status,omitempty"`

	// SubType The subtype of the RequestInquiry. Can be ONCE or RECURRING for DIRECT_DEBIT RequestInquiries and NONE for all other.
	SubType string `json:"sub_type,omitempty"`

	// TimeExpiry The timestamp of when the RequestResponse expired or will expire.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeRefundRequested The timestamp of when a refund request for the RequestResponse was claimed.
	TimeRefundRequested string `json:"time_refund_requested,omitempty"`

	// TimeRefunded The timestamp of when the RequestResponse was refunded.
	TimeRefunded string `json:"time_refunded,omitempty"`

	// TimeResponded The timestamp of when the RequestResponse was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Type The type of the RequestInquiry. Can be DIRECT_DEBIT, DIRECT_DEBIT_B2B, IDEAL, SOFORT or INTERNAL.
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the Request Response was last updated (will be updated when chat messages are received).
	Updated             string    `json:"updated,omitempty"`
	UserRefundRequested *LabelUser `json:"user_refund_requested,omitempty"`
}

// RequestResponseListing defines model for RequestResponseListing.
type RequestResponseListing struct {
	AddressBilling  *Address              `json:"address_billing,omitempty"`
	AddressShipping *Address              `json:"address_shipping,omitempty"`
	Alias           *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountInquired  Amount               `json:"amount_inquired,omitempty"`
	AmountResponded Amount               `json:"amount_responded,omitempty"`

	// Attachment The Attachments attached to the RequestResponse.
	Attachment        []Attachment         `json:"attachment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp when the Request Response was created.
	Created string `json:"created,omitempty"`

	// CreditSchemeIdentifier The credit scheme id provided by the counterparty for DIRECT_DEBIT inquiries.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Description The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.
	Description string `json:"description,omitempty"`

	// EligibleWhitelistId The whitelist id for this action or null.
	EligibleWhitelistId int `json:"eligible_whitelist_id,omitempty"`

	// EventId The ID of the latest event for the request.
	EventId     int         `json:"event_id,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the Request Response.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate id provided by the counterparty for DIRECT_DEBIT inquiries.
	MandateIdentifier string `json:"mandate_identifier,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestResponse must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the RequestResponse was received on.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// MonetaryAccountPreferredId The ID of the monetary account this user prefers to pay the request from.
	MonetaryAccountPreferredId int `json:"monetary_account_preferred_id,omitempty"`

	// RedirectUrl The URL which the user is sent to after accepting or rejecting the Request.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// RegistrationAction Recommended registration action after IdealIssuerTransaction from iDEAL issuer transaction.
	RegistrationAction string `json:"registration_action,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// Status The status of the RequestResponse. Can be ACCEPTED, PENDING, REJECTED, REFUND_REQUESTED, REFUNDED or REVOKED.
	Status string `json:"status,omitempty"`

	// SubType The subtype of the RequestInquiry. Can be ONCE or RECURRING for DIRECT_DEBIT RequestInquiries and NONE for all other.
	SubType string `json:"sub_type,omitempty"`

	// TimeExpiry The timestamp of when the RequestResponse expired or will expire.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeRefundRequested The timestamp of when a refund request for the RequestResponse was claimed.
	TimeRefundRequested string `json:"time_refund_requested,omitempty"`

	// TimeRefunded The timestamp of when the RequestResponse was refunded.
	TimeRefunded string `json:"time_refunded,omitempty"`

	// TimeResponded The timestamp of when the RequestResponse was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Type The type of the RequestInquiry. Can be DIRECT_DEBIT, DIRECT_DEBIT_B2B, IDEAL, SOFORT or INTERNAL.
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the Request Response was last updated (will be updated when chat messages are received).
	Updated             string    `json:"updated,omitempty"`
	UserRefundRequested *LabelUser `json:"user_refund_requested,omitempty"`
}

// RequestResponseRead defines model for RequestResponseRead.
type RequestResponseRead struct {
	AddressBilling  *Address              `json:"address_billing,omitempty"`
	AddressShipping *Address              `json:"address_shipping,omitempty"`
	Alias           *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountInquired  Amount               `json:"amount_inquired,omitempty"`
	AmountResponded Amount               `json:"amount_responded,omitempty"`

	// Attachment The Attachments attached to the RequestResponse.
	Attachment        []Attachment         `json:"attachment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Created The timestamp when the Request Response was created.
	Created string `json:"created,omitempty"`

	// CreditSchemeIdentifier The credit scheme id provided by the counterparty for DIRECT_DEBIT inquiries.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Description The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.
	Description string `json:"description,omitempty"`

	// EligibleWhitelistId The whitelist id for this action or null.
	EligibleWhitelistId int `json:"eligible_whitelist_id,omitempty"`

	// EventId The ID of the latest event for the request.
	EventId     int         `json:"event_id,omitempty"`
	Geolocation *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the Request Response.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate id provided by the counterparty for DIRECT_DEBIT inquiries.
	MandateIdentifier string `json:"mandate_identifier,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestResponse must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the RequestResponse was received on.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// MonetaryAccountPreferredId The ID of the monetary account this user prefers to pay the request from.
	MonetaryAccountPreferredId int `json:"monetary_account_preferred_id,omitempty"`

	// RedirectUrl The URL which the user is sent to after accepting or rejecting the Request.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// RegistrationAction Recommended registration action after IdealIssuerTransaction from iDEAL issuer transaction.
	RegistrationAction string `json:"registration_action,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// Status The status of the RequestResponse. Can be ACCEPTED, PENDING, REJECTED, REFUND_REQUESTED, REFUNDED or REVOKED.
	Status string `json:"status,omitempty"`

	// SubType The subtype of the RequestInquiry. Can be ONCE or RECURRING for DIRECT_DEBIT RequestInquiries and NONE for all other.
	SubType string `json:"sub_type,omitempty"`

	// TimeExpiry The timestamp of when the RequestResponse expired or will expire.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeRefundRequested The timestamp of when a refund request for the RequestResponse was claimed.
	TimeRefundRequested string `json:"time_refund_requested,omitempty"`

	// TimeRefunded The timestamp of when the RequestResponse was refunded.
	TimeRefunded string `json:"time_refunded,omitempty"`

	// TimeResponded The timestamp of when the RequestResponse was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Type The type of the RequestInquiry. Can be DIRECT_DEBIT, DIRECT_DEBIT_B2B, IDEAL, SOFORT or INTERNAL.
	Type string `json:"type,omitempty"`

	// Updated The timestamp when the Request Response was last updated (will be updated when chat messages are received).
	Updated             string    `json:"updated,omitempty"`
	UserRefundRequested *LabelUser `json:"user_refund_requested,omitempty"`
}

// RequestResponseUpdate defines model for RequestResponseUpdate.
type RequestResponseUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// SandboxUserCompany defines model for SandboxUserCompany.
type SandboxUserCompany = map[string]interface{}

// SandboxUserCompanyCreate defines model for SandboxUserCompanyCreate.
type SandboxUserCompanyCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// SandboxUserPerson defines model for SandboxUserPerson.
type SandboxUserPerson = map[string]interface{}

// SandboxUserPersonCreate defines model for SandboxUserPersonCreate.
type SandboxUserPersonCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// Schedule defines model for Schedule.
type Schedule struct {
	Object *ScheduleAnchorObject `json:"object,omitempty"`

	// RecurrenceSize The schedule recurrence size. For example size 4 and unit WEEKLY means the recurrence is every 4 weeks.
	RecurrenceSize int `json:"recurrence_size,omitempty"`

	// RecurrenceUnit The schedule recurrence unit, options: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY
	RecurrenceUnit string `json:"recurrence_unit,omitempty"`

	// Status The schedule status, options: ACTIVE, FINISHED, CANCELLED.
	Status string `json:"status,omitempty"`

	// TimeEnd The schedule end time (UTC).
	TimeEnd string `json:"time_end,omitempty"`

	// TimeStart The schedule start time (UTC).
	TimeStart string `json:"time_start,omitempty"`
}

// ScheduleAnchorObject defines model for ScheduleAnchorObject.
type ScheduleAnchorObject struct {
	Payment      *Payment      `json:"Payment,omitempty"`
	PaymentBatch *PaymentBatch `json:"PaymentBatch,omitempty"`
}

// ScheduleInstance defines model for ScheduleInstance.
type ScheduleInstance struct {
	// ErrorMessage The message when the scheduled instance has run and failed due to user error.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference    `json:"request_reference_split_the_bill,omitempty"`
	ResultObject                 *ScheduleInstanceAnchorObject `json:"result_object,omitempty"`
	ScheduledObject              *ScheduleAnchorObject         `json:"scheduled_object,omitempty"`

	// State The state of the scheduleInstance. (FINISHED_SUCCESSFULLY, RETRY, FAILED_USER_ERROR)
	State string `json:"state,omitempty"`

	// TimeEnd The schedule end time (UTC).
	TimeEnd string `json:"time_end,omitempty"`

	// TimeStart The schedule start time (UTC).
	TimeStart string `json:"time_start,omitempty"`
}

// ScheduleInstanceAnchorObject defines model for ScheduleInstanceAnchorObject.
type ScheduleInstanceAnchorObject struct {
	Payment      *Payment      `json:"Payment,omitempty"`
	PaymentBatch *PaymentBatch `json:"PaymentBatch,omitempty"`
}

// ScheduleInstanceListing defines model for ScheduleInstanceListing.
type ScheduleInstanceListing struct {
	// ErrorMessage The message when the scheduled instance has run and failed due to user error.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference    `json:"request_reference_split_the_bill,omitempty"`
	ResultObject                 *ScheduleInstanceAnchorObject `json:"result_object,omitempty"`
	ScheduledObject              *ScheduleAnchorObject         `json:"scheduled_object,omitempty"`

	// State The state of the scheduleInstance. (FINISHED_SUCCESSFULLY, RETRY, FAILED_USER_ERROR)
	State string `json:"state,omitempty"`

	// TimeEnd The schedule end time (UTC).
	TimeEnd string `json:"time_end,omitempty"`

	// TimeStart The schedule start time (UTC).
	TimeStart string `json:"time_start,omitempty"`
}

// ScheduleInstanceRead defines model for ScheduleInstanceRead.
type ScheduleInstanceRead struct {
	// ErrorMessage The message when the scheduled instance has run and failed due to user error.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference    `json:"request_reference_split_the_bill,omitempty"`
	ResultObject                 *ScheduleInstanceAnchorObject `json:"result_object,omitempty"`
	ScheduledObject              *ScheduleAnchorObject         `json:"scheduled_object,omitempty"`

	// State The state of the scheduleInstance. (FINISHED_SUCCESSFULLY, RETRY, FAILED_USER_ERROR)
	State string `json:"state,omitempty"`

	// TimeEnd The schedule end time (UTC).
	TimeEnd string `json:"time_end,omitempty"`

	// TimeStart The schedule start time (UTC).
	TimeStart string `json:"time_start,omitempty"`
}

// ScheduleInstanceUpdate defines model for ScheduleInstanceUpdate.
type ScheduleInstanceUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// ScheduleListing defines model for ScheduleListing.
type ScheduleListing struct {
	Object *ScheduleAnchorObject `json:"object,omitempty"`

	// RecurrenceSize The schedule recurrence size. For example size 4 and unit WEEKLY means the recurrence is every 4 weeks.
	RecurrenceSize int `json:"recurrence_size,omitempty"`

	// RecurrenceUnit The schedule recurrence unit, options: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY
	RecurrenceUnit string `json:"recurrence_unit,omitempty"`

	// Status The schedule status, options: ACTIVE, FINISHED, CANCELLED.
	Status string `json:"status,omitempty"`

	// TimeEnd The schedule end time (UTC).
	TimeEnd string `json:"time_end,omitempty"`

	// TimeStart The schedule start time (UTC).
	TimeStart string `json:"time_start,omitempty"`
}

// SchedulePayment defines model for SchedulePayment.
type SchedulePayment struct {
	Payment  *SchedulePaymentEntry `json:"payment,omitempty"`
	Schedule *Schedule             `json:"schedule,omitempty"`

	// Status The schedule status, options: ACTIVE, FINISHED, CANCELLED.
	Status string `json:"status,omitempty"`
}

// SchedulePaymentBatch defines model for SchedulePaymentBatch.
type SchedulePaymentBatch struct {
	// Payments The payment details.
	Payments []SchedulePaymentEntry `json:"payments,omitempty"`
	Schedule *Schedule               `json:"schedule,omitempty"`
}

// SchedulePaymentBatchCreate defines model for SchedulePaymentBatchCreate.
type SchedulePaymentBatchCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// SchedulePaymentBatchDelete defines model for SchedulePaymentBatchDelete.
type SchedulePaymentBatchDelete = map[string]interface{}

// SchedulePaymentBatchRead defines model for SchedulePaymentBatchRead.
type SchedulePaymentBatchRead struct {
	// Payments The payment details.
	Payments []SchedulePaymentEntry `json:"payments,omitempty"`
	Schedule *Schedule               `json:"schedule,omitempty"`
}

// SchedulePaymentBatchUpdate defines model for SchedulePaymentBatchUpdate.
type SchedulePaymentBatchUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// SchedulePaymentCreate defines model for SchedulePaymentCreate.
type SchedulePaymentCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// SchedulePaymentDelete defines model for SchedulePaymentDelete.
type SchedulePaymentDelete = map[string]interface{}

// SchedulePaymentEntry defines model for SchedulePaymentEntry.
type SchedulePaymentEntry struct {
	Alias *LabelMonetaryAccount `json:"alias,omitempty"`

	// AllowBunqto Whether or not sending a bunq.to payment is allowed.
	AllowBunqto bool   `json:"allow_bunqto,omitempty"`
	Amount      Amount `json:"amount,omitempty"`

	// Attachment The Attachments attached to the Payment.
	Attachment        []AttachmentMonetaryAccountPayment `json:"attachment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount               `json:"counterparty_alias,omitempty"`

	// Description The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.
	Description string `json:"description,omitempty"`

	// MerchantReference Optional data included with the Payment specific to the merchant.
	MerchantReference string `json:"merchant_reference,omitempty"`
}

// SchedulePaymentListing defines model for SchedulePaymentListing.
type SchedulePaymentListing struct {
	Payment  *SchedulePaymentEntry `json:"payment,omitempty"`
	Schedule *Schedule             `json:"schedule,omitempty"`

	// Status The schedule status, options: ACTIVE, FINISHED, CANCELLED.
	Status string `json:"status,omitempty"`
}

// SchedulePaymentRead defines model for SchedulePaymentRead.
type SchedulePaymentRead struct {
	Payment  *SchedulePaymentEntry `json:"payment,omitempty"`
	Schedule *Schedule             `json:"schedule,omitempty"`

	// Status The schedule status, options: ACTIVE, FINISHED, CANCELLED.
	Status string `json:"status,omitempty"`
}

// SchedulePaymentUpdate defines model for SchedulePaymentUpdate.
type SchedulePaymentUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// ScheduleRead defines model for ScheduleRead.
type ScheduleRead struct {
	Object *ScheduleAnchorObject `json:"object,omitempty"`

	// RecurrenceSize The schedule recurrence size. For example size 4 and unit WEEKLY means the recurrence is every 4 weeks.
	RecurrenceSize int `json:"recurrence_size,omitempty"`

	// RecurrenceUnit The schedule recurrence unit, options: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY
	RecurrenceUnit string `json:"recurrence_unit,omitempty"`

	// Status The schedule status, options: ACTIVE, FINISHED, CANCELLED.
	Status string `json:"status,omitempty"`

	// TimeEnd The schedule end time (UTC).
	TimeEnd string `json:"time_end,omitempty"`

	// TimeStart The schedule start time (UTC).
	TimeStart string `json:"time_start,omitempty"`
}

// ScheduleUserListing defines model for ScheduleUserListing.
type ScheduleUserListing = map[string]interface{}

// ServerError defines model for ServerError.
type ServerError = map[string]interface{}

// ServerErrorCreate defines model for ServerErrorCreate.
type ServerErrorCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// SessionDelete defines model for SessionDelete.
type SessionDelete = map[string]interface{}

// SessionServer defines model for SessionServer.
type SessionServer struct {
	// Secret The API key of the user you want to login. If your API key has not been used before, it will be bound to the ip address of this DeviceServer.
	Secret string `json:"secret,omitempty"`
}

// SessionServerCreate defines model for SessionServerCreate.
type SessionServerCreate struct {
	Id                         *BunqId                     `json:"Id,omitempty"`
	Token                      *SessionServerToken         `json:"Token,omitempty"`
	UserApiKey                 *UserApiKey                 `json:"UserApiKey,omitempty"`
	UserCompany                *UserCompany                `json:"UserCompany,omitempty"`
	UserPaymentServiceProvider *UserPaymentServiceProvider `json:"UserPaymentServiceProvider,omitempty"`
	UserPerson                 *UserPerson                 `json:"UserPerson,omitempty"`
}

// SessionServerToken defines model for SessionServerToken.
type SessionServerToken struct {
	// Id The id of the Token.
	Id int `json:"id,omitempty"`

	// Token The Session token is the token the client has to provide in the "X-Bunq-Client-Authentication" header for each API call that requires a Session (only the creation of a Installation and DeviceServer don't require a Session).
	Token string `json:"token,omitempty"`
}

// ShareDetail defines model for ShareDetail.
type ShareDetail struct {
	DraftPayment *ShareDetailDraftPayment `json:"draft_payment,omitempty"`
	Payment      *ShareDetailPayment      `json:"payment,omitempty"`
	ReadOnly     *ShareDetailReadOnly     `json:"read_only,omitempty"`
}

// ShareDetailDraftPayment defines model for ShareDetailDraftPayment.
type ShareDetailDraftPayment struct {
	// MakeDraftPayments If set to true, the invited user will be able to make draft payments from the shared account.
	MakeDraftPayments bool `json:"make_draft_payments,omitempty"`

	// ViewBalance If set to true, the invited user will be able to view the account balance.
	ViewBalance bool `json:"view_balance,omitempty"`

	// ViewNewEvents If set to true, the invited user will be able to view events starting from the time the share became active.
	ViewNewEvents bool `json:"view_new_events,omitempty"`

	// ViewOldEvents If set to true, the invited user will be able to view events from before the share was active.
	ViewOldEvents bool `json:"view_old_events,omitempty"`
}

// ShareDetailPayment defines model for ShareDetailPayment.
type ShareDetailPayment struct {
	// MakeDraftPayments If set to true, the invited user will be able to make draft payments from the shared account.
	MakeDraftPayments bool `json:"make_draft_payments,omitempty"`

	// MakePayments If set to true, the invited user will be able to make payments from the shared account.
	MakePayments bool `json:"make_payments,omitempty"`

	// ViewBalance If set to true, the invited user will be able to view the account balance.
	ViewBalance bool `json:"view_balance,omitempty"`

	// ViewNewEvents If set to true, the invited user will be able to view events starting from the time the share became active.
	ViewNewEvents bool `json:"view_new_events,omitempty"`

	// ViewOldEvents If set to true, the invited user will be able to view events from before the share was active.
	ViewOldEvents bool `json:"view_old_events,omitempty"`
}

// ShareDetailReadOnly defines model for ShareDetailReadOnly.
type ShareDetailReadOnly struct {
	// ViewBalance If set to true, the invited user will be able to view the account balance.
	ViewBalance bool `json:"view_balance,omitempty"`

	// ViewNewEvents If set to true, the invited user will be able to view events starting from the time the share became active.
	ViewNewEvents bool `json:"view_new_events,omitempty"`

	// ViewOldEvents If set to true, the invited user will be able to view events from before the share was active.
	ViewOldEvents bool `json:"view_old_events,omitempty"`
}

// ShareInviteMonetaryAccountInquiry defines model for ShareInviteMonetaryAccountInquiry.
type ShareInviteMonetaryAccountInquiry struct {
	// AccessType Type of access that is in place.
	AccessType       string               `json:"access_type,omitempty"`
	Alias            *LabelMonetaryAccount `json:"alias,omitempty"`
	CounterUserAlias *LabelUser            `json:"counter_user_alias,omitempty"`

	// DraftShareInviteBankId DEPRECATED: USE `access_type` INSTEAD | The id of the draft share invite bank.
	DraftShareInviteBankId int `json:"draft_share_invite_bank_id,omitempty"`

	// EndDate DEPRECATED: USE `access_type` INSTEAD | The expiration date of this share.
	EndDate string `json:"end_date,omitempty"`

	// Id The id of the newly created share invite.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the share applies to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Relationship The relationship: COMPANY_DIRECTOR, COMPANY_EMPLOYEE, etc
	Relationship string      `json:"relationship,omitempty"`
	ShareDetail  *ShareDetail `json:"share_detail,omitempty"`

	// ShareType DEPRECATED: USE `access_type` INSTEAD | The share type, either STANDARD or MUTUAL.
	ShareType string `json:"share_type,omitempty"`

	// StartDate DEPRECATED: USE `access_type` INSTEAD | The start date of this share.
	StartDate string `json:"start_date,omitempty"`

	// Status The status of the share. Can be ACTIVE, REVOKED, REJECTED.
	Status           string    `json:"status,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
	UserAliasRevoked *LabelUser `json:"user_alias_revoked,omitempty"`
}

// ShareInviteMonetaryAccountInquiryCreate defines model for ShareInviteMonetaryAccountInquiryCreate.
type ShareInviteMonetaryAccountInquiryCreate struct {
	// Id The id of the newly created share invite.
	Id int `json:"id,omitempty"`
}

// ShareInviteMonetaryAccountInquiryListing defines model for ShareInviteMonetaryAccountInquiryListing.
type ShareInviteMonetaryAccountInquiryListing struct {
	// AccessType Type of access that is in place.
	AccessType       string               `json:"access_type,omitempty"`
	Alias            *LabelMonetaryAccount `json:"alias,omitempty"`
	CounterUserAlias *LabelUser            `json:"counter_user_alias,omitempty"`

	// Id The id of the newly created share invite.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the share applies to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Relationship The relationship: COMPANY_DIRECTOR, COMPANY_EMPLOYEE, etc
	Relationship string `json:"relationship,omitempty"`

	// Status The status of the share. Can be ACTIVE, REVOKED, REJECTED.
	Status           string    `json:"status,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
	UserAliasRevoked *LabelUser `json:"user_alias_revoked,omitempty"`
}

// ShareInviteMonetaryAccountInquiryRead defines model for ShareInviteMonetaryAccountInquiryRead.
type ShareInviteMonetaryAccountInquiryRead struct {
	// AccessType Type of access that is in place.
	AccessType       string               `json:"access_type,omitempty"`
	Alias            *LabelMonetaryAccount `json:"alias,omitempty"`
	CounterUserAlias *LabelUser            `json:"counter_user_alias,omitempty"`

	// Id The id of the newly created share invite.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the share applies to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Relationship The relationship: COMPANY_DIRECTOR, COMPANY_EMPLOYEE, etc
	Relationship string `json:"relationship,omitempty"`

	// Status The status of the share. Can be ACTIVE, REVOKED, REJECTED.
	Status           string    `json:"status,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
	UserAliasRevoked *LabelUser `json:"user_alias_revoked,omitempty"`
}

// ShareInviteMonetaryAccountInquiryUpdate defines model for ShareInviteMonetaryAccountInquiryUpdate.
type ShareInviteMonetaryAccountInquiryUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// ShareInviteMonetaryAccountResponse defines model for ShareInviteMonetaryAccountResponse.
type ShareInviteMonetaryAccountResponse struct {
	// AccessType Type of access that is wanted, one of VIEW_BALANCE, VIEW_TRANSACTION, DRAFT_PAYMENT or FULL_TRANSIENT
	AccessType string `json:"access_type,omitempty"`

	// CardId The card to link to the shared monetary account. Used only if share_detail is ShareDetailCardPayment.
	CardId       int                  `json:"card_id,omitempty"`
	CounterAlias *LabelMonetaryAccount `json:"counter_alias,omitempty"`

	// Created The timestamp of the ShareInviteBankResponse creation.
	Created string `json:"created,omitempty"`

	// Description The description of this share. It is basically the monetary account description.
	Description string `json:"description,omitempty"`

	// DraftShareInviteBankId The id of the draft share invite bank.
	DraftShareInviteBankId int `json:"draft_share_invite_bank_id,omitempty"`

	// EndDate The expiration date of this share.
	EndDate string `json:"end_date,omitempty"`

	// Id The id of the ShareInviteBankResponse.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the ACCEPTED share applies to. null otherwise.
	MonetaryAccountId int          `json:"monetary_account_id,omitempty"`
	RelationUser      *RelationUser `json:"relation_user,omitempty"`
	ShareDetail       *ShareDetail  `json:"share_detail,omitempty"`

	// ShareType The share type, either STANDARD or MUTUAL.
	ShareType string `json:"share_type,omitempty"`

	// StartDate The start date of this share.
	StartDate string `json:"start_date,omitempty"`

	// Status The status of the share. Can be ACTIVE, REVOKED, REJECTED.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the ShareInviteBankResponse last update.
	Updated            string    `json:"updated,omitempty"`
	UserAliasCancelled *LabelUser `json:"user_alias_cancelled,omitempty"`
}

// ShareInviteMonetaryAccountResponseListing defines model for ShareInviteMonetaryAccountResponseListing.
type ShareInviteMonetaryAccountResponseListing struct {
	// AccessType Type of access that is wanted, one of VIEW_BALANCE, VIEW_TRANSACTION, DRAFT_PAYMENT or FULL_TRANSIENT
	AccessType   string               `json:"access_type,omitempty"`
	CounterAlias *LabelMonetaryAccount `json:"counter_alias,omitempty"`

	// Created The timestamp of the ShareInviteBankResponse creation.
	Created string `json:"created,omitempty"`

	// Description The description of this share. It is basically the monetary account description.
	Description string `json:"description,omitempty"`

	// DraftShareInviteBankId The id of the draft share invite bank.
	DraftShareInviteBankId int `json:"draft_share_invite_bank_id,omitempty"`

	// EndDate The expiration date of this share.
	EndDate string `json:"end_date,omitempty"`

	// Id The id of the ShareInviteBankResponse.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the ACCEPTED share applies to. null otherwise.
	MonetaryAccountId int          `json:"monetary_account_id,omitempty"`
	RelationUser      *RelationUser `json:"relation_user,omitempty"`
	ShareDetail       *ShareDetail  `json:"share_detail,omitempty"`

	// ShareType The share type, either STANDARD or MUTUAL.
	ShareType string `json:"share_type,omitempty"`

	// StartDate The start date of this share.
	StartDate string `json:"start_date,omitempty"`

	// Status The status of the share. Can be ACTIVE, REVOKED, REJECTED.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the ShareInviteBankResponse last update.
	Updated            string    `json:"updated,omitempty"`
	UserAliasCancelled *LabelUser `json:"user_alias_cancelled,omitempty"`
}

// ShareInviteMonetaryAccountResponseRead defines model for ShareInviteMonetaryAccountResponseRead.
type ShareInviteMonetaryAccountResponseRead struct {
	// AccessType Type of access that is wanted, one of VIEW_BALANCE, VIEW_TRANSACTION, DRAFT_PAYMENT or FULL_TRANSIENT
	AccessType   string               `json:"access_type,omitempty"`
	CounterAlias *LabelMonetaryAccount `json:"counter_alias,omitempty"`

	// Created The timestamp of the ShareInviteBankResponse creation.
	Created string `json:"created,omitempty"`

	// Description The description of this share. It is basically the monetary account description.
	Description string `json:"description,omitempty"`

	// DraftShareInviteBankId The id of the draft share invite bank.
	DraftShareInviteBankId int `json:"draft_share_invite_bank_id,omitempty"`

	// EndDate The expiration date of this share.
	EndDate string `json:"end_date,omitempty"`

	// Id The id of the ShareInviteBankResponse.
	Id int `json:"id,omitempty"`

	// MonetaryAccountId The id of the monetary account the ACCEPTED share applies to. null otherwise.
	MonetaryAccountId int          `json:"monetary_account_id,omitempty"`
	RelationUser      *RelationUser `json:"relation_user,omitempty"`
	ShareDetail       *ShareDetail  `json:"share_detail,omitempty"`

	// ShareType The share type, either STANDARD or MUTUAL.
	ShareType string `json:"share_type,omitempty"`

	// StartDate The start date of this share.
	StartDate string `json:"start_date,omitempty"`

	// Status The status of the share. Can be ACTIVE, REVOKED, REJECTED.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the ShareInviteBankResponse last update.
	Updated            string    `json:"updated,omitempty"`
	UserAliasCancelled *LabelUser `json:"user_alias_cancelled,omitempty"`
}

// ShareInviteMonetaryAccountResponseUpdate defines model for ShareInviteMonetaryAccountResponseUpdate.
type ShareInviteMonetaryAccountResponseUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// SofortMerchantTransaction defines model for SofortMerchantTransaction.
type SofortMerchantTransaction struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountGuaranteed  Amount               `json:"amount_guaranteed,omitempty"`
	AmountRequested   Amount               `json:"amount_requested,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// ErrorMessage The error message of the transaction.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// Issuer The BIC of the issuer.
	Issuer string `json:"issuer,omitempty"`

	// IssuerAuthenticationUrl The URL to visit to
	IssuerAuthenticationUrl string `json:"issuer_authentication_url,omitempty"`

	// MonetaryAccountId The id of the monetary account this sofort merchant transaction links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Status The status of the transaction.
	Status string `json:"status,omitempty"`

	// TransactionIdentifier The 'transaction ID' of the Sofort transaction.
	TransactionIdentifier string `json:"transaction_identifier,omitempty"`
}

// SofortMerchantTransactionListing defines model for SofortMerchantTransactionListing.
type SofortMerchantTransactionListing struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountGuaranteed  Amount               `json:"amount_guaranteed,omitempty"`
	AmountRequested   Amount               `json:"amount_requested,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// ErrorMessage The error message of the transaction.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// Issuer The BIC of the issuer.
	Issuer string `json:"issuer,omitempty"`

	// IssuerAuthenticationUrl The URL to visit to
	IssuerAuthenticationUrl string `json:"issuer_authentication_url,omitempty"`

	// MonetaryAccountId The id of the monetary account this sofort merchant transaction links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Status The status of the transaction.
	Status string `json:"status,omitempty"`

	// TransactionIdentifier The 'transaction ID' of the Sofort transaction.
	TransactionIdentifier string `json:"transaction_identifier,omitempty"`
}

// SofortMerchantTransactionRead defines model for SofortMerchantTransactionRead.
type SofortMerchantTransactionRead struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountGuaranteed  Amount               `json:"amount_guaranteed,omitempty"`
	AmountRequested   Amount               `json:"amount_requested,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// ErrorMessage The error message of the transaction.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// Issuer The BIC of the issuer.
	Issuer string `json:"issuer,omitempty"`

	// IssuerAuthenticationUrl The URL to visit to
	IssuerAuthenticationUrl string `json:"issuer_authentication_url,omitempty"`

	// MonetaryAccountId The id of the monetary account this sofort merchant transaction links to.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// Status The status of the transaction.
	Status string `json:"status,omitempty"`

	// TransactionIdentifier The 'transaction ID' of the Sofort transaction.
	TransactionIdentifier string `json:"transaction_identifier,omitempty"`
}

// TaxResident defines model for TaxResident.
type TaxResident struct {
	// Country The country of the tax number.
	Country string `json:"country,omitempty"`

	// Id The id of the tax resident.
	Id int `json:"id,omitempty"`

	// Status The status of the tax number. Either CONFIRMED or UNCONFIRMED.
	Status string `json:"status,omitempty"`

	// TaxNumber The tax number.
	TaxNumber string `json:"tax_number,omitempty"`
}

// TokenQrRequestIdeal defines model for TokenQrRequestIdeal.
type TokenQrRequestIdeal struct {
	// Token The token passed from a site or read from a QR code.
	Token string `json:"token,omitempty"`
}

// TokenQrRequestIdealCreate defines model for TokenQrRequestIdealCreate.
type TokenQrRequestIdealCreate struct {
	AddressBilling  *Address              `json:"address_billing,omitempty"`
	AddressShipping *Address              `json:"address_shipping,omitempty"`
	Alias           *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountInquired  Amount               `json:"amount_inquired,omitempty"`
	AmountResponded Amount               `json:"amount_responded,omitempty"`

	// Attachment The Attachments attached to the RequestResponse.
	Attachment        []Attachment         `json:"attachment,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// Description The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.
	Description string `json:"description,omitempty"`

	// EligibleWhitelistId The whitelist id for this action or null.
	EligibleWhitelistId int         `json:"eligible_whitelist_id,omitempty"`
	Geolocation         *Geolocation `json:"geolocation,omitempty"`

	// Id The id of the RequestResponse.
	Id int `json:"id,omitempty"`

	// MinimumAge The minimum age the user accepting the RequestResponse must have.
	MinimumAge int `json:"minimum_age,omitempty"`

	// MonetaryAccountId The id of the MonetaryAccount the RequestResponse was received on.
	MonetaryAccountId int `json:"monetary_account_id,omitempty"`

	// RedirectUrl The URL which the user is sent to after accepting or rejecting the Request.
	RedirectUrl string `json:"redirect_url,omitempty"`

	// RequireAddress Whether or not an address must be provided on accept.
	RequireAddress string `json:"require_address,omitempty"`

	// Status The status of the created RequestResponse. Can only be PENDING.
	Status string `json:"status,omitempty"`

	// SubType The subtype of the RequestResponse. Can be only be NONE.
	SubType string `json:"sub_type,omitempty"`

	// TimeExpiry The timestamp of when the RequestResponse expired or will expire.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// TimeResponded The timestamp of when the RequestResponse was responded to.
	TimeResponded string `json:"time_responded,omitempty"`

	// Type The type of the RequestResponse. Can be only be IDEAL.
	Type string `json:"type,omitempty"`
}

// TokenQrRequestSofort defines model for TokenQrRequestSofort.
type TokenQrRequestSofort struct {
	// Token The token passed from a site or read from a QR code.
	Token string `json:"token,omitempty"`
}

// TokenQrRequestSofortCreate defines model for TokenQrRequestSofortCreate.
type TokenQrRequestSofortCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseAccountQuote defines model for TransferwiseAccountQuote.
type TransferwiseAccountQuote struct {
	// Country The country of the receiving account.
	Country string `json:"country,omitempty"`

	// Detail The fields which were specified as "required" and have since been filled by the user. Always provide the full list.
	Detail []TransferwiseRequirementField `json:"detail,omitempty"`

	// NameAccountHolder The name of the account holder.
	NameAccountHolder string `json:"name_account_holder"`

	// Type The chosen recipient account type. The possible options are provided dynamically in the response endpoint.
	Type string `json:"type,omitempty"`
}

// TransferwiseAccountQuoteCreate defines model for TransferwiseAccountQuoteCreate.
type TransferwiseAccountQuoteCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseAccountQuoteDelete defines model for TransferwiseAccountQuoteDelete.
type TransferwiseAccountQuoteDelete = map[string]interface{}

// TransferwiseAccountQuoteListing defines model for TransferwiseAccountQuoteListing.
type TransferwiseAccountQuoteListing struct {
	// AccountId Transferwise's id of the account.
	AccountId string `json:"account_id,omitempty"`

	// AccountNumber The account number.
	AccountNumber string `json:"account_number,omitempty"`

	// BankCode The bank code.
	BankCode string `json:"bank_code,omitempty"`

	// Country The country of the account.
	Country string `json:"country,omitempty"`

	// Currency The currency the account.
	Currency string `json:"currency,omitempty"`

	// NameAccountHolder The name of the account holder.
	NameAccountHolder string `json:"name_account_holder,omitempty"`
}

// TransferwiseAccountQuoteRead defines model for TransferwiseAccountQuoteRead.
type TransferwiseAccountQuoteRead struct {
	// AccountId Transferwise's id of the account.
	AccountId string `json:"account_id,omitempty"`

	// AccountNumber The account number.
	AccountNumber string `json:"account_number,omitempty"`

	// BankCode The bank code.
	BankCode string `json:"bank_code,omitempty"`

	// Country The country of the account.
	Country string `json:"country,omitempty"`

	// Currency The currency the account.
	Currency string `json:"currency,omitempty"`

	// NameAccountHolder The name of the account holder.
	NameAccountHolder string `json:"name_account_holder,omitempty"`
}

// TransferwiseAccountRequirement defines model for TransferwiseAccountRequirement.
type TransferwiseAccountRequirement struct {
	// Country The country of the receiving account.
	Country string `json:"country,omitempty"`

	// Detail The fields which were specified as "required" and have since been filled by the user. Always provide the full list.
	Detail []TransferwiseRequirementField `json:"detail,omitempty"`

	// NameAccountHolder The name of the account holder.
	NameAccountHolder string `json:"name_account_holder,omitempty"`

	// Type The chosen recipient account type. The possible options are provided dynamically in the response endpoint.
	Type string `json:"type"`
}

// TransferwiseAccountRequirementCreate defines model for TransferwiseAccountRequirementCreate.
type TransferwiseAccountRequirementCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseAccountRequirementListing defines model for TransferwiseAccountRequirementListing.
type TransferwiseAccountRequirementListing struct {
	// Fields The fields which the user needs to fill.
	Fields []TransferwiseRequirementField `json:"fields,omitempty"`

	// Label The label of the possible recipient account type to show to the user.
	Label string `json:"label,omitempty"`

	// Type A possible recipient account type.
	Type string `json:"type,omitempty"`
}

// TransferwiseCurrencyListing defines model for TransferwiseCurrencyListing.
type TransferwiseCurrencyListing struct {
	// Country The country code associated with the currency.
	Country string `json:"country,omitempty"`

	// Currency The currency code.
	Currency string `json:"currency,omitempty"`

	// Name The currency name.
	Name string `json:"name,omitempty"`
}

// TransferwiseQuote defines model for TransferwiseQuote.
type TransferwiseQuote struct {
	AmountFee    Amount `json:"amount_fee,omitempty"`
	AmountSource Amount `json:"amount_source,omitempty"`
	AmountTarget Amount `json:"amount_target,omitempty"`

	// Created The timestamp of the quote's creation.
	Created string `json:"created,omitempty"`

	// CurrencySource The source currency.
	CurrencySource string `json:"currency_source,omitempty"`

	// CurrencyTarget The target currency.
	CurrencyTarget string `json:"currency_target,omitempty"`

	// Id The id of the quote.
	Id int `json:"id,omitempty"`

	// QuoteId The quote id Transferwise needs.
	QuoteId string `json:"quote_id,omitempty"`

	// Rate The rate.
	Rate string `json:"rate,omitempty"`

	// TimeDeliveryEstimate The estimated delivery time.
	TimeDeliveryEstimate string `json:"time_delivery_estimate,omitempty"`

	// TimeExpiry The expiration timestamp of the quote.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Updated The timestamp of the quote's last update.
	Updated string `json:"updated,omitempty"`
}

// TransferwiseQuoteCreate defines model for TransferwiseQuoteCreate.
type TransferwiseQuoteCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseQuoteRead defines model for TransferwiseQuoteRead.
type TransferwiseQuoteRead struct {
	AmountFee    Amount `json:"amount_fee,omitempty"`
	AmountSource Amount `json:"amount_source,omitempty"`
	AmountTarget Amount `json:"amount_target,omitempty"`

	// Created The timestamp of the quote's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the quote.
	Id int `json:"id,omitempty"`

	// QuoteId The quote id Transferwise needs.
	QuoteId string `json:"quote_id,omitempty"`

	// Rate The rate.
	Rate string `json:"rate,omitempty"`

	// TimeDeliveryEstimate The estimated delivery time.
	TimeDeliveryEstimate string `json:"time_delivery_estimate,omitempty"`

	// TimeExpiry The expiration timestamp of the quote.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Updated The timestamp of the quote's last update.
	Updated string `json:"updated,omitempty"`
}

// TransferwiseQuoteTemporary defines model for TransferwiseQuoteTemporary.
type TransferwiseQuoteTemporary struct {
	AmountSource Amount `json:"amount_source,omitempty"`
	AmountTarget Amount `json:"amount_target,omitempty"`

	// CurrencySource The source currency.
	CurrencySource string `json:"currency_source,omitempty"`

	// CurrencyTarget The target currency.
	CurrencyTarget string `json:"currency_target,omitempty"`
}

// TransferwiseQuoteTemporaryCreate defines model for TransferwiseQuoteTemporaryCreate.
type TransferwiseQuoteTemporaryCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseQuoteTemporaryRead defines model for TransferwiseQuoteTemporaryRead.
type TransferwiseQuoteTemporaryRead struct {
	AmountSource Amount `json:"amount_source,omitempty"`
	AmountTarget Amount `json:"amount_target,omitempty"`

	// Created The timestamp of the note's creation.
	Created string `json:"created,omitempty"`

	// Id The id of the quote.
	Id int `json:"id,omitempty"`

	// QuoteId The quote id Transferwise needs. Will always be null for temporary quotes.
	QuoteId string `json:"quote_id,omitempty"`

	// Rate The rate.
	Rate string `json:"rate,omitempty"`

	// TimeExpiry The expiration timestamp of the quote. Will always be null for temporary quotes.
	TimeExpiry string `json:"time_expiry,omitempty"`

	// Updated The timestamp of the note's last update.
	Updated string `json:"updated,omitempty"`
}

// TransferwiseRequirementField defines model for TransferwiseRequirementField.
type TransferwiseRequirementField struct {
	Group *TransferwiseRequirementFieldGroup `json:"group,omitempty"`

	// Key The name of the required field.
	Key string `json:"key,omitempty"`

	// Name The descriptive label of the field.
	Name string `json:"name,omitempty"`

	// Value The value of the required field.
	Value string `json:"value,omitempty"`
}

// TransferwiseRequirementFieldGroup defines model for TransferwiseRequirementFieldGroup.
type TransferwiseRequirementFieldGroup struct {
	// DisplayFormat Formatting mask to guide user input.
	DisplayFormat string `json:"display_format,omitempty"`

	// Example An example value for this field.
	Example string `json:"example,omitempty"`

	// Key The key of the field. This is the value to send as input.
	Key string `json:"key,omitempty"`

	// MaxLength The maximum length of the field's value.
	MaxLength string `json:"max_length,omitempty"`

	// MinLength The minimum length of the field's value.
	MinLength string `json:"min_length,omitempty"`

	// Name The field name.
	Name string `json:"name,omitempty"`

	// RefreshRequirementsOnChange Indicates that any changes in this field affect the requirements, if this field is changed, the requirements endpoint must be called again to recheck if there are any additional requirements.
	RefreshRequirementsOnChange bool `json:"refresh_requirements_on_change,omitempty"`

	// Required Whether or not the field is required.
	Required bool `json:"required,omitempty"`

	// Type The field's input type: "text", "select" or "radio".
	Type            string                                           `json:"type,omitempty"`
	ValidationAsync *TransferwiseRequirementFieldGroupValidationAsync `json:"validation_async,omitempty"`

	// ValidationRegexp A regular expression which may be used to validate the user input.
	ValidationRegexp string                                         `json:"validation_regexp,omitempty"`
	ValuesAllowed    *TransferwiseRequirementFieldGroupValuesAllowed `json:"values_allowed,omitempty"`
}

// TransferwiseRequirementFieldGroupValidationAsync defines model for TransferwiseRequirementFieldGroupValidationAsync.
type TransferwiseRequirementFieldGroupValidationAsync struct {
	Params *TransferwiseRequirementFieldGroupValidationAsyncParams `json:"params,omitempty"`

	// Url The url to be used to validate user input.
	Url string `json:"url,omitempty"`
}

// TransferwiseRequirementFieldGroupValidationAsyncParams defines model for TransferwiseRequirementFieldGroupValidationAsyncParams.
type TransferwiseRequirementFieldGroupValidationAsyncParams struct {
	// Key The parameter key.
	Key string `json:"key,omitempty"`

	// ParameterName The parameter label.
	ParameterName string `json:"parameter_name,omitempty"`

	// Required Shows whether the parameter is required or not.
	Required bool `json:"required,omitempty"`
}

// TransferwiseRequirementFieldGroupValuesAllowed defines model for TransferwiseRequirementFieldGroupValuesAllowed.
type TransferwiseRequirementFieldGroupValuesAllowed struct {
	// Key The key.
	Key string `json:"key,omitempty"`

	// Name The label.
	Name string `json:"name,omitempty"`
}

// TransferwiseTransfer defines model for TransferwiseTransfer.
type TransferwiseTransfer struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountSource      Amount               `json:"amount_source,omitempty"`
	AmountTarget      Amount               `json:"amount_target,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// MonetaryAccountId The id of the monetary account the payment should be made from.
	MonetaryAccountId string `json:"monetary_account_id,omitempty"`

	// PayInReference The Pay-In reference of the payment.
	PayInReference string            `json:"pay_in_reference,omitempty"`
	Quote          *TransferwiseQuote `json:"quote,omitempty"`

	// Rate The rate of the payment.
	Rate string `json:"rate,omitempty"`

	// RecipientId The id of the target account.
	RecipientId string `json:"recipient_id,omitempty"`

	// Reference The reference of the payment.
	Reference string `json:"reference,omitempty"`

	// Status The status.
	Status string `json:"status,omitempty"`

	// StatusTransferwise The status as Transferwise reports it.
	StatusTransferwise string `json:"status_transferwise,omitempty"`

	// StatusTransferwiseIssue A status to indicatie if Transferwise has an issue with this payment and requires more information.
	StatusTransferwiseIssue string `json:"status_transferwise_issue,omitempty"`

	// SubStatus The subStatus.
	SubStatus string `json:"sub_status,omitempty"`

	// TimeDeliveryEstimate The estimated delivery time.
	TimeDeliveryEstimate string `json:"time_delivery_estimate,omitempty"`
}

// TransferwiseTransferCreate defines model for TransferwiseTransferCreate.
type TransferwiseTransferCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseTransferListing defines model for TransferwiseTransferListing.
type TransferwiseTransferListing struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountSource      Amount               `json:"amount_source,omitempty"`
	AmountTarget      Amount               `json:"amount_target,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// PayInReference The Pay-In reference of the payment.
	PayInReference string            `json:"pay_in_reference,omitempty"`
	Quote          *TransferwiseQuote `json:"quote,omitempty"`

	// Rate The rate of the payment.
	Rate string `json:"rate,omitempty"`

	// Reference The reference of the payment.
	Reference string `json:"reference,omitempty"`

	// Status The status.
	Status string `json:"status,omitempty"`

	// StatusTransferwise The status as Transferwise reports it.
	StatusTransferwise string `json:"status_transferwise,omitempty"`

	// StatusTransferwiseIssue A status to indicatie if Transferwise has an issue with this payment and requires more information.
	StatusTransferwiseIssue string `json:"status_transferwise_issue,omitempty"`

	// SubStatus The subStatus.
	SubStatus string `json:"sub_status,omitempty"`

	// TimeDeliveryEstimate The estimated delivery time.
	TimeDeliveryEstimate string `json:"time_delivery_estimate,omitempty"`
}

// TransferwiseTransferRead defines model for TransferwiseTransferRead.
type TransferwiseTransferRead struct {
	Alias             *LabelMonetaryAccount `json:"alias,omitempty"`
	AmountSource      Amount               `json:"amount_source,omitempty"`
	AmountTarget      Amount               `json:"amount_target,omitempty"`
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// PayInReference The Pay-In reference of the payment.
	PayInReference string            `json:"pay_in_reference,omitempty"`
	Quote          *TransferwiseQuote `json:"quote,omitempty"`

	// Rate The rate of the payment.
	Rate string `json:"rate,omitempty"`

	// Reference The reference of the payment.
	Reference string `json:"reference,omitempty"`

	// Status The status.
	Status string `json:"status,omitempty"`

	// StatusTransferwise The status as Transferwise reports it.
	StatusTransferwise string `json:"status_transferwise,omitempty"`

	// StatusTransferwiseIssue A status to indicatie if Transferwise has an issue with this payment and requires more information.
	StatusTransferwiseIssue string `json:"status_transferwise_issue,omitempty"`

	// SubStatus The subStatus.
	SubStatus string `json:"sub_status,omitempty"`

	// TimeDeliveryEstimate The estimated delivery time.
	TimeDeliveryEstimate string `json:"time_delivery_estimate,omitempty"`
}

// TransferwiseTransferRequirement defines model for TransferwiseTransferRequirement.
type TransferwiseTransferRequirement struct {
	// Detail The fields which were specified as "required" and have since been filled by the user. Always provide the full list.
	Detail []TransferwiseRequirementField `json:"detail,omitempty"`

	// RecipientId The id of the target account.
	RecipientId string `json:"recipient_id,omitempty"`
}

// TransferwiseTransferRequirementCreate defines model for TransferwiseTransferRequirementCreate.
type TransferwiseTransferRequirementCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseUser defines model for TransferwiseUser.
type TransferwiseUser struct {
	// OauthCode The OAuth code returned by Transferwise we should be using to gain access to the user's Transferwise account.
	OauthCode string `json:"oauth_code,omitempty"`
}

// TransferwiseUserCreate defines model for TransferwiseUserCreate.
type TransferwiseUserCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// TransferwiseUserListing defines model for TransferwiseUserListing.
type TransferwiseUserListing struct {
	// Created The timestamp of the TransferwiseUser's creation.
	Created string `json:"created,omitempty"`

	// Email The email the user is registered with at TransferWise.
	Email string `json:"email,omitempty"`

	// Id The id of the TransferwiseUser.
	Id int `json:"id,omitempty"`

	// Name The name the user is registered with at TransferWise.
	Name string `json:"name,omitempty"`

	// Source The source of the user at TransferWise.
	Source string `json:"source,omitempty"`

	// Updated The timestamp of the TransferwiseUser's last update.
	Updated string `json:"updated,omitempty"`
}

// TreeProgressListing defines model for TreeProgressListing.
type TreeProgressListing struct {
	LabelUser *LabelUser `json:"label_user,omitempty"`

	// NumberOfTree The number of trees this user and all users have planted.
	NumberOfTree int `json:"number_of_tree,omitempty"`

	// ProgressTreeNext The progress towards the next tree.
	ProgressTreeNext int `json:"progress_tree_next,omitempty"`

	// UrlInviteProfile URL of the invite profile.
	UrlInviteProfile string `json:"url_invite_profile,omitempty"`
}

// Ubo defines model for Ubo.
type Ubo struct {
	// DateOfBirth The date of birth of the ultimate beneficiary owner.
	DateOfBirth string `json:"date_of_birth,omitempty"`

	// Name The name of the ultimate beneficiary owner.
	Name string `json:"name,omitempty"`

	// Nationality The nationality of the ultimate beneficiary owner.
	Nationality string `json:"nationality,omitempty"`
}

// UserApiKey defines model for UserApiKey.
type UserApiKey struct {
	// Created The timestamp of the user object's creation.
	Created       string                 `json:"created,omitempty"`
	GrantedByUser *UserApiKeyAnchoredUser `json:"granted_by_user,omitempty"`

	// Id The id of the user.
	Id              int                    `json:"id,omitempty"`
	RequestedByUser *UserApiKeyAnchoredUser `json:"requested_by_user,omitempty"`

	// Updated The timestamp of the user object's last update.
	Updated string `json:"updated,omitempty"`
}

// UserApiKeyAnchoredUser defines model for UserApiKeyAnchoredUser.
type UserApiKeyAnchoredUser struct {
	UserCompany                *UserCompany                `json:"UserCompany,omitempty"`
	UserPaymentServiceProvider *UserPaymentServiceProvider `json:"UserPaymentServiceProvider,omitempty"`
	UserPerson                 *UserPerson                 `json:"UserPerson,omitempty"`
}

// UserBlocklistMasterCardMerchant defines model for UserBlocklistMasterCardMerchant.
type UserBlocklistMasterCardMerchant struct {
	// Created The timestamp of the object's creation.
	Created string `json:"created,omitempty"`

	// ExternalMerchantId Externally provided merchant identification.
	ExternalMerchantId string `json:"external_merchant_id,omitempty"`

	// Id The id of the blocklist.
	Id int `json:"id,omitempty"`

	// MastercardMerchantId The blocklisted merchant.
	MastercardMerchantId string `json:"mastercard_merchant_id,omitempty"`
	MerchantAvatar       *Avatar `json:"merchant_avatar,omitempty"`

	// MerchantHash Hash of the merchant we are blocklisting.
	MerchantHash string `json:"merchant_hash,omitempty"`

	// MerchantId The blocklisted merchant.
	MerchantId string `json:"merchant_id,omitempty"`

	// MerchantIdentifier Identifier of the merchant we are blocklisting.
	MerchantIdentifier string `json:"merchant_identifier,omitempty"`

	// MerchantName The name of the merchant.
	MerchantName string `json:"merchant_name,omitempty"`

	// Status The status of the the blocklist.
	Status string `json:"status,omitempty"`

	// Updated The timestamp of the object's last update.
	Updated string `json:"updated,omitempty"`
}

// UserCompany defines model for UserCompany.
type UserCompany struct {
	AddressMain   *Address `json:"address_main,omitempty"`
	AddressPostal *Address `json:"address_postal,omitempty"`

	// Alias The aliases of the account.
	Alias  []Pointer `json:"alias,omitempty"`
	Avatar *Avatar    `json:"avatar,omitempty"`

	// AvatarUuid The public UUID of the company's avatar.
	AvatarUuid string `json:"avatar_uuid,omitempty"`

	// BillingContract The subscription of the company.
	BillingContract []BillingContractSubscription `json:"billing_contract,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string `json:"chamber_of_commerce_number,omitempty"`

	// CounterBankIban The company's other bank account IBAN, through which we verify it.
	CounterBankIban string `json:"counter_bank_iban,omitempty"`

	// Country The country as an ISO 3166-1 alpha-2 country code.
	Country string `json:"country,omitempty"`

	// Created The timestamp of the company object's creation.
	Created                            string        `json:"created,omitempty"`
	Customer                           *Customer      `json:"customer,omitempty"`
	CustomerLimit                      *CustomerLimit `json:"customer_limit,omitempty"`
	DailyLimitWithoutConfirmationLogin Amount        `json:"daily_limit_without_confirmation_login,omitempty"`

	// DenyReason The user deny reason.
	DenyReason string `json:"deny_reason,omitempty"`

	// Directors The existing bunq aliases for the company's directors.
	Directors []LabelUser `json:"directors,omitempty"`

	// DisplayName The company's display name.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the modified company.
	Id int `json:"id,omitempty"`

	// Language The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Language string `json:"language,omitempty"`

	// LegalForm The company's legal form.
	LegalForm string `json:"legal_form,omitempty"`

	// Name The company name.
	Name string `json:"name,omitempty"`

	// NotificationFilters The types of notifications that will result in a push notification or URL callback for this UserCompany.
	NotificationFilters []NotificationFilter `json:"notification_filters,omitempty"`

	// PublicNickName The company's public nick name.
	PublicNickName string `json:"public_nick_name,omitempty"`

	// PublicUuid The company's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Region The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Region string `json:"region,omitempty"`

	// Relations The relations for this user.
	Relations []RelationUser `json:"relations,omitempty"`

	// SectorOfIndustry The sector of industry.
	SectorOfIndustry string `json:"sector_of_industry,omitempty"`

	// SessionTimeout The setting for the session timeout of the company in seconds.
	SessionTimeout int `json:"session_timeout,omitempty"`

	// Status The user status. Can be: ACTIVE, SIGNUP, RECOVERY.
	Status string `json:"status,omitempty"`

	// SubStatus The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.
	SubStatus string `json:"sub_status,omitempty"`

	// TaxResident The user's tax residence numbers for different countries.
	TaxResident []TaxResident `json:"tax_resident,omitempty"`

	// TypeOfBusinessEntity The type of business entity.
	TypeOfBusinessEntity string `json:"type_of_business_entity,omitempty"`

	// Ubo The names of the company's ultimate beneficiary owners. Minimum zero, maximum four.
	Ubo []Ubo `json:"ubo,omitempty"`

	// Updated The timestamp of the company object's last update.
	Updated string `json:"updated,omitempty"`

	// VersionTermsOfService The version of the terms of service accepted by the user.
	VersionTermsOfService string `json:"version_terms_of_service,omitempty"`
}

// UserCompanyNameListing defines model for UserCompanyNameListing.
type UserCompanyNameListing struct {
	// NameArray All known (trade) names for a user company.
	NameArray []string `json:"name_array,omitempty"`
}

// UserCompanyRead defines model for UserCompanyRead.
type UserCompanyRead struct {
	AddressMain   *Address `json:"address_main,omitempty"`
	AddressPostal *Address `json:"address_postal,omitempty"`

	// Alias The aliases of the account.
	Alias  []Pointer `json:"alias,omitempty"`
	Avatar *Avatar    `json:"avatar,omitempty"`

	// BillingContract The subscription of the company.
	BillingContract []BillingContractSubscription `json:"billing_contract,omitempty"`

	// ChamberOfCommerceNumber The company's chamber of commerce number.
	ChamberOfCommerceNumber string `json:"chamber_of_commerce_number,omitempty"`

	// CounterBankIban The company's other bank account IBAN, through which we verify it.
	CounterBankIban string `json:"counter_bank_iban,omitempty"`

	// Country The country as an ISO 3166-1 alpha-2 country code.
	Country string `json:"country,omitempty"`

	// Created The timestamp of the company object's creation.
	Created                            string        `json:"created,omitempty"`
	Customer                           *Customer      `json:"customer,omitempty"`
	CustomerLimit                      *CustomerLimit `json:"customer_limit,omitempty"`
	DailyLimitWithoutConfirmationLogin Amount        `json:"daily_limit_without_confirmation_login,omitempty"`

	// DenyReason The user deny reason.
	DenyReason string `json:"deny_reason,omitempty"`

	// Directors The existing bunq aliases for the company's directors.
	Directors []LabelUser `json:"directors,omitempty"`

	// DisplayName The company's display name.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the modified company.
	Id int `json:"id,omitempty"`

	// Language The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Language string `json:"language,omitempty"`

	// LegalForm The company's legal form.
	LegalForm string `json:"legal_form,omitempty"`

	// Name The company name.
	Name string `json:"name,omitempty"`

	// NotificationFilters The types of notifications that will result in a push notification or URL callback for this UserCompany.
	NotificationFilters []NotificationFilter `json:"notification_filters,omitempty"`

	// PublicNickName The company's public nick name.
	PublicNickName string `json:"public_nick_name,omitempty"`

	// PublicUuid The company's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Region The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Region string `json:"region,omitempty"`

	// Relations The relations for this user.
	Relations []RelationUser `json:"relations,omitempty"`

	// SectorOfIndustry The sector of industry.
	SectorOfIndustry string `json:"sector_of_industry,omitempty"`

	// SessionTimeout The setting for the session timeout of the company in seconds.
	SessionTimeout int `json:"session_timeout,omitempty"`

	// Status The user status. Can be: ACTIVE, SIGNUP, RECOVERY.
	Status string `json:"status,omitempty"`

	// SubStatus The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.
	SubStatus string `json:"sub_status,omitempty"`

	// TaxResident The user's tax residence numbers for different countries.
	TaxResident []TaxResident `json:"tax_resident,omitempty"`

	// TypeOfBusinessEntity The type of business entity.
	TypeOfBusinessEntity string `json:"type_of_business_entity,omitempty"`

	// Ubo The names of the company's ultimate beneficiary owners. Minimum zero, maximum four.
	Ubo []Ubo `json:"ubo,omitempty"`

	// Updated The timestamp of the company object's last update.
	Updated string `json:"updated,omitempty"`

	// VersionTermsOfService The version of the terms of service accepted by the user.
	VersionTermsOfService string `json:"version_terms_of_service,omitempty"`
}

// UserCompanyUpdate defines model for UserCompanyUpdate.
type UserCompanyUpdate struct {
	// Id The id of the modified company.
	Id int `json:"id,omitempty"`
}

// UserCredentialPasswordIpListing defines model for UserCredentialPasswordIpListing.
type UserCredentialPasswordIpListing struct {
	// Created The timestamp of the credential object's creation.
	Created string `json:"created,omitempty"`

	// ExpiryTime When the status is PENDING_FIRST_USE: when the credential expires.
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Id The id of the credential.
	Id              int             `json:"id,omitempty"`
	PermittedDevice *PermittedDevice `json:"permitted_device,omitempty"`

	// Status The status of the credential.
	Status string `json:"status,omitempty"`

	// TokenValue When the status is PENDING_FIRST_USE: the value of the token.
	TokenValue string `json:"token_value,omitempty"`

	// Updated The timestamp of the credential object's last update.
	Updated string `json:"updated,omitempty"`
}

// UserCredentialPasswordIpRead defines model for UserCredentialPasswordIpRead.
type UserCredentialPasswordIpRead struct {
	// Created The timestamp of the credential object's creation.
	Created string `json:"created,omitempty"`

	// ExpiryTime When the status is PENDING_FIRST_USE: when the credential expires.
	ExpiryTime string `json:"expiry_time,omitempty"`

	// Id The id of the credential.
	Id              int             `json:"id,omitempty"`
	PermittedDevice *PermittedDevice `json:"permitted_device,omitempty"`

	// Status The status of the credential.
	Status string `json:"status,omitempty"`

	// TokenValue When the status is PENDING_FIRST_USE: the value of the token.
	TokenValue string `json:"token_value,omitempty"`

	// Updated The timestamp of the credential object's last update.
	Updated string `json:"updated,omitempty"`
}

// UserLegalNameListing defines model for UserLegalNameListing.
type UserLegalNameListing struct {
	// LegalNames All legal names that can be used by the user
	LegalNames []string `json:"legal_names,omitempty"`
}

// UserListing defines model for UserListing.
type UserListing struct {
	UserApiKey                 *UserApiKey                 `json:"UserApiKey,omitempty"`
	UserCompany                *UserCompany                `json:"UserCompany,omitempty"`
	UserPaymentServiceProvider *UserPaymentServiceProvider `json:"UserPaymentServiceProvider,omitempty"`
	UserPerson                 *UserPerson                 `json:"UserPerson,omitempty"`
}

// UserPaymentServiceProvider defines model for UserPaymentServiceProvider.
type UserPaymentServiceProvider struct {
	// Alias The aliases of the user.
	Alias  []Pointer `json:"alias,omitempty"`
	Avatar *Avatar    `json:"avatar,omitempty"`

	// CertificateDistinguishedName The distinguished name from the certificate used to identify this user.
	CertificateDistinguishedName string `json:"certificate_distinguished_name,omitempty"`

	// Created The timestamp of the user object's creation.
	Created string `json:"created,omitempty"`

	// DisplayName The display name for the provider.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the user.
	Id int `json:"id,omitempty"`

	// Language The provider's language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	Language string `json:"language,omitempty"`

	// PublicNickName The public nick name for the provider.
	PublicNickName string `json:"public_nick_name,omitempty"`

	// PublicUuid The providers's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Region The provider's region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	Region string `json:"region,omitempty"`

	// SessionTimeout The setting for the session timeout of the user in seconds.
	SessionTimeout int `json:"session_timeout,omitempty"`

	// Status The user status. The user status. Can be: ACTIVE, BLOCKED or DENIED.
	Status string `json:"status,omitempty"`

	// SubStatus The user sub-status. Can be: NONE
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the user object's last update.
	Updated string `json:"updated,omitempty"`
}

// UserPaymentServiceProviderRead defines model for UserPaymentServiceProviderRead.
type UserPaymentServiceProviderRead struct {
	// Alias The aliases of the user.
	Alias  []Pointer `json:"alias,omitempty"`
	Avatar *Avatar    `json:"avatar,omitempty"`

	// CertificateDistinguishedName The distinguished name from the certificate used to identify this user.
	CertificateDistinguishedName string `json:"certificate_distinguished_name,omitempty"`

	// Created The timestamp of the user object's creation.
	Created string `json:"created,omitempty"`

	// DisplayName The display name for the provider.
	DisplayName string `json:"display_name,omitempty"`

	// Id The id of the user.
	Id int `json:"id,omitempty"`

	// Language The provider's language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	Language string `json:"language,omitempty"`

	// PublicNickName The public nick name for the provider.
	PublicNickName string `json:"public_nick_name,omitempty"`

	// PublicUuid The providers's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Region The provider's region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	Region string `json:"region,omitempty"`

	// SessionTimeout The setting for the session timeout of the user in seconds.
	SessionTimeout int `json:"session_timeout,omitempty"`

	// Status The user status. The user status. Can be: ACTIVE, BLOCKED or DENIED.
	Status string `json:"status,omitempty"`

	// SubStatus The user sub-status. Can be: NONE
	SubStatus string `json:"sub_status,omitempty"`

	// Updated The timestamp of the user object's last update.
	Updated string `json:"updated,omitempty"`
}

// UserPerson defines model for UserPerson.
type UserPerson struct {
	AddressMain   *Address `json:"address_main,omitempty"`
	AddressPostal *Address `json:"address_postal,omitempty"`

	// Alias The aliases of the user.
	Alias []Pointer `json:"alias,omitempty"`

	// AllNationality All of the person's nationalities.
	AllNationality []string `json:"all_nationality,omitempty"`
	Avatar         *Avatar   `json:"avatar,omitempty"`

	// AvatarUuid The public UUID of the user's avatar.
	AvatarUuid string `json:"avatar_uuid,omitempty"`

	// CountryOfBirth The person's country of birth. Formatted as a SO 3166-1 alpha-2 country code.
	CountryOfBirth string `json:"country_of_birth,omitempty"`

	// Created The timestamp of the person object's creation.
	Created                            string `json:"created,omitempty"`
	DailyLimitWithoutConfirmationLogin Amount `json:"daily_limit_without_confirmation_login,omitempty"`

	// DateOfBirth The person's date of birth. Accepts ISO8601 date formats.
	DateOfBirth string `json:"date_of_birth,omitempty"`

	// DisplayName The display name for the person.
	DisplayName string `json:"display_name,omitempty"`

	// DocumentBackAttachmentId The reference to the uploaded picture/scan of the back side of the identification document.
	DocumentBackAttachmentId int `json:"document_back_attachment_id,omitempty"`

	// DocumentCountryOfIssuance The country which issued the identification document the person registered with.
	DocumentCountryOfIssuance string `json:"document_country_of_issuance,omitempty"`

	// DocumentFrontAttachmentId The reference to the uploaded picture/scan of the front side of the identification document.
	DocumentFrontAttachmentId int `json:"document_front_attachment_id,omitempty"`

	// DocumentNumber The identification document number the person registered with.
	DocumentNumber string `json:"document_number,omitempty"`

	// DocumentType The type of identification document the person registered with.
	DocumentType string `json:"document_type,omitempty"`

	// FirstName The person's first name.
	FirstName string `json:"first_name,omitempty"`

	// Gender The person's gender. Can be MALE, FEMALE or UNKNOWN.
	Gender string `json:"gender,omitempty"`

	// Id The id of the modified person object.
	Id int `json:"id,omitempty"`

	// Language The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Language string `json:"language,omitempty"`

	// LastName The person's last name.
	LastName           string  `json:"last_name,omitempty"`
	LegalGuardianAlias *Pointer `json:"legal_guardian_alias,omitempty"`

	// LegalName The person's legal name.
	LegalName string `json:"legal_name,omitempty"`

	// MiddleName The person's middle name.
	MiddleName string `json:"middle_name,omitempty"`

	// Nationality The person's nationality. Formatted as a SO 3166-1 alpha-2 country code.
	Nationality string `json:"nationality,omitempty"`

	// NotificationFilters The types of notifications that will result in a push notification or URL callback for this UserPerson.
	NotificationFilters []NotificationFilter `json:"notification_filters,omitempty"`

	// PlaceOfBirth The person's place of birth.
	PlaceOfBirth string `json:"place_of_birth,omitempty"`

	// PublicNickName The public nick name for the person.
	PublicNickName string `json:"public_nick_name,omitempty"`

	// PublicUuid The person's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Region The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Region string `json:"region,omitempty"`

	// Relations The relations for this user.
	Relations []RelationUser `json:"relations,omitempty"`

	// SessionTimeout The setting for the session timeout of the user in seconds.
	SessionTimeout int `json:"session_timeout,omitempty"`

	// SignupTrackType The type of signup track the user is following.
	SignupTrackType string `json:"signup_track_type,omitempty"`

	// Status The user status. The user status. Can be: ACTIVE, BLOCKED, SIGNUP, RECOVERY, DENIED or ABORTED.
	Status string `json:"status,omitempty"`

	// SubStatus The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.
	SubStatus string `json:"sub_status,omitempty"`

	// SubscriptionType The subscription type the user should start on.
	SubscriptionType string `json:"subscription_type,omitempty"`

	// TaxResident The user's tax residence numbers for different countries.
	TaxResident []TaxResident `json:"tax_resident,omitempty"`

	// Updated The timestamp of the person object's last update.
	Updated string `json:"updated,omitempty"`

	// VersionTermsOfService The version of the terms of service accepted by the user.
	VersionTermsOfService string `json:"version_terms_of_service,omitempty"`
}

// UserPersonRead defines model for UserPersonRead.
type UserPersonRead struct {
	AddressMain   *Address `json:"address_main,omitempty"`
	AddressPostal *Address `json:"address_postal,omitempty"`

	// Alias The aliases of the user.
	Alias []Pointer `json:"alias,omitempty"`

	// AllNationality All of the person's nationalities.
	AllNationality []string `json:"all_nationality,omitempty"`
	Avatar         *Avatar   `json:"avatar,omitempty"`

	// CountryOfBirth The person's country of birth. Formatted as a SO 3166-1 alpha-2 country code.
	CountryOfBirth string `json:"country_of_birth,omitempty"`

	// Created The timestamp of the person object's creation.
	Created                            string `json:"created,omitempty"`
	DailyLimitWithoutConfirmationLogin Amount `json:"daily_limit_without_confirmation_login,omitempty"`

	// DateOfBirth The person's date of birth. Accepts ISO8601 date formats.
	DateOfBirth string `json:"date_of_birth,omitempty"`

	// DisplayName The display name for the person.
	DisplayName string `json:"display_name,omitempty"`

	// FirstName The person's first name.
	FirstName string `json:"first_name,omitempty"`

	// Gender The person's gender. Can be MALE, FEMALE or UNKNOWN.
	Gender string `json:"gender,omitempty"`

	// Id The id of the modified person object.
	Id int `json:"id,omitempty"`

	// Language The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Language string `json:"language,omitempty"`

	// LastName The person's last name.
	LastName string `json:"last_name,omitempty"`

	// LegalName The person's legal name.
	LegalName string `json:"legal_name,omitempty"`

	// MiddleName The person's middle name.
	MiddleName string `json:"middle_name,omitempty"`

	// Nationality The person's nationality. Formatted as a SO 3166-1 alpha-2 country code.
	Nationality string `json:"nationality,omitempty"`

	// NotificationFilters The types of notifications that will result in a push notification or URL callback for this UserPerson.
	NotificationFilters []NotificationFilter `json:"notification_filters,omitempty"`

	// PlaceOfBirth The person's place of birth.
	PlaceOfBirth string `json:"place_of_birth,omitempty"`

	// PublicNickName The public nick name for the person.
	PublicNickName string `json:"public_nick_name,omitempty"`

	// PublicUuid The person's public UUID.
	PublicUuid string `json:"public_uuid,omitempty"`

	// Region The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.
	Region string `json:"region,omitempty"`

	// Relations The relations for this user.
	Relations []RelationUser `json:"relations,omitempty"`

	// SessionTimeout The setting for the session timeout of the user in seconds.
	SessionTimeout int `json:"session_timeout,omitempty"`

	// Status The user status. The user status. Can be: ACTIVE, BLOCKED, SIGNUP, RECOVERY, DENIED or ABORTED.
	Status string `json:"status,omitempty"`

	// SubStatus The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.
	SubStatus string `json:"sub_status,omitempty"`

	// TaxResident The user's tax residence numbers for different countries.
	TaxResident []TaxResident `json:"tax_resident,omitempty"`

	// Updated The timestamp of the person object's last update.
	Updated string `json:"updated,omitempty"`

	// VersionTermsOfService The version of the terms of service accepted by the user.
	VersionTermsOfService string `json:"version_terms_of_service,omitempty"`
}

// UserPersonUpdate defines model for UserPersonUpdate.
type UserPersonUpdate struct {
	// Id The id of the modified person object.
	Id int `json:"id,omitempty"`
}

// UserRead defines model for UserRead.
type UserRead struct {
	UserApiKey                 *UserApiKey                 `json:"UserApiKey,omitempty"`
	UserCompany                *UserCompany                `json:"UserCompany,omitempty"`
	UserPaymentServiceProvider *UserPaymentServiceProvider `json:"UserPaymentServiceProvider,omitempty"`
	UserPerson                 *UserPerson                 `json:"UserPerson,omitempty"`
}

// Whitelist defines model for Whitelist.
type Whitelist = map[string]interface{}

// WhitelistResult defines model for WhitelistResult.
type WhitelistResult struct {
	// ErrorMessage The message when the whitelist result has failed due to user error.
	ErrorMessage []Error `json:"error_message,omitempty"`

	// Id The ID of the whitelist entry.
	Id int `json:"id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int                               `json:"monetary_account_paying_id,omitempty"`
	Object                  *WhitelistResultViewAnchoredObject `json:"object,omitempty"`

	// RequestReferenceSplitTheBill The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch
	RequestReferenceSplitTheBill []RequestInquiryReference `json:"request_reference_split_the_bill,omitempty"`

	// Status The status of the WhitelistResult.
	Status string `json:"status,omitempty"`

	// SubStatus The subStatus of the WhitelistResult.
	SubStatus string    `json:"sub_status,omitempty"`
	Whitelist *Whitelist `json:"whitelist,omitempty"`
}

// WhitelistResultViewAnchoredObject defines model for WhitelistResultViewAnchoredObject.
type WhitelistResultViewAnchoredObject struct {
	DraftPayment *DraftPayment `json:"draftPayment,omitempty"`

	// Id The ID of the whitelist entry.
	Id              int             `json:"id,omitempty"`
	RequestResponse *RequestResponse `json:"requestResponse,omitempty"`
}

// WhitelistSddListing defines model for WhitelistSddListing.
type WhitelistSddListing struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate ID provided by the counterparty.
	MandateIdentifier     string `json:"mandate_identifier,omitempty"`
	MaximumAmountPerMonth Amount `json:"maximum_amount_per_month,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddMonetaryAccountPayingListing defines model for WhitelistSddMonetaryAccountPayingListing.
type WhitelistSddMonetaryAccountPayingListing struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate ID provided by the counterparty.
	MandateIdentifier     string `json:"mandate_identifier,omitempty"`
	MaximumAmountPerMonth Amount `json:"maximum_amount_per_month,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddMonetaryAccountPayingRead defines model for WhitelistSddMonetaryAccountPayingRead.
type WhitelistSddMonetaryAccountPayingRead struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate ID provided by the counterparty.
	MandateIdentifier     string `json:"mandate_identifier,omitempty"`
	MaximumAmountPerMonth Amount `json:"maximum_amount_per_month,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddOneOff defines model for WhitelistSddOneOff.
type WhitelistSddOneOff struct {
	MaximumAmountPerMonth   Amount `json:"maximum_amount_per_month,omitempty"`
	MaximumAmountPerPayment Amount `json:"maximum_amount_per_payment,omitempty"`

	// MonetaryAccountPayingId ID of the monetary account of which you want to pay from.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id"`

	// RequestId ID of the request for which you want to whitelist the originating SDD.
	RequestId int `json:"request_id,omitempty"`

	// RoutingType The type of routing for this whitelist. Should be changed to non-optional CIT/technical#12806.
	RoutingType string `json:"routing_type,omitempty"`
}

// WhitelistSddOneOffCreate defines model for WhitelistSddOneOffCreate.
type WhitelistSddOneOffCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// WhitelistSddOneOffDelete defines model for WhitelistSddOneOffDelete.
type WhitelistSddOneOffDelete = map[string]interface{}

// WhitelistSddOneOffListing defines model for WhitelistSddOneOffListing.
type WhitelistSddOneOffListing struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id                      int    `json:"id,omitempty"`
	MaximumAmountPerMonth   Amount `json:"maximum_amount_per_month,omitempty"`
	MaximumAmountPerPayment Amount `json:"maximum_amount_per_payment,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// RoutingType The type of routing for this whitelist.
	RoutingType string `json:"routing_type,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddOneOffRead defines model for WhitelistSddOneOffRead.
type WhitelistSddOneOffRead struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id                      int    `json:"id,omitempty"`
	MaximumAmountPerMonth   Amount `json:"maximum_amount_per_month,omitempty"`
	MaximumAmountPerPayment Amount `json:"maximum_amount_per_payment,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// RoutingType The type of routing for this whitelist.
	RoutingType string `json:"routing_type,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddOneOffUpdate defines model for WhitelistSddOneOffUpdate.
type WhitelistSddOneOffUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// WhitelistSddRead defines model for WhitelistSddRead.
type WhitelistSddRead struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate ID provided by the counterparty.
	MandateIdentifier     string `json:"mandate_identifier,omitempty"`
	MaximumAmountPerMonth Amount `json:"maximum_amount_per_month,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddRecurring defines model for WhitelistSddRecurring.
type WhitelistSddRecurring struct {
	MaximumAmountPerMonth   Amount `json:"maximum_amount_per_month,omitempty"`
	MaximumAmountPerPayment Amount `json:"maximum_amount_per_payment,omitempty"`

	// MonetaryAccountPayingId ID of the monetary account of which you want to pay from.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id"`

	// RequestId ID of the request for which you want to whitelist the originating SDD.
	RequestId int `json:"request_id,omitempty"`

	// RoutingType The type of routing for this whitelist. Should be changed to non-optional CIT/technical#12806.
	RoutingType string `json:"routing_type,omitempty"`
}

// WhitelistSddRecurringCreate defines model for WhitelistSddRecurringCreate.
type WhitelistSddRecurringCreate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// WhitelistSddRecurringDelete defines model for WhitelistSddRecurringDelete.
type WhitelistSddRecurringDelete = map[string]interface{}

// WhitelistSddRecurringListing defines model for WhitelistSddRecurringListing.
type WhitelistSddRecurringListing struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate ID provided by the counterparty.
	MandateIdentifier       string `json:"mandate_identifier,omitempty"`
	MaximumAmountPerMonth   Amount `json:"maximum_amount_per_month,omitempty"`
	MaximumAmountPerPayment Amount `json:"maximum_amount_per_payment,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// RoutingType The type of routing for this whitelist.
	RoutingType string `json:"routing_type,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddRecurringRead defines model for WhitelistSddRecurringRead.
type WhitelistSddRecurringRead struct {
	CounterpartyAlias *LabelMonetaryAccount `json:"counterparty_alias,omitempty"`

	// CreditSchemeIdentifier The credit scheme ID provided by the counterparty.
	CreditSchemeIdentifier string `json:"credit_scheme_identifier,omitempty"`

	// Id The ID of the whitelist entry.
	Id int `json:"id,omitempty"`

	// MandateIdentifier The mandate ID provided by the counterparty.
	MandateIdentifier       string `json:"mandate_identifier,omitempty"`
	MaximumAmountPerMonth   Amount `json:"maximum_amount_per_month,omitempty"`
	MaximumAmountPerPayment Amount `json:"maximum_amount_per_payment,omitempty"`

	// MonetaryAccountIncomingId The account to which payments will come in before possibly being 'redirected' by the whitelist.
	MonetaryAccountIncomingId int `json:"monetary_account_incoming_id,omitempty"`

	// MonetaryAccountPayingId The account from which payments will be deducted when a transaction is matched with this whitelist.
	MonetaryAccountPayingId int `json:"monetary_account_paying_id,omitempty"`

	// RoutingType The type of routing for this whitelist.
	RoutingType string `json:"routing_type,omitempty"`

	// Status The status of the whitelist.
	Status string `json:"status,omitempty"`

	// Type The type of the SDD whitelist, can be CORE or B2B.
	Type             string    `json:"type,omitempty"`
	UserAliasCreated *LabelUser `json:"user_alias_created,omitempty"`
}

// WhitelistSddRecurringUpdate defines model for WhitelistSddRecurringUpdate.
type WhitelistSddRecurringUpdate struct {
	Id *BunqId `json:"Id,omitempty"`
}

// CacheControl defines model for Cache-Control.
type CacheControl = string

// UserAgent defines model for User-Agent.
type UserAgent = string

// XBunqClientAuthentication defines model for X-Bunq-Client-Authentication.
type XBunqClientAuthentication = string

// XBunqClientRequestId defines model for X-Bunq-Client-Request-Id.
type XBunqClientRequestId = string

// XBunqGeolocation defines model for X-Bunq-Geolocation.
type XBunqGeolocation = string

// XBunqLanguage defines model for X-Bunq-Language.
type XBunqLanguage = string

// XBunqRegion defines model for X-Bunq-Region.
type XBunqRegion = string

// GenericError defines model for GenericError.
type GenericError struct {
	Error *Error `json:"Error,omitempty"`
}

// CREATEAttachmentPublicParams defines parameters for CREATEAttachmentPublic.
type CREATEAttachmentPublicParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForAttachmentPublicParams defines parameters for ListAllContentForAttachmentPublic.
type ListAllContentForAttachmentPublicParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READAttachmentPublicParams defines parameters for READAttachmentPublic.
type READAttachmentPublicParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEAvatarParams defines parameters for CREATEAvatar.
type CREATEAvatarParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READAvatarParams defines parameters for READAvatar.
type READAvatarParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllDeviceParams defines parameters for ListAllDevice.
type ListAllDeviceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllDeviceServerParams defines parameters for ListAllDeviceServer.
type ListAllDeviceServerParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEDeviceServerParams defines parameters for CREATEDeviceServer.
type CREATEDeviceServerParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READDeviceServerParams defines parameters for READDeviceServer.
type READDeviceServerParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READDeviceParams defines parameters for READDevice.
type READDeviceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllInstallationParams defines parameters for ListAllInstallation.
type ListAllInstallationParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEInstallationParams defines parameters for CREATEInstallation.
type CREATEInstallationParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllServerPublicKeyForInstallationParams defines parameters for ListAllServerPublicKeyForInstallation.
type ListAllServerPublicKeyForInstallationParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READInstallationParams defines parameters for READInstallation.
type READInstallationParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEPaymentServiceProviderCredentialParams defines parameters for CREATEPaymentServiceProviderCredential.
type CREATEPaymentServiceProviderCredentialParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READPaymentServiceProviderCredentialParams defines parameters for READPaymentServiceProviderCredential.
type READPaymentServiceProviderCredentialParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATESandboxUserCompanyParams defines parameters for CREATESandboxUserCompany.
type CREATESandboxUserCompanyParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATESandboxUserPersonParams defines parameters for CREATESandboxUserPerson.
type CREATESandboxUserPersonParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEServerErrorParams defines parameters for CREATEServerError.
type CREATEServerErrorParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATESessionServerParams defines parameters for CREATESessionServer.
type CREATESessionServerParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETESessionParams defines parameters for DELETESession.
type DELETESessionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllUserParams defines parameters for ListAllUser.
type ListAllUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READUserCompanyParams defines parameters for READUserCompany.
type READUserCompanyParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEUserCompanyParams defines parameters for UPDATEUserCompany.
type UPDATEUserCompanyParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNameForUserCompanyParams defines parameters for ListAllNameForUserCompany.
type ListAllNameForUserCompanyParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READUserPaymentServiceProviderParams defines parameters for READUserPaymentServiceProvider.
type READUserPaymentServiceProviderParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READUserPersonParams defines parameters for READUserPerson.
type READUserPersonParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEUserPersonParams defines parameters for UPDATEUserPerson.
type UPDATEUserPersonParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READUserParams defines parameters for READUser.
type READUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllAdditionalTransactionInformationCategoryForUserParams defines parameters for ListAllAdditionalTransactionInformationCategoryForUser.
type ListAllAdditionalTransactionInformationCategoryForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEAdditionalTransactionInformationCategoryUserDefinedForUserParams defines parameters for CREATEAdditionalTransactionInformationCategoryUserDefinedForUser.
type CREATEAdditionalTransactionInformationCategoryUserDefinedForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserAttachmentParams defines parameters for ListAllContentForUserAttachment.
type ListAllContentForUserAttachmentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READAttachmentForUserParams defines parameters for READAttachmentForUser.
type READAttachmentForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllBillingContractSubscriptionForUserParams defines parameters for ListAllBillingContractSubscriptionForUser.
type ListAllBillingContractSubscriptionForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllBunqmeFundraiserProfileForUserParams defines parameters for ListAllBunqmeFundraiserProfileForUser.
type ListAllBunqmeFundraiserProfileForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READBunqmeFundraiserProfileForUserParams defines parameters for READBunqmeFundraiserProfileForUser.
type READBunqmeFundraiserProfileForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCardForUserParams defines parameters for ListAllCardForUser.
type ListAllCardForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECardBatchForUserParams defines parameters for CREATECardBatchForUser.
type CREATECardBatchForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECardBatchReplaceForUserParams defines parameters for CREATECardBatchReplaceForUser.
type CREATECardBatchReplaceForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECardCreditForUserParams defines parameters for CREATECardCreditForUser.
type CREATECardCreditForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECardDebitForUserParams defines parameters for CREATECardDebitForUser.
type CREATECardDebitForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCardNameForUserParams defines parameters for ListAllCardNameForUser.
type ListAllCardNameForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllExportStatementCardForUserCardParams defines parameters for ListAllExportStatementCardForUserCard.
type ListAllExportStatementCardForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllExportStatementCardCsvForUserCardParams defines parameters for ListAllExportStatementCardCsvForUserCard.
type ListAllExportStatementCardCsvForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEExportStatementCardCsvForUserCardParams defines parameters for CREATEExportStatementCardCsvForUserCard.
type CREATEExportStatementCardCsvForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEExportStatementCardCsvForUserCardParams defines parameters for DELETEExportStatementCardCsvForUserCard.
type DELETEExportStatementCardCsvForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READExportStatementCardCsvForUserCardParams defines parameters for READExportStatementCardCsvForUserCard.
type READExportStatementCardCsvForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllExportStatementCardPdfForUserCardParams defines parameters for ListAllExportStatementCardPdfForUserCard.
type ListAllExportStatementCardPdfForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEExportStatementCardPdfForUserCardParams defines parameters for CREATEExportStatementCardPdfForUserCard.
type CREATEExportStatementCardPdfForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEExportStatementCardPdfForUserCardParams defines parameters for DELETEExportStatementCardPdfForUserCard.
type DELETEExportStatementCardPdfForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READExportStatementCardPdfForUserCardParams defines parameters for READExportStatementCardPdfForUserCard.
type READExportStatementCardPdfForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserCardExportStatementCardParams defines parameters for ListAllContentForUserCardExportStatementCard.
type ListAllContentForUserCardExportStatementCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READExportStatementCardForUserCardParams defines parameters for READExportStatementCardForUserCard.
type READExportStatementCardForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllGeneratedCvc2ForUserCardParams defines parameters for ListAllGeneratedCvc2ForUserCard.
type ListAllGeneratedCvc2ForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEGeneratedCvc2ForUserCardParams defines parameters for CREATEGeneratedCvc2ForUserCard.
type CREATEGeneratedCvc2ForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READGeneratedCvc2ForUserCardParams defines parameters for READGeneratedCvc2ForUserCard.
type READGeneratedCvc2ForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEGeneratedCvc2ForUserCardParams defines parameters for UPDATEGeneratedCvc2ForUserCard.
type UPDATEGeneratedCvc2ForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEReplaceForUserCardParams defines parameters for CREATEReplaceForUserCard.
type CREATEReplaceForUserCardParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCardForUserParams defines parameters for READCardForUser.
type READCardForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATECardForUserParams defines parameters for UPDATECardForUser.
type UPDATECardForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCertificatePinnedForUserParams defines parameters for ListAllCertificatePinnedForUser.
type ListAllCertificatePinnedForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECertificatePinnedForUserParams defines parameters for CREATECertificatePinnedForUser.
type CREATECertificatePinnedForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETECertificatePinnedForUserParams defines parameters for DELETECertificatePinnedForUser.
type DELETECertificatePinnedForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCertificatePinnedForUserParams defines parameters for READCertificatePinnedForUser.
type READCertificatePinnedForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READChallengeRequestForUserParams defines parameters for READChallengeRequestForUser.
type READChallengeRequestForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEChallengeRequestForUserParams defines parameters for UPDATEChallengeRequestForUser.
type UPDATEChallengeRequestForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserChatConversationAttachmentParams defines parameters for ListAllContentForUserChatConversationAttachment.
type ListAllContentForUserChatConversationAttachmentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCompanyForUserParams defines parameters for ListAllCompanyForUser.
type ListAllCompanyForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECompanyForUserParams defines parameters for CREATECompanyForUser.
type CREATECompanyForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCompanyForUserParams defines parameters for READCompanyForUser.
type READCompanyForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATECompanyForUserParams defines parameters for UPDATECompanyForUser.
type UPDATECompanyForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEConfirmationOfFundsForUserParams defines parameters for CREATEConfirmationOfFundsForUser.
type CREATEConfirmationOfFundsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCredentialPasswordIpForUserParams defines parameters for ListAllCredentialPasswordIpForUser.
type ListAllCredentialPasswordIpForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllIpForUserCredentialPasswordIpParams defines parameters for ListAllIpForUserCredentialPasswordIp.
type ListAllIpForUserCredentialPasswordIpParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEIpForUserCredentialPasswordIpParams defines parameters for CREATEIpForUserCredentialPasswordIp.
type CREATEIpForUserCredentialPasswordIpParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READIpForUserCredentialPasswordIpParams defines parameters for READIpForUserCredentialPasswordIp.
type READIpForUserCredentialPasswordIpParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEIpForUserCredentialPasswordIpParams defines parameters for UPDATEIpForUserCredentialPasswordIp.
type UPDATEIpForUserCredentialPasswordIpParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCredentialPasswordIpForUserParams defines parameters for READCredentialPasswordIpForUser.
type READCredentialPasswordIpForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCurrencyCloudBeneficiaryForUserParams defines parameters for ListAllCurrencyCloudBeneficiaryForUser.
type ListAllCurrencyCloudBeneficiaryForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECurrencyCloudBeneficiaryForUserParams defines parameters for CREATECurrencyCloudBeneficiaryForUser.
type CREATECurrencyCloudBeneficiaryForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCurrencyCloudBeneficiaryRequirementForUserParams defines parameters for ListAllCurrencyCloudBeneficiaryRequirementForUser.
type ListAllCurrencyCloudBeneficiaryRequirementForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCurrencyCloudBeneficiaryForUserParams defines parameters for READCurrencyCloudBeneficiaryForUser.
type READCurrencyCloudBeneficiaryForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllEventForUserParams defines parameters for ListAllEventForUser.
type ListAllEventForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READEventForUserParams defines parameters for READEventForUser.
type READEventForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllExportAnnualOverviewForUserParams defines parameters for ListAllExportAnnualOverviewForUser.
type ListAllExportAnnualOverviewForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEExportAnnualOverviewForUserParams defines parameters for CREATEExportAnnualOverviewForUser.
type CREATEExportAnnualOverviewForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserExportAnnualOverviewParams defines parameters for ListAllContentForUserExportAnnualOverview.
type ListAllContentForUserExportAnnualOverviewParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEExportAnnualOverviewForUserParams defines parameters for DELETEExportAnnualOverviewForUser.
type DELETEExportAnnualOverviewForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READExportAnnualOverviewForUserParams defines parameters for READExportAnnualOverviewForUser.
type READExportAnnualOverviewForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READFeatureAnnouncementForUserParams defines parameters for READFeatureAnnouncementForUser.
type READFeatureAnnouncementForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllInsightPreferenceDateForUserParams defines parameters for ListAllInsightPreferenceDateForUser.
type ListAllInsightPreferenceDateForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllInsightsForUserParams defines parameters for ListAllInsightsForUser.
type ListAllInsightsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllInsightsSearchForUserParams defines parameters for ListAllInsightsSearchForUser.
type ListAllInsightsSearchForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllInvoiceForUserParams defines parameters for ListAllInvoiceForUser.
type ListAllInvoiceForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEInvoiceExportForUserInvoiceParams defines parameters for CREATEInvoiceExportForUserInvoice.
type CREATEInvoiceExportForUserInvoiceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEInvoiceExportForUserInvoiceParams defines parameters for DELETEInvoiceExportForUserInvoice.
type DELETEInvoiceExportForUserInvoiceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READInvoiceExportForUserInvoiceParams defines parameters for READInvoiceExportForUserInvoice.
type READInvoiceExportForUserInvoiceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEInvoiceExportForUserInvoiceParams defines parameters for UPDATEInvoiceExportForUserInvoice.
type UPDATEInvoiceExportForUserInvoiceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPdfContentForUserInvoiceParams defines parameters for ListAllPdfContentForUserInvoice.
type ListAllPdfContentForUserInvoiceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READInvoiceForUserParams defines parameters for READInvoiceForUser.
type READInvoiceForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllLegalNameForUserParams defines parameters for ListAllLegalNameForUser.
type ListAllLegalNameForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllLimitForUserParams defines parameters for ListAllLimitForUser.
type ListAllLimitForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMonetaryAccountForUserParams defines parameters for ListAllMonetaryAccountForUser.
type ListAllMonetaryAccountForUserParams struct {
	// Count Amount of things to return
	Count int `form:"count,omitempty" json:"count,omitempty"`

	// NewerId Starting id for this page
	NewerId int `form:"newer_id,omitempty" json:"newer_id,omitempty"`

	// OlderId Ending id for this page
	OlderId int `form:"older_id,omitempty" json:"older_id,omitempty"`

	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMonetaryAccountBankForUserParams defines parameters for ListAllMonetaryAccountBankForUser.
type ListAllMonetaryAccountBankForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEMonetaryAccountBankForUserParams defines parameters for CREATEMonetaryAccountBankForUser.
type CREATEMonetaryAccountBankForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMonetaryAccountBankForUserParams defines parameters for READMonetaryAccountBankForUser.
type READMonetaryAccountBankForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEMonetaryAccountBankForUserParams defines parameters for UPDATEMonetaryAccountBankForUser.
type UPDATEMonetaryAccountBankForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMonetaryAccountCardForUserParams defines parameters for ListAllMonetaryAccountCardForUser.
type ListAllMonetaryAccountCardForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMonetaryAccountCardForUserParams defines parameters for READMonetaryAccountCardForUser.
type READMonetaryAccountCardForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEMonetaryAccountCardForUserParams defines parameters for UPDATEMonetaryAccountCardForUser.
type UPDATEMonetaryAccountCardForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMonetaryAccountExternalForUserParams defines parameters for ListAllMonetaryAccountExternalForUser.
type ListAllMonetaryAccountExternalForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEMonetaryAccountExternalForUserParams defines parameters for CREATEMonetaryAccountExternalForUser.
type CREATEMonetaryAccountExternalForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMonetaryAccountExternalSavingsForUserParams defines parameters for ListAllMonetaryAccountExternalSavingsForUser.
type ListAllMonetaryAccountExternalSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEMonetaryAccountExternalSavingsForUserParams defines parameters for CREATEMonetaryAccountExternalSavingsForUser.
type CREATEMonetaryAccountExternalSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMonetaryAccountExternalSavingsForUserParams defines parameters for READMonetaryAccountExternalSavingsForUser.
type READMonetaryAccountExternalSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEMonetaryAccountExternalSavingsForUserParams defines parameters for UPDATEMonetaryAccountExternalSavingsForUser.
type UPDATEMonetaryAccountExternalSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMonetaryAccountExternalForUserParams defines parameters for READMonetaryAccountExternalForUser.
type READMonetaryAccountExternalForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEMonetaryAccountExternalForUserParams defines parameters for UPDATEMonetaryAccountExternalForUser.
type UPDATEMonetaryAccountExternalForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMonetaryAccountJointForUserParams defines parameters for ListAllMonetaryAccountJointForUser.
type ListAllMonetaryAccountJointForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEMonetaryAccountJointForUserParams defines parameters for CREATEMonetaryAccountJointForUser.
type CREATEMonetaryAccountJointForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMonetaryAccountJointForUserParams defines parameters for READMonetaryAccountJointForUser.
type READMonetaryAccountJointForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEMonetaryAccountJointForUserParams defines parameters for UPDATEMonetaryAccountJointForUser.
type UPDATEMonetaryAccountJointForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMonetaryAccountSavingsForUserParams defines parameters for ListAllMonetaryAccountSavingsForUser.
type ListAllMonetaryAccountSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEMonetaryAccountSavingsForUserParams defines parameters for CREATEMonetaryAccountSavingsForUser.
type CREATEMonetaryAccountSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMonetaryAccountSavingsForUserParams defines parameters for READMonetaryAccountSavingsForUser.
type READMonetaryAccountSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEMonetaryAccountSavingsForUserParams defines parameters for UPDATEMonetaryAccountSavingsForUser.
type UPDATEMonetaryAccountSavingsForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMonetaryAccountForUserParams defines parameters for READMonetaryAccountForUser.
type READMonetaryAccountForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransaction.
type ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction.
type CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransaction.
type DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams defines parameters for READNoteAttachmentForUserMonetaryAccountAdyenCardTransaction.
type READNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction.
type UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountAdyenCardTransactionParams defines parameters for ListAllNoteTextForUserMonetaryAccountAdyenCardTransaction.
type ListAllNoteTextForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountAdyenCardTransactionParams defines parameters for CREATENoteTextForUserMonetaryAccountAdyenCardTransaction.
type CREATENoteTextForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountAdyenCardTransactionParams defines parameters for DELETENoteTextForUserMonetaryAccountAdyenCardTransaction.
type DELETENoteTextForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountAdyenCardTransactionParams defines parameters for READNoteTextForUserMonetaryAccountAdyenCardTransaction.
type READNoteTextForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionParams defines parameters for UPDATENoteTextForUserMonetaryAccountAdyenCardTransaction.
type UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEAttachmentForUserMonetaryAccountParams defines parameters for CREATEAttachmentForUserMonetaryAccount.
type CREATEAttachmentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserMonetaryAccountAttachmentParams defines parameters for ListAllContentForUserMonetaryAccountAttachment.
type ListAllContentForUserMonetaryAccountAttachmentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult.
type ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult.
type CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult.
type DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult.
type READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult.
type UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResult.
type ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResult.
type CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResult.
type DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for READNoteTextForUserMonetaryAccountBunqmeFundraiserResult.
type READNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams defines parameters for UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResult.
type UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READBunqmeFundraiserResultForUserMonetaryAccountParams defines parameters for READBunqmeFundraiserResultForUserMonetaryAccount.
type READBunqmeFundraiserResultForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllBunqmeTabForUserMonetaryAccountParams defines parameters for ListAllBunqmeTabForUserMonetaryAccount.
type ListAllBunqmeTabForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEBunqmeTabForUserMonetaryAccountParams defines parameters for CREATEBunqmeTabForUserMonetaryAccount.
type CREATEBunqmeTabForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READBunqmeTabResultResponseForUserMonetaryAccountParams defines parameters for READBunqmeTabResultResponseForUserMonetaryAccount.
type READBunqmeTabResultResponseForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READBunqmeTabForUserMonetaryAccountParams defines parameters for READBunqmeTabForUserMonetaryAccount.
type READBunqmeTabForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEBunqmeTabForUserMonetaryAccountParams defines parameters for UPDATEBunqmeTabForUserMonetaryAccount.
type UPDATEBunqmeTabForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountParams defines parameters for CREATECurrencyCloudPaymentQuoteForUserMonetaryAccount.
type CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCurrencyConversionForUserMonetaryAccountParams defines parameters for ListAllCurrencyConversionForUserMonetaryAccount.
type ListAllCurrencyConversionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECurrencyConversionQuoteForUserMonetaryAccountParams defines parameters for CREATECurrencyConversionQuoteForUserMonetaryAccount.
type CREATECurrencyConversionQuoteForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCurrencyConversionQuoteForUserMonetaryAccountParams defines parameters for READCurrencyConversionQuoteForUserMonetaryAccount.
type READCurrencyConversionQuoteForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATECurrencyConversionQuoteForUserMonetaryAccountParams defines parameters for UPDATECurrencyConversionQuoteForUserMonetaryAccount.
type UPDATECurrencyConversionQuoteForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCurrencyConversionForUserMonetaryAccountParams defines parameters for READCurrencyConversionForUserMonetaryAccount.
type READCurrencyConversionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCustomerStatementForUserMonetaryAccountParams defines parameters for ListAllCustomerStatementForUserMonetaryAccount.
type ListAllCustomerStatementForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECustomerStatementForUserMonetaryAccountParams defines parameters for CREATECustomerStatementForUserMonetaryAccount.
type CREATECustomerStatementForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserMonetaryAccountCustomerStatementParams defines parameters for ListAllContentForUserMonetaryAccountCustomerStatement.
type ListAllContentForUserMonetaryAccountCustomerStatementParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETECustomerStatementForUserMonetaryAccountParams defines parameters for DELETECustomerStatementForUserMonetaryAccount.
type DELETECustomerStatementForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCustomerStatementForUserMonetaryAccountParams defines parameters for READCustomerStatementForUserMonetaryAccount.
type READCustomerStatementForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllDraftPaymentForUserMonetaryAccountParams defines parameters for ListAllDraftPaymentForUserMonetaryAccount.
type ListAllDraftPaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEDraftPaymentForUserMonetaryAccountParams defines parameters for CREATEDraftPaymentForUserMonetaryAccount.
type CREATEDraftPaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountDraftPaymentParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountDraftPayment.
type ListAllNoteAttachmentForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountDraftPaymentParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountDraftPayment.
type CREATENoteAttachmentForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountDraftPaymentParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountDraftPayment.
type DELETENoteAttachmentForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountDraftPaymentParams defines parameters for READNoteAttachmentForUserMonetaryAccountDraftPayment.
type READNoteAttachmentForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountDraftPayment.
type UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountDraftPaymentParams defines parameters for ListAllNoteTextForUserMonetaryAccountDraftPayment.
type ListAllNoteTextForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountDraftPaymentParams defines parameters for CREATENoteTextForUserMonetaryAccountDraftPayment.
type CREATENoteTextForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountDraftPaymentParams defines parameters for DELETENoteTextForUserMonetaryAccountDraftPayment.
type DELETENoteTextForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountDraftPaymentParams defines parameters for READNoteTextForUserMonetaryAccountDraftPayment.
type READNoteTextForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountDraftPaymentParams defines parameters for UPDATENoteTextForUserMonetaryAccountDraftPayment.
type UPDATENoteTextForUserMonetaryAccountDraftPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READDraftPaymentForUserMonetaryAccountParams defines parameters for READDraftPaymentForUserMonetaryAccount.
type READDraftPaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEDraftPaymentForUserMonetaryAccountParams defines parameters for UPDATEDraftPaymentForUserMonetaryAccount.
type UPDATEDraftPaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEStatementForUserMonetaryAccountEventParams defines parameters for CREATEStatementForUserMonetaryAccountEvent.
type CREATEStatementForUserMonetaryAccountEventParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READStatementForUserMonetaryAccountEventParams defines parameters for READStatementForUserMonetaryAccountEvent.
type READStatementForUserMonetaryAccountEventParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserMonetaryAccountEventStatementParams defines parameters for ListAllContentForUserMonetaryAccountEventStatement.
type ListAllContentForUserMonetaryAccountEventStatementParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllExportRibForUserMonetaryAccountParams defines parameters for ListAllExportRibForUserMonetaryAccount.
type ListAllExportRibForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEExportRibForUserMonetaryAccountParams defines parameters for CREATEExportRibForUserMonetaryAccount.
type CREATEExportRibForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllContentForUserMonetaryAccountExportRibParams defines parameters for ListAllContentForUserMonetaryAccountExportRib.
type ListAllContentForUserMonetaryAccountExportRibParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEExportRibForUserMonetaryAccountParams defines parameters for DELETEExportRibForUserMonetaryAccount.
type DELETEExportRibForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READExportRibForUserMonetaryAccountParams defines parameters for READExportRibForUserMonetaryAccount.
type READExportRibForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllIdealMerchantTransactionForUserMonetaryAccountParams defines parameters for ListAllIdealMerchantTransactionForUserMonetaryAccount.
type ListAllIdealMerchantTransactionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEIdealMerchantTransactionForUserMonetaryAccountParams defines parameters for CREATEIdealMerchantTransactionForUserMonetaryAccount.
type CREATEIdealMerchantTransactionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction.
type ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction.
type CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction.
type DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for READNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction.
type READNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction.
type UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for ListAllNoteTextForUserMonetaryAccountIdealMerchantTransaction.
type ListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for CREATENoteTextForUserMonetaryAccountIdealMerchantTransaction.
type CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for DELETENoteTextForUserMonetaryAccountIdealMerchantTransaction.
type DELETENoteTextForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for READNoteTextForUserMonetaryAccountIdealMerchantTransaction.
type READNoteTextForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams defines parameters for UPDATENoteTextForUserMonetaryAccountIdealMerchantTransaction.
type UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READIdealMerchantTransactionForUserMonetaryAccountParams defines parameters for READIdealMerchantTransactionForUserMonetaryAccount.
type READIdealMerchantTransactionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllInvoiceForUserMonetaryAccountParams defines parameters for ListAllInvoiceForUserMonetaryAccount.
type ListAllInvoiceForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READInvoiceForUserMonetaryAccountParams defines parameters for READInvoiceForUserMonetaryAccount.
type READInvoiceForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllMastercardActionForUserMonetaryAccountParams defines parameters for ListAllMastercardActionForUserMonetaryAccount.
type ListAllMastercardActionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READMastercardActionForUserMonetaryAccountParams defines parameters for READMastercardActionForUserMonetaryAccount.
type READMastercardActionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountMastercardActionParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountMastercardAction.
type ListAllNoteAttachmentForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountMastercardActionParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountMastercardAction.
type CREATENoteAttachmentForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountMastercardActionParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountMastercardAction.
type DELETENoteAttachmentForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountMastercardActionParams defines parameters for READNoteAttachmentForUserMonetaryAccountMastercardAction.
type READNoteAttachmentForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountMastercardActionParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountMastercardAction.
type UPDATENoteAttachmentForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountMastercardActionParams defines parameters for ListAllNoteTextForUserMonetaryAccountMastercardAction.
type ListAllNoteTextForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountMastercardActionParams defines parameters for CREATENoteTextForUserMonetaryAccountMastercardAction.
type CREATENoteTextForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountMastercardActionParams defines parameters for DELETENoteTextForUserMonetaryAccountMastercardAction.
type DELETENoteTextForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountMastercardActionParams defines parameters for READNoteTextForUserMonetaryAccountMastercardAction.
type READNoteTextForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountMastercardActionParams defines parameters for UPDATENoteTextForUserMonetaryAccountMastercardAction.
type UPDATENoteTextForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPaymentForUserMonetaryAccountMastercardActionParams defines parameters for ListAllPaymentForUserMonetaryAccountMastercardAction.
type ListAllPaymentForUserMonetaryAccountMastercardActionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNotificationFilterUrlForUserMonetaryAccountParams defines parameters for ListAllNotificationFilterUrlForUserMonetaryAccount.
type ListAllNotificationFilterUrlForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENotificationFilterUrlForUserMonetaryAccountParams defines parameters for CREATENotificationFilterUrlForUserMonetaryAccount.
type CREATENotificationFilterUrlForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction.
type ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction.
type CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction.
type DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction.
type READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction.
type UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction.
type ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction.
type CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction.
type DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for READNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction.
type READNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams defines parameters for UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction.
type UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPaymentForUserMonetaryAccountParams defines parameters for ListAllPaymentForUserMonetaryAccount.
type ListAllPaymentForUserMonetaryAccountParams struct {
	// Count Amount of things to return
	Count int `form:"count,omitempty" json:"count,omitempty"`

	// NewerId Starting id for this page
	NewerId int `form:"newer_id,omitempty" json:"newer_id,omitempty"`

	// OlderId Ending id for this page
	OlderId int `form:"older_id,omitempty" json:"older_id,omitempty"`

	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEPaymentForUserMonetaryAccountParams defines parameters for CREATEPaymentForUserMonetaryAccount.
type CREATEPaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPaymentAutoAllocateForUserMonetaryAccountParams defines parameters for ListAllPaymentAutoAllocateForUserMonetaryAccount.
type ListAllPaymentAutoAllocateForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEPaymentAutoAllocateForUserMonetaryAccountParams defines parameters for CREATEPaymentAutoAllocateForUserMonetaryAccount.
type CREATEPaymentAutoAllocateForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEPaymentAutoAllocateForUserMonetaryAccountParams defines parameters for DELETEPaymentAutoAllocateForUserMonetaryAccount.
type DELETEPaymentAutoAllocateForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READPaymentAutoAllocateForUserMonetaryAccountParams defines parameters for READPaymentAutoAllocateForUserMonetaryAccount.
type READPaymentAutoAllocateForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEPaymentAutoAllocateForUserMonetaryAccountParams defines parameters for UPDATEPaymentAutoAllocateForUserMonetaryAccount.
type UPDATEPaymentAutoAllocateForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateParams defines parameters for ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocate.
type ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllInstanceForUserMonetaryAccountPaymentAutoAllocateParams defines parameters for ListAllInstanceForUserMonetaryAccountPaymentAutoAllocate.
type ListAllInstanceForUserMonetaryAccountPaymentAutoAllocateParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READInstanceForUserMonetaryAccountPaymentAutoAllocateParams defines parameters for READInstanceForUserMonetaryAccountPaymentAutoAllocate.
type READInstanceForUserMonetaryAccountPaymentAutoAllocateParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPaymentBatchForUserMonetaryAccountParams defines parameters for ListAllPaymentBatchForUserMonetaryAccount.
type ListAllPaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEPaymentBatchForUserMonetaryAccountParams defines parameters for CREATEPaymentBatchForUserMonetaryAccount.
type CREATEPaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READPaymentBatchForUserMonetaryAccountParams defines parameters for READPaymentBatchForUserMonetaryAccount.
type READPaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEPaymentBatchForUserMonetaryAccountParams defines parameters for UPDATEPaymentBatchForUserMonetaryAccount.
type UPDATEPaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountPaymentBatchParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountPaymentBatch.
type ListAllNoteAttachmentForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountPaymentBatchParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountPaymentBatch.
type CREATENoteAttachmentForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountPaymentBatchParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountPaymentBatch.
type DELETENoteAttachmentForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountPaymentBatchParams defines parameters for READNoteAttachmentForUserMonetaryAccountPaymentBatch.
type READNoteAttachmentForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountPaymentBatch.
type UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountPaymentBatchParams defines parameters for ListAllNoteTextForUserMonetaryAccountPaymentBatch.
type ListAllNoteTextForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountPaymentBatchParams defines parameters for CREATENoteTextForUserMonetaryAccountPaymentBatch.
type CREATENoteTextForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountPaymentBatchParams defines parameters for DELETENoteTextForUserMonetaryAccountPaymentBatch.
type DELETENoteTextForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountPaymentBatchParams defines parameters for READNoteTextForUserMonetaryAccountPaymentBatch.
type READNoteTextForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountPaymentBatchParams defines parameters for UPDATENoteTextForUserMonetaryAccountPaymentBatch.
type UPDATENoteTextForUserMonetaryAccountPaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayed.
type ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountPaymentDelayed.
type CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountPaymentDelayedParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountPaymentDelayed.
type DELETENoteAttachmentForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountPaymentDelayedParams defines parameters for READNoteAttachmentForUserMonetaryAccountPaymentDelayed.
type READNoteAttachmentForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayed.
type UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountPaymentDelayedParams defines parameters for ListAllNoteTextForUserMonetaryAccountPaymentDelayed.
type ListAllNoteTextForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountPaymentDelayedParams defines parameters for CREATENoteTextForUserMonetaryAccountPaymentDelayed.
type CREATENoteTextForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountPaymentDelayedParams defines parameters for DELETENoteTextForUserMonetaryAccountPaymentDelayed.
type DELETENoteTextForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountPaymentDelayedParams defines parameters for READNoteTextForUserMonetaryAccountPaymentDelayed.
type READNoteTextForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountPaymentDelayedParams defines parameters for UPDATENoteTextForUserMonetaryAccountPaymentDelayed.
type UPDATENoteTextForUserMonetaryAccountPaymentDelayedParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READPaymentForUserMonetaryAccountParams defines parameters for READPaymentForUserMonetaryAccount.
type READPaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountPaymentParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountPayment.
type ListAllNoteAttachmentForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountPaymentParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountPayment.
type CREATENoteAttachmentForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountPaymentParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountPayment.
type DELETENoteAttachmentForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountPaymentParams defines parameters for READNoteAttachmentForUserMonetaryAccountPayment.
type READNoteAttachmentForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountPaymentParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountPayment.
type UPDATENoteAttachmentForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountPaymentParams defines parameters for ListAllNoteTextForUserMonetaryAccountPayment.
type ListAllNoteTextForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountPaymentParams defines parameters for CREATENoteTextForUserMonetaryAccountPayment.
type CREATENoteTextForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountPaymentParams defines parameters for DELETENoteTextForUserMonetaryAccountPayment.
type DELETENoteTextForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountPaymentParams defines parameters for READNoteTextForUserMonetaryAccountPayment.
type READNoteTextForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountPaymentParams defines parameters for UPDATENoteTextForUserMonetaryAccountPayment.
type UPDATENoteTextForUserMonetaryAccountPaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllRequestInquiryForUserMonetaryAccountParams defines parameters for ListAllRequestInquiryForUserMonetaryAccount.
type ListAllRequestInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATERequestInquiryForUserMonetaryAccountParams defines parameters for CREATERequestInquiryForUserMonetaryAccount.
type CREATERequestInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllRequestInquiryBatchForUserMonetaryAccountParams defines parameters for ListAllRequestInquiryBatchForUserMonetaryAccount.
type ListAllRequestInquiryBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATERequestInquiryBatchForUserMonetaryAccountParams defines parameters for CREATERequestInquiryBatchForUserMonetaryAccount.
type CREATERequestInquiryBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READRequestInquiryBatchForUserMonetaryAccountParams defines parameters for READRequestInquiryBatchForUserMonetaryAccount.
type READRequestInquiryBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATERequestInquiryBatchForUserMonetaryAccountParams defines parameters for UPDATERequestInquiryBatchForUserMonetaryAccount.
type UPDATERequestInquiryBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatch.
type ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch.
type CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatch.
type DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams defines parameters for READNoteAttachmentForUserMonetaryAccountRequestInquiryBatch.
type READNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch.
type UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountRequestInquiryBatchParams defines parameters for ListAllNoteTextForUserMonetaryAccountRequestInquiryBatch.
type ListAllNoteTextForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountRequestInquiryBatchParams defines parameters for CREATENoteTextForUserMonetaryAccountRequestInquiryBatch.
type CREATENoteTextForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountRequestInquiryBatchParams defines parameters for DELETENoteTextForUserMonetaryAccountRequestInquiryBatch.
type DELETENoteTextForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountRequestInquiryBatchParams defines parameters for READNoteTextForUserMonetaryAccountRequestInquiryBatch.
type READNoteTextForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchParams defines parameters for UPDATENoteTextForUserMonetaryAccountRequestInquiryBatch.
type UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READRequestInquiryForUserMonetaryAccountParams defines parameters for READRequestInquiryForUserMonetaryAccount.
type READRequestInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATERequestInquiryForUserMonetaryAccountParams defines parameters for UPDATERequestInquiryForUserMonetaryAccount.
type UPDATERequestInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountRequestInquiry.
type ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountRequestInquiryParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountRequestInquiry.
type CREATENoteAttachmentForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountRequestInquiryParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountRequestInquiry.
type DELETENoteAttachmentForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountRequestInquiryParams defines parameters for READNoteAttachmentForUserMonetaryAccountRequestInquiry.
type READNoteAttachmentForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountRequestInquiry.
type UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountRequestInquiryParams defines parameters for ListAllNoteTextForUserMonetaryAccountRequestInquiry.
type ListAllNoteTextForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountRequestInquiryParams defines parameters for CREATENoteTextForUserMonetaryAccountRequestInquiry.
type CREATENoteTextForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountRequestInquiryParams defines parameters for DELETENoteTextForUserMonetaryAccountRequestInquiry.
type DELETENoteTextForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountRequestInquiryParams defines parameters for READNoteTextForUserMonetaryAccountRequestInquiry.
type READNoteTextForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountRequestInquiryParams defines parameters for UPDATENoteTextForUserMonetaryAccountRequestInquiry.
type UPDATENoteTextForUserMonetaryAccountRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllRequestResponseForUserMonetaryAccountParams defines parameters for ListAllRequestResponseForUserMonetaryAccount.
type ListAllRequestResponseForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READRequestResponseForUserMonetaryAccountParams defines parameters for READRequestResponseForUserMonetaryAccount.
type READRequestResponseForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATERequestResponseForUserMonetaryAccountParams defines parameters for UPDATERequestResponseForUserMonetaryAccount.
type UPDATERequestResponseForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountRequestResponseParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountRequestResponse.
type ListAllNoteAttachmentForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountRequestResponseParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountRequestResponse.
type CREATENoteAttachmentForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountRequestResponseParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountRequestResponse.
type DELETENoteAttachmentForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountRequestResponseParams defines parameters for READNoteAttachmentForUserMonetaryAccountRequestResponse.
type READNoteAttachmentForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountRequestResponseParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountRequestResponse.
type UPDATENoteAttachmentForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountRequestResponseParams defines parameters for ListAllNoteTextForUserMonetaryAccountRequestResponse.
type ListAllNoteTextForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountRequestResponseParams defines parameters for CREATENoteTextForUserMonetaryAccountRequestResponse.
type CREATENoteTextForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountRequestResponseParams defines parameters for DELETENoteTextForUserMonetaryAccountRequestResponse.
type DELETENoteTextForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountRequestResponseParams defines parameters for READNoteTextForUserMonetaryAccountRequestResponse.
type READNoteTextForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountRequestResponseParams defines parameters for UPDATENoteTextForUserMonetaryAccountRequestResponse.
type UPDATENoteTextForUserMonetaryAccountRequestResponseParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllScheduleForUserMonetaryAccountParams defines parameters for ListAllScheduleForUserMonetaryAccount.
type ListAllScheduleForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllSchedulePaymentForUserMonetaryAccountParams defines parameters for ListAllSchedulePaymentForUserMonetaryAccount.
type ListAllSchedulePaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATESchedulePaymentForUserMonetaryAccountParams defines parameters for CREATESchedulePaymentForUserMonetaryAccount.
type CREATESchedulePaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATESchedulePaymentBatchForUserMonetaryAccountParams defines parameters for CREATESchedulePaymentBatchForUserMonetaryAccount.
type CREATESchedulePaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETESchedulePaymentBatchForUserMonetaryAccountParams defines parameters for DELETESchedulePaymentBatchForUserMonetaryAccount.
type DELETESchedulePaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READSchedulePaymentBatchForUserMonetaryAccountParams defines parameters for READSchedulePaymentBatchForUserMonetaryAccount.
type READSchedulePaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATESchedulePaymentBatchForUserMonetaryAccountParams defines parameters for UPDATESchedulePaymentBatchForUserMonetaryAccount.
type UPDATESchedulePaymentBatchForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch.
type ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch.
type CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch.
type DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch.
type READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch.
type UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatch.
type ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for CREATENoteTextForUserMonetaryAccountSchedulePaymentBatch.
type CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for DELETENoteTextForUserMonetaryAccountSchedulePaymentBatch.
type DELETENoteTextForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for READNoteTextForUserMonetaryAccountSchedulePaymentBatch.
type READNoteTextForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams defines parameters for UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatch.
type UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETESchedulePaymentForUserMonetaryAccountParams defines parameters for DELETESchedulePaymentForUserMonetaryAccount.
type DELETESchedulePaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READSchedulePaymentForUserMonetaryAccountParams defines parameters for READSchedulePaymentForUserMonetaryAccount.
type READSchedulePaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATESchedulePaymentForUserMonetaryAccountParams defines parameters for UPDATESchedulePaymentForUserMonetaryAccount.
type UPDATESchedulePaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountSchedulePayment.
type ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountSchedulePayment.
type CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountSchedulePayment.
type DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountSchedulePaymentParams defines parameters for READNoteAttachmentForUserMonetaryAccountSchedulePayment.
type READNoteAttachmentForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountSchedulePayment.
type UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountSchedulePaymentParams defines parameters for ListAllNoteTextForUserMonetaryAccountSchedulePayment.
type ListAllNoteTextForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountSchedulePaymentParams defines parameters for CREATENoteTextForUserMonetaryAccountSchedulePayment.
type CREATENoteTextForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountSchedulePaymentParams defines parameters for DELETENoteTextForUserMonetaryAccountSchedulePayment.
type DELETENoteTextForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountSchedulePaymentParams defines parameters for READNoteTextForUserMonetaryAccountSchedulePayment.
type READNoteTextForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountSchedulePaymentParams defines parameters for UPDATENoteTextForUserMonetaryAccountSchedulePayment.
type UPDATENoteTextForUserMonetaryAccountSchedulePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch.
type ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch.
type CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch.
type DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch.
type READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch.
type UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch.
type ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch.
type CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch.
type DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch.
type READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams defines parameters for UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch.
type UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry.
type ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry.
type CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry.
type DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry.
type READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry.
type UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiry.
type ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for CREATENoteTextForUserMonetaryAccountScheduleRequestInquiry.
type CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for DELETENoteTextForUserMonetaryAccountScheduleRequestInquiry.
type DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for READNoteTextForUserMonetaryAccountScheduleRequestInquiry.
type READNoteTextForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams defines parameters for UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiry.
type UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READScheduleForUserMonetaryAccountParams defines parameters for READScheduleForUserMonetaryAccount.
type READScheduleForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllScheduleInstanceForUserMonetaryAccountScheduleParams defines parameters for ListAllScheduleInstanceForUserMonetaryAccountSchedule.
type ListAllScheduleInstanceForUserMonetaryAccountScheduleParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READScheduleInstanceForUserMonetaryAccountScheduleParams defines parameters for READScheduleInstanceForUserMonetaryAccountSchedule.
type READScheduleInstanceForUserMonetaryAccountScheduleParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEScheduleInstanceForUserMonetaryAccountScheduleParams defines parameters for UPDATEScheduleInstanceForUserMonetaryAccountSchedule.
type UPDATEScheduleInstanceForUserMonetaryAccountScheduleParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance.
type ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance.
type CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance.
type DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance.
type READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance.
type UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstance.
type ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for CREATENoteTextForUserMonetaryAccountScheduleScheduleInstance.
type CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for DELETENoteTextForUserMonetaryAccountScheduleScheduleInstance.
type DELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for READNoteTextForUserMonetaryAccountScheduleScheduleInstance.
type READNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams defines parameters for UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstance.
type UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams defines parameters for ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccount.
type ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams defines parameters for CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount.
type CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams defines parameters for READShareInviteMonetaryAccountInquiryForUserMonetaryAccount.
type READShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams defines parameters for UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount.
type UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllSofortMerchantTransactionForUserMonetaryAccountParams defines parameters for ListAllSofortMerchantTransactionForUserMonetaryAccount.
type ListAllSofortMerchantTransactionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READSofortMerchantTransactionForUserMonetaryAccountParams defines parameters for READSofortMerchantTransactionForUserMonetaryAccount.
type READSofortMerchantTransactionForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction.
type ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction.
type CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction.
type DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for READNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction.
type READNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction.
type UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for ListAllNoteTextForUserMonetaryAccountSofortMerchantTransaction.
type ListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for CREATENoteTextForUserMonetaryAccountSofortMerchantTransaction.
type CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for DELETENoteTextForUserMonetaryAccountSofortMerchantTransaction.
type DELETENoteTextForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for READNoteTextForUserMonetaryAccountSofortMerchantTransaction.
type READNoteTextForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams defines parameters for UPDATENoteTextForUserMonetaryAccountSofortMerchantTransaction.
type UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READSwitchServicePaymentForUserMonetaryAccountParams defines parameters for READSwitchServicePaymentForUserMonetaryAccount.
type READSwitchServicePaymentForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePayment.
type ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountSwitchServicePayment.
type CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountSwitchServicePayment.
type DELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams defines parameters for READNoteAttachmentForUserMonetaryAccountSwitchServicePayment.
type READNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePayment.
type UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountSwitchServicePaymentParams defines parameters for ListAllNoteTextForUserMonetaryAccountSwitchServicePayment.
type ListAllNoteTextForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountSwitchServicePaymentParams defines parameters for CREATENoteTextForUserMonetaryAccountSwitchServicePayment.
type CREATENoteTextForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountSwitchServicePaymentParams defines parameters for DELETENoteTextForUserMonetaryAccountSwitchServicePayment.
type DELETENoteTextForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountSwitchServicePaymentParams defines parameters for READNoteTextForUserMonetaryAccountSwitchServicePayment.
type READNoteTextForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentParams defines parameters for UPDATENoteTextForUserMonetaryAccountSwitchServicePayment.
type UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllWhitelistSddForUserMonetaryAccountParams defines parameters for ListAllWhitelistSddForUserMonetaryAccount.
type ListAllWhitelistSddForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READWhitelistSddForUserMonetaryAccountParams defines parameters for READWhitelistSddForUserMonetaryAccount.
type READWhitelistSddForUserMonetaryAccountParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult.
type ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult.
type CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult.
type DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult.
type READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult.
type UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResult.
type ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResult.
type CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResult.
type DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for READNoteTextForUserMonetaryAccountWhitelistWhitelistResult.
type READNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams defines parameters for UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResult.
type UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNotificationFilterEmailForUserParams defines parameters for ListAllNotificationFilterEmailForUser.
type ListAllNotificationFilterEmailForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENotificationFilterEmailForUserParams defines parameters for CREATENotificationFilterEmailForUser.
type CREATENotificationFilterEmailForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNotificationFilterFailureForUserParams defines parameters for ListAllNotificationFilterFailureForUser.
type ListAllNotificationFilterFailureForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENotificationFilterFailureForUserParams defines parameters for CREATENotificationFilterFailureForUser.
type CREATENotificationFilterFailureForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNotificationFilterPushForUserParams defines parameters for ListAllNotificationFilterPushForUser.
type ListAllNotificationFilterPushForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENotificationFilterPushForUserParams defines parameters for CREATENotificationFilterPushForUser.
type CREATENotificationFilterPushForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllNotificationFilterUrlForUserParams defines parameters for ListAllNotificationFilterUrlForUser.
type ListAllNotificationFilterUrlForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATENotificationFilterUrlForUserParams defines parameters for CREATENotificationFilterUrlForUser.
type CREATENotificationFilterUrlForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllOauthClientForUserParams defines parameters for ListAllOauthClientForUser.
type ListAllOauthClientForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEOauthClientForUserParams defines parameters for CREATEOauthClientForUser.
type CREATEOauthClientForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READOauthClientForUserParams defines parameters for READOauthClientForUser.
type READOauthClientForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEOauthClientForUserParams defines parameters for UPDATEOauthClientForUser.
type UPDATEOauthClientForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllCallbackUrlForUserOauthClientParams defines parameters for ListAllCallbackUrlForUserOauthClient.
type ListAllCallbackUrlForUserOauthClientParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATECallbackUrlForUserOauthClientParams defines parameters for CREATECallbackUrlForUserOauthClient.
type CREATECallbackUrlForUserOauthClientParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETECallbackUrlForUserOauthClientParams defines parameters for DELETECallbackUrlForUserOauthClient.
type DELETECallbackUrlForUserOauthClientParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READCallbackUrlForUserOauthClientParams defines parameters for READCallbackUrlForUserOauthClient.
type READCallbackUrlForUserOauthClientParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATECallbackUrlForUserOauthClientParams defines parameters for UPDATECallbackUrlForUserOauthClient.
type UPDATECallbackUrlForUserOauthClientParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPaymentAutoAllocateForUserParams defines parameters for ListAllPaymentAutoAllocateForUser.
type ListAllPaymentAutoAllocateForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPaymentServiceProviderDraftPaymentForUserParams defines parameters for ListAllPaymentServiceProviderDraftPaymentForUser.
type ListAllPaymentServiceProviderDraftPaymentForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEPaymentServiceProviderDraftPaymentForUserParams defines parameters for CREATEPaymentServiceProviderDraftPaymentForUser.
type CREATEPaymentServiceProviderDraftPaymentForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READPaymentServiceProviderDraftPaymentForUserParams defines parameters for READPaymentServiceProviderDraftPaymentForUser.
type READPaymentServiceProviderDraftPaymentForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEPaymentServiceProviderDraftPaymentForUserParams defines parameters for UPDATEPaymentServiceProviderDraftPaymentForUser.
type UPDATEPaymentServiceProviderDraftPaymentForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllPaymentServiceProviderIssuerTransactionForUserParams defines parameters for ListAllPaymentServiceProviderIssuerTransactionForUser.
type ListAllPaymentServiceProviderIssuerTransactionForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEPaymentServiceProviderIssuerTransactionForUserParams defines parameters for CREATEPaymentServiceProviderIssuerTransactionForUser.
type CREATEPaymentServiceProviderIssuerTransactionForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READPaymentServiceProviderIssuerTransactionForUserParams defines parameters for READPaymentServiceProviderIssuerTransactionForUser.
type READPaymentServiceProviderIssuerTransactionForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEPaymentServiceProviderIssuerTransactionForUserParams defines parameters for UPDATEPaymentServiceProviderIssuerTransactionForUser.
type UPDATEPaymentServiceProviderIssuerTransactionForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllScheduleForUserParams defines parameters for ListAllScheduleForUser.
type ListAllScheduleForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllShareInviteMonetaryAccountResponseForUserParams defines parameters for ListAllShareInviteMonetaryAccountResponseForUser.
type ListAllShareInviteMonetaryAccountResponseForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READShareInviteMonetaryAccountResponseForUserParams defines parameters for READShareInviteMonetaryAccountResponseForUser.
type READShareInviteMonetaryAccountResponseForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEShareInviteMonetaryAccountResponseForUserParams defines parameters for UPDATEShareInviteMonetaryAccountResponseForUser.
type UPDATEShareInviteMonetaryAccountResponseForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETokenQrRequestIdealForUserParams defines parameters for CREATETokenQrRequestIdealForUser.
type CREATETokenQrRequestIdealForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETokenQrRequestSofortForUserParams defines parameters for CREATETokenQrRequestSofortForUser.
type CREATETokenQrRequestSofortForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllTransferwiseCurrencyForUserParams defines parameters for ListAllTransferwiseCurrencyForUser.
type ListAllTransferwiseCurrencyForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETransferwiseQuoteForUserParams defines parameters for CREATETransferwiseQuoteForUser.
type CREATETransferwiseQuoteForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETransferwiseQuoteTemporaryForUserParams defines parameters for CREATETransferwiseQuoteTemporaryForUser.
type CREATETransferwiseQuoteTemporaryForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READTransferwiseQuoteTemporaryForUserParams defines parameters for READTransferwiseQuoteTemporaryForUser.
type READTransferwiseQuoteTemporaryForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READTransferwiseQuoteForUserParams defines parameters for READTransferwiseQuoteForUser.
type READTransferwiseQuoteForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllTransferwiseRecipientForUserTransferwiseQuoteParams defines parameters for ListAllTransferwiseRecipientForUserTransferwiseQuote.
type ListAllTransferwiseRecipientForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETransferwiseRecipientForUserTransferwiseQuoteParams defines parameters for CREATETransferwiseRecipientForUserTransferwiseQuote.
type CREATETransferwiseRecipientForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteParams defines parameters for ListAllTransferwiseRecipientRequirementForUserTransferwiseQuote.
type ListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteParams defines parameters for CREATETransferwiseRecipientRequirementForUserTransferwiseQuote.
type CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETETransferwiseRecipientForUserTransferwiseQuoteParams defines parameters for DELETETransferwiseRecipientForUserTransferwiseQuote.
type DELETETransferwiseRecipientForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READTransferwiseRecipientForUserTransferwiseQuoteParams defines parameters for READTransferwiseRecipientForUserTransferwiseQuote.
type READTransferwiseRecipientForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllTransferwiseTransferForUserTransferwiseQuoteParams defines parameters for ListAllTransferwiseTransferForUserTransferwiseQuote.
type ListAllTransferwiseTransferForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETransferwiseTransferForUserTransferwiseQuoteParams defines parameters for CREATETransferwiseTransferForUserTransferwiseQuote.
type CREATETransferwiseTransferForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETransferwiseTransferRequirementForUserTransferwiseQuoteParams defines parameters for CREATETransferwiseTransferRequirementForUserTransferwiseQuote.
type CREATETransferwiseTransferRequirementForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READTransferwiseTransferForUserTransferwiseQuoteParams defines parameters for READTransferwiseTransferForUserTransferwiseQuote.
type READTransferwiseTransferForUserTransferwiseQuoteParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllTransferwiseUserForUserParams defines parameters for ListAllTransferwiseUserForUser.
type ListAllTransferwiseUserForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATETransferwiseUserForUserParams defines parameters for CREATETransferwiseUserForUser.
type CREATETransferwiseUserForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllTreeProgressForUserParams defines parameters for ListAllTreeProgressForUser.
type ListAllTreeProgressForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllWhitelistSddForUserParams defines parameters for ListAllWhitelistSddForUser.
type ListAllWhitelistSddForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllWhitelistSddOneOffForUserParams defines parameters for ListAllWhitelistSddOneOffForUser.
type ListAllWhitelistSddOneOffForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEWhitelistSddOneOffForUserParams defines parameters for CREATEWhitelistSddOneOffForUser.
type CREATEWhitelistSddOneOffForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEWhitelistSddOneOffForUserParams defines parameters for DELETEWhitelistSddOneOffForUser.
type DELETEWhitelistSddOneOffForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READWhitelistSddOneOffForUserParams defines parameters for READWhitelistSddOneOffForUser.
type READWhitelistSddOneOffForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEWhitelistSddOneOffForUserParams defines parameters for UPDATEWhitelistSddOneOffForUser.
type UPDATEWhitelistSddOneOffForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// ListAllWhitelistSddRecurringForUserParams defines parameters for ListAllWhitelistSddRecurringForUser.
type ListAllWhitelistSddRecurringForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEWhitelistSddRecurringForUserParams defines parameters for CREATEWhitelistSddRecurringForUser.
type CREATEWhitelistSddRecurringForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// DELETEWhitelistSddRecurringForUserParams defines parameters for DELETEWhitelistSddRecurringForUser.
type DELETEWhitelistSddRecurringForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READWhitelistSddRecurringForUserParams defines parameters for READWhitelistSddRecurringForUser.
type READWhitelistSddRecurringForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// UPDATEWhitelistSddRecurringForUserParams defines parameters for UPDATEWhitelistSddRecurringForUser.
type UPDATEWhitelistSddRecurringForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// READWhitelistSddForUserParams defines parameters for READWhitelistSddForUser.
type READWhitelistSddForUserParams struct {
	// CacheControl The standard HTTP Cache-Control header is required for all signed requests.
	CacheControl *CacheControl `json:"Cache-Control,omitempty"`

	// UserAgent The User-Agent header field should contain information about the user agent originating the request. There are no restrictions on the value of this header.
	UserAgent UserAgent `json:"User-Agent"`

	// XBunqLanguage The X-Bunq-Language header must contain a preferred language indication. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore. Currently only the languages en_US and nl_NL are supported. Anything else will default to en_US.
	XBunqLanguage *XBunqLanguage `json:"X-Bunq-Language,omitempty"`

	// XBunqRegion The X-Bunq-Region header must contain the region (country) of the client device. The value of this header is formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.
	XBunqRegion *XBunqRegion `json:"X-Bunq-Region,omitempty"`

	// XBunqClientRequestId This header must specify an ID with each request that is unique for the logged in user. There are no restrictions for the format of this ID. However, the server will respond with an error when the same ID is used again on the same DeviceServer.
	XBunqClientRequestId *XBunqClientRequestId `json:"X-Bunq-Client-Request-Id,omitempty"`

	// XBunqGeolocation This header must specify the geolocation of the device. The format of this value is longitude latitude altitude radius country. The country is expected to be formatted of an ISO 3166-1 alpha-2 country code. When no geolocation is available or known the header must still be included but can be zero valued.
	XBunqGeolocation *XBunqGeolocation `json:"X-Bunq-Geolocation,omitempty"`

	// XBunqClientAuthentication The authentication token is used to authenticate the source of the API call. It is required by all API calls except for POST /v1/installation. It is important to note that the device and session calls are using the token from the response of the installation call, while all the other calls use the token from the response of the session-server call
	XBunqClientAuthentication XBunqClientAuthentication `json:"X-Bunq-Client-Authentication"`
}

// CREATEAttachmentPublicJSONRequestBody defines body for CREATEAttachmentPublic for application/json ContentType.
type CREATEAttachmentPublicJSONRequestBody = AttachmentPublic

// CREATEAvatarJSONRequestBody defines body for CREATEAvatar for application/json ContentType.
type CREATEAvatarJSONRequestBody = Avatar

// CREATEDeviceServerJSONRequestBody defines body for CREATEDeviceServer for application/json ContentType.
type CREATEDeviceServerJSONRequestBody = DeviceServer

// CREATEInstallationJSONRequestBody defines body for CREATEInstallation for application/json ContentType.
type CREATEInstallationJSONRequestBody = Installation

// CREATEPaymentServiceProviderCredentialJSONRequestBody defines body for CREATEPaymentServiceProviderCredential for application/json ContentType.
type CREATEPaymentServiceProviderCredentialJSONRequestBody = PaymentServiceProviderCredential

// CREATESandboxUserCompanyJSONRequestBody defines body for CREATESandboxUserCompany for application/json ContentType.
type CREATESandboxUserCompanyJSONRequestBody = SandboxUserCompany

// CREATESandboxUserPersonJSONRequestBody defines body for CREATESandboxUserPerson for application/json ContentType.
type CREATESandboxUserPersonJSONRequestBody = SandboxUserPerson

// CREATEServerErrorJSONRequestBody defines body for CREATEServerError for application/json ContentType.
type CREATEServerErrorJSONRequestBody = ServerError

// CREATESessionServerJSONRequestBody defines body for CREATESessionServer for application/json ContentType.
type CREATESessionServerJSONRequestBody = SessionServer

// UPDATEUserCompanyJSONRequestBody defines body for UPDATEUserCompany for application/json ContentType.
type UPDATEUserCompanyJSONRequestBody = UserCompany

// UPDATEUserPersonJSONRequestBody defines body for UPDATEUserPerson for application/json ContentType.
type UPDATEUserPersonJSONRequestBody = UserPerson

// CREATEAdditionalTransactionInformationCategoryUserDefinedForUserJSONRequestBody defines body for CREATEAdditionalTransactionInformationCategoryUserDefinedForUser for application/json ContentType.
type CREATEAdditionalTransactionInformationCategoryUserDefinedForUserJSONRequestBody = AdditionalTransactionInformationCategoryUserDefined

// CREATECardBatchForUserJSONRequestBody defines body for CREATECardBatchForUser for application/json ContentType.
type CREATECardBatchForUserJSONRequestBody = CardBatch

// CREATECardBatchReplaceForUserJSONRequestBody defines body for CREATECardBatchReplaceForUser for application/json ContentType.
type CREATECardBatchReplaceForUserJSONRequestBody = CardBatchReplace

// CREATECardCreditForUserJSONRequestBody defines body for CREATECardCreditForUser for application/json ContentType.
type CREATECardCreditForUserJSONRequestBody = CardCredit

// CREATECardDebitForUserJSONRequestBody defines body for CREATECardDebitForUser for application/json ContentType.
type CREATECardDebitForUserJSONRequestBody = CardDebit

// CREATEExportStatementCardCsvForUserCardJSONRequestBody defines body for CREATEExportStatementCardCsvForUserCard for application/json ContentType.
type CREATEExportStatementCardCsvForUserCardJSONRequestBody = ExportStatementCardCsv

// CREATEExportStatementCardPdfForUserCardJSONRequestBody defines body for CREATEExportStatementCardPdfForUserCard for application/json ContentType.
type CREATEExportStatementCardPdfForUserCardJSONRequestBody = ExportStatementCardPdf

// CREATEGeneratedCvc2ForUserCardJSONRequestBody defines body for CREATEGeneratedCvc2ForUserCard for application/json ContentType.
type CREATEGeneratedCvc2ForUserCardJSONRequestBody = CardGeneratedCvc2

// UPDATEGeneratedCvc2ForUserCardJSONRequestBody defines body for UPDATEGeneratedCvc2ForUserCard for application/json ContentType.
type UPDATEGeneratedCvc2ForUserCardJSONRequestBody = CardGeneratedCvc2

// CREATEReplaceForUserCardJSONRequestBody defines body for CREATEReplaceForUserCard for application/json ContentType.
type CREATEReplaceForUserCardJSONRequestBody = CardReplace

// UPDATECardForUserJSONRequestBody defines body for UPDATECardForUser for application/json ContentType.
type UPDATECardForUserJSONRequestBody = Card

// CREATECertificatePinnedForUserJSONRequestBody defines body for CREATECertificatePinnedForUser for application/json ContentType.
type CREATECertificatePinnedForUserJSONRequestBody = CertificatePinned

// UPDATEChallengeRequestForUserJSONRequestBody defines body for UPDATEChallengeRequestForUser for application/json ContentType.
type UPDATEChallengeRequestForUserJSONRequestBody = MasterCardIdentityCheckChallengeRequestUser

// CREATECompanyForUserJSONRequestBody defines body for CREATECompanyForUser for application/json ContentType.
type CREATECompanyForUserJSONRequestBody = Company

// UPDATECompanyForUserJSONRequestBody defines body for UPDATECompanyForUser for application/json ContentType.
type UPDATECompanyForUserJSONRequestBody = Company

// CREATEConfirmationOfFundsForUserJSONRequestBody defines body for CREATEConfirmationOfFundsForUser for application/json ContentType.
type CREATEConfirmationOfFundsForUserJSONRequestBody = ConfirmationOfFunds

// CREATEIpForUserCredentialPasswordIpJSONRequestBody defines body for CREATEIpForUserCredentialPasswordIp for application/json ContentType.
type CREATEIpForUserCredentialPasswordIpJSONRequestBody = PermittedIp

// UPDATEIpForUserCredentialPasswordIpJSONRequestBody defines body for UPDATEIpForUserCredentialPasswordIp for application/json ContentType.
type UPDATEIpForUserCredentialPasswordIpJSONRequestBody = PermittedIp

// CREATECurrencyCloudBeneficiaryForUserJSONRequestBody defines body for CREATECurrencyCloudBeneficiaryForUser for application/json ContentType.
type CREATECurrencyCloudBeneficiaryForUserJSONRequestBody = CurrencyCloudBeneficiary

// CREATEExportAnnualOverviewForUserJSONRequestBody defines body for CREATEExportAnnualOverviewForUser for application/json ContentType.
type CREATEExportAnnualOverviewForUserJSONRequestBody = ExportAnnualOverview

// CREATEInvoiceExportForUserInvoiceJSONRequestBody defines body for CREATEInvoiceExportForUserInvoice for application/json ContentType.
type CREATEInvoiceExportForUserInvoiceJSONRequestBody = InvoiceExportPdf

// UPDATEInvoiceExportForUserInvoiceJSONRequestBody defines body for UPDATEInvoiceExportForUserInvoice for application/json ContentType.
type UPDATEInvoiceExportForUserInvoiceJSONRequestBody = InvoiceExportPdf

// CREATEMonetaryAccountBankForUserJSONRequestBody defines body for CREATEMonetaryAccountBankForUser for application/json ContentType.
type CREATEMonetaryAccountBankForUserJSONRequestBody = MonetaryAccountBank

// UPDATEMonetaryAccountBankForUserJSONRequestBody defines body for UPDATEMonetaryAccountBankForUser for application/json ContentType.
type UPDATEMonetaryAccountBankForUserJSONRequestBody = MonetaryAccountBank

// UPDATEMonetaryAccountCardForUserJSONRequestBody defines body for UPDATEMonetaryAccountCardForUser for application/json ContentType.
type UPDATEMonetaryAccountCardForUserJSONRequestBody = MonetaryAccountCard

// CREATEMonetaryAccountExternalForUserJSONRequestBody defines body for CREATEMonetaryAccountExternalForUser for application/json ContentType.
type CREATEMonetaryAccountExternalForUserJSONRequestBody = MonetaryAccountExternal

// CREATEMonetaryAccountExternalSavingsForUserJSONRequestBody defines body for CREATEMonetaryAccountExternalSavingsForUser for application/json ContentType.
type CREATEMonetaryAccountExternalSavingsForUserJSONRequestBody = MonetaryAccountExternalSavings

// UPDATEMonetaryAccountExternalSavingsForUserJSONRequestBody defines body for UPDATEMonetaryAccountExternalSavingsForUser for application/json ContentType.
type UPDATEMonetaryAccountExternalSavingsForUserJSONRequestBody = MonetaryAccountExternalSavings

// UPDATEMonetaryAccountExternalForUserJSONRequestBody defines body for UPDATEMonetaryAccountExternalForUser for application/json ContentType.
type UPDATEMonetaryAccountExternalForUserJSONRequestBody = MonetaryAccountExternal

// CREATEMonetaryAccountJointForUserJSONRequestBody defines body for CREATEMonetaryAccountJointForUser for application/json ContentType.
type CREATEMonetaryAccountJointForUserJSONRequestBody = MonetaryAccountJoint

// UPDATEMonetaryAccountJointForUserJSONRequestBody defines body for UPDATEMonetaryAccountJointForUser for application/json ContentType.
type UPDATEMonetaryAccountJointForUserJSONRequestBody = MonetaryAccountJoint

// CREATEMonetaryAccountSavingsForUserJSONRequestBody defines body for CREATEMonetaryAccountSavingsForUser for application/json ContentType.
type CREATEMonetaryAccountSavingsForUserJSONRequestBody = MonetaryAccountSavings

// UPDATEMonetaryAccountSavingsForUserJSONRequestBody defines body for UPDATEMonetaryAccountSavingsForUser for application/json ContentType.
type UPDATEMonetaryAccountSavingsForUserJSONRequestBody = MonetaryAccountSavings

// CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody = NoteAttachmentAdyenCardTransaction

// UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody = NoteAttachmentAdyenCardTransaction

// CREATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountAdyenCardTransaction for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody = NoteTextAdyenCardTransaction

// UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountAdyenCardTransaction for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody = NoteTextAdyenCardTransaction

// CREATEAttachmentForUserMonetaryAccountJSONRequestBody defines body for CREATEAttachmentForUserMonetaryAccount for application/json ContentType.
type CREATEAttachmentForUserMonetaryAccountJSONRequestBody = AttachmentMonetaryAccount

// CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody = NoteAttachmentBunqMeFundraiserResult

// UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody = NoteAttachmentBunqMeFundraiserResult

// CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResult for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody = NoteTextBunqMeFundraiserResult

// UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResult for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody = NoteTextBunqMeFundraiserResult

// CREATEBunqmeTabForUserMonetaryAccountJSONRequestBody defines body for CREATEBunqmeTabForUserMonetaryAccount for application/json ContentType.
type CREATEBunqmeTabForUserMonetaryAccountJSONRequestBody = BunqMeTab

// UPDATEBunqmeTabForUserMonetaryAccountJSONRequestBody defines body for UPDATEBunqmeTabForUserMonetaryAccount for application/json ContentType.
type UPDATEBunqmeTabForUserMonetaryAccountJSONRequestBody = BunqMeTab

// CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountJSONRequestBody defines body for CREATECurrencyCloudPaymentQuoteForUserMonetaryAccount for application/json ContentType.
type CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountJSONRequestBody = CurrencyCloudPaymentQuote

// CREATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody defines body for CREATECurrencyConversionQuoteForUserMonetaryAccount for application/json ContentType.
type CREATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody = CurrencyConversionQuote

// UPDATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody defines body for UPDATECurrencyConversionQuoteForUserMonetaryAccount for application/json ContentType.
type UPDATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody = CurrencyConversionQuote

// CREATECustomerStatementForUserMonetaryAccountJSONRequestBody defines body for CREATECustomerStatementForUserMonetaryAccount for application/json ContentType.
type CREATECustomerStatementForUserMonetaryAccountJSONRequestBody = ExportStatement

// CREATEDraftPaymentForUserMonetaryAccountJSONRequestBody defines body for CREATEDraftPaymentForUserMonetaryAccount for application/json ContentType.
type CREATEDraftPaymentForUserMonetaryAccountJSONRequestBody = DraftPayment

// CREATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountDraftPayment for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody = NoteAttachmentDraftPayment

// UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountDraftPayment for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody = NoteAttachmentDraftPayment

// CREATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountDraftPayment for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody = NoteTextDraftPayment

// UPDATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountDraftPayment for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody = NoteTextDraftPayment

// UPDATEDraftPaymentForUserMonetaryAccountJSONRequestBody defines body for UPDATEDraftPaymentForUserMonetaryAccount for application/json ContentType.
type UPDATEDraftPaymentForUserMonetaryAccountJSONRequestBody = DraftPayment

// CREATEStatementForUserMonetaryAccountEventJSONRequestBody defines body for CREATEStatementForUserMonetaryAccountEvent for application/json ContentType.
type CREATEStatementForUserMonetaryAccountEventJSONRequestBody = ExportStatementPayment

// CREATEExportRibForUserMonetaryAccountJSONRequestBody defines body for CREATEExportRibForUserMonetaryAccount for application/json ContentType.
type CREATEExportRibForUserMonetaryAccountJSONRequestBody = ExportRib

// CREATEIdealMerchantTransactionForUserMonetaryAccountJSONRequestBody defines body for CREATEIdealMerchantTransactionForUserMonetaryAccount for application/json ContentType.
type CREATEIdealMerchantTransactionForUserMonetaryAccountJSONRequestBody = IdealMerchantTransaction

// CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody = NoteAttachmentIdealMerchantTransaction

// UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody = NoteAttachmentIdealMerchantTransaction

// CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountIdealMerchantTransaction for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody = NoteTextIdealMerchantTransaction

// UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountIdealMerchantTransaction for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody = NoteTextIdealMerchantTransaction

// CREATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountMastercardAction for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody = NoteAttachmentMasterCardAction

// UPDATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountMastercardAction for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody = NoteAttachmentMasterCardAction

// CREATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountMastercardAction for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody = NoteTextMasterCardAction

// UPDATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountMastercardAction for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody = NoteTextMasterCardAction

// CREATENotificationFilterUrlForUserMonetaryAccountJSONRequestBody defines body for CREATENotificationFilterUrlForUserMonetaryAccount for application/json ContentType.
type CREATENotificationFilterUrlForUserMonetaryAccountJSONRequestBody = NotificationFilterUrlMonetaryAccount

// CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody = NoteAttachmentOpenBankingMerchantTransaction

// UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody = NoteAttachmentOpenBankingMerchantTransaction

// CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody = NoteTextOpenBankingMerchantTransaction

// UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody = NoteTextOpenBankingMerchantTransaction

// CREATEPaymentForUserMonetaryAccountJSONRequestBody defines body for CREATEPaymentForUserMonetaryAccount for application/json ContentType.
type CREATEPaymentForUserMonetaryAccountJSONRequestBody = CreatePayment

// CREATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody defines body for CREATEPaymentAutoAllocateForUserMonetaryAccount for application/json ContentType.
type CREATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody = PaymentAutoAllocate

// UPDATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody defines body for UPDATEPaymentAutoAllocateForUserMonetaryAccount for application/json ContentType.
type UPDATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody = PaymentAutoAllocate

// CREATEPaymentBatchForUserMonetaryAccountJSONRequestBody defines body for CREATEPaymentBatchForUserMonetaryAccount for application/json ContentType.
type CREATEPaymentBatchForUserMonetaryAccountJSONRequestBody = PaymentBatch

// UPDATEPaymentBatchForUserMonetaryAccountJSONRequestBody defines body for UPDATEPaymentBatchForUserMonetaryAccount for application/json ContentType.
type UPDATEPaymentBatchForUserMonetaryAccountJSONRequestBody = PaymentBatch

// CREATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountPaymentBatch for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody = NoteAttachmentPaymentBatch

// UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountPaymentBatch for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody = NoteAttachmentPaymentBatch

// CREATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountPaymentBatch for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody = NoteTextPaymentBatch

// UPDATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountPaymentBatch for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody = NoteTextPaymentBatch

// CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountPaymentDelayed for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody = NoteAttachmentPaymentDelayed

// UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayed for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody = NoteAttachmentPaymentDelayed

// CREATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountPaymentDelayed for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody = NoteTextPaymentDelayed

// UPDATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountPaymentDelayed for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody = NoteTextPaymentDelayed

// CREATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountPayment for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody = NoteAttachmentPayment

// UPDATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountPayment for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody = NoteAttachmentPayment

// CREATENoteTextForUserMonetaryAccountPaymentJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountPayment for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountPaymentJSONRequestBody = NoteTextPayment

// UPDATENoteTextForUserMonetaryAccountPaymentJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountPayment for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountPaymentJSONRequestBody = NoteTextPayment

// CREATERequestInquiryForUserMonetaryAccountJSONRequestBody defines body for CREATERequestInquiryForUserMonetaryAccount for application/json ContentType.
type CREATERequestInquiryForUserMonetaryAccountJSONRequestBody = RequestInquiry

// CREATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody defines body for CREATERequestInquiryBatchForUserMonetaryAccount for application/json ContentType.
type CREATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody = RequestInquiryBatch

// UPDATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody defines body for UPDATERequestInquiryBatchForUserMonetaryAccount for application/json ContentType.
type UPDATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody = RequestInquiryBatch

// CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody = NoteAttachmentRequestInquiryBatch

// UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody = NoteAttachmentRequestInquiryBatch

// CREATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountRequestInquiryBatch for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody = NoteTextRequestInquiryBatch

// UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountRequestInquiryBatch for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody = NoteTextRequestInquiryBatch

// UPDATERequestInquiryForUserMonetaryAccountJSONRequestBody defines body for UPDATERequestInquiryForUserMonetaryAccount for application/json ContentType.
type UPDATERequestInquiryForUserMonetaryAccountJSONRequestBody = RequestInquiry

// CREATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountRequestInquiry for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody = NoteAttachmentRequestInquiry

// UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountRequestInquiry for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody = NoteAttachmentRequestInquiry

// CREATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountRequestInquiry for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody = NoteTextRequestInquiry

// UPDATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountRequestInquiry for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody = NoteTextRequestInquiry

// UPDATERequestResponseForUserMonetaryAccountJSONRequestBody defines body for UPDATERequestResponseForUserMonetaryAccount for application/json ContentType.
type UPDATERequestResponseForUserMonetaryAccountJSONRequestBody = RequestResponse

// CREATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountRequestResponse for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody = NoteAttachmentRequestResponse

// UPDATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountRequestResponse for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody = NoteAttachmentRequestResponse

// CREATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountRequestResponse for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody = NoteTextRequestResponse

// UPDATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountRequestResponse for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody = NoteTextRequestResponse

// CREATESchedulePaymentForUserMonetaryAccountJSONRequestBody defines body for CREATESchedulePaymentForUserMonetaryAccount for application/json ContentType.
type CREATESchedulePaymentForUserMonetaryAccountJSONRequestBody = SchedulePayment

// CREATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody defines body for CREATESchedulePaymentBatchForUserMonetaryAccount for application/json ContentType.
type CREATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody = SchedulePaymentBatch

// UPDATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody defines body for UPDATESchedulePaymentBatchForUserMonetaryAccount for application/json ContentType.
type UPDATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody = SchedulePaymentBatch

// CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody = NoteAttachmentSchedulePaymentBatch

// UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody = NoteAttachmentSchedulePaymentBatch

// CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountSchedulePaymentBatch for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody = NoteTextSchedulePaymentBatch

// UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatch for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody = NoteTextSchedulePaymentBatch

// UPDATESchedulePaymentForUserMonetaryAccountJSONRequestBody defines body for UPDATESchedulePaymentForUserMonetaryAccount for application/json ContentType.
type UPDATESchedulePaymentForUserMonetaryAccountJSONRequestBody = SchedulePayment

// CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountSchedulePayment for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody = NoteAttachmentSchedulePayment

// UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountSchedulePayment for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody = NoteAttachmentSchedulePayment

// CREATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountSchedulePayment for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody = NoteTextSchedulePayment

// UPDATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountSchedulePayment for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody = NoteTextSchedulePayment

// CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody = NoteAttachmentScheduleRequestBatch

// UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody = NoteAttachmentScheduleRequestBatch

// CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody = NoteTextScheduleRequestBatch

// UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody = NoteTextScheduleRequestBatch

// CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody = NoteAttachmentScheduleRequest

// UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody = NoteAttachmentScheduleRequest

// CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountScheduleRequestInquiry for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody = NoteTextScheduleRequest

// UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiry for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody = NoteTextScheduleRequest

// UPDATEScheduleInstanceForUserMonetaryAccountScheduleJSONRequestBody defines body for UPDATEScheduleInstanceForUserMonetaryAccountSchedule for application/json ContentType.
type UPDATEScheduleInstanceForUserMonetaryAccountScheduleJSONRequestBody = ScheduleInstance

// CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody = NoteAttachmentScheduleInstance

// UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody = NoteAttachmentScheduleInstance

// CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountScheduleScheduleInstance for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody = NoteTextScheduleInstance

// UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstance for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody = NoteTextScheduleInstance

// CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody defines body for CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount for application/json ContentType.
type CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody = ShareInviteMonetaryAccountInquiry

// UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody defines body for UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount for application/json ContentType.
type UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody = ShareInviteMonetaryAccountInquiry

// CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody = NoteAttachmentSofortMerchantTransaction

// UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody = NoteAttachmentSofortMerchantTransaction

// CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountSofortMerchantTransaction for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody = NoteTextSofortMerchantTransaction

// UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountSofortMerchantTransaction for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody = NoteTextSofortMerchantTransaction

// CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountSwitchServicePayment for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody = NoteAttachmentBankSwitchServiceNetherlandsIncomingPayment

// UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePayment for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody = NoteAttachmentBankSwitchServiceNetherlandsIncomingPayment

// CREATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountSwitchServicePayment for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody = NoteTextBankSwitchServiceNetherlandsIncomingPayment

// UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountSwitchServicePayment for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody = NoteTextBankSwitchServiceNetherlandsIncomingPayment

// CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody defines body for CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult for application/json ContentType.
type CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody = NoteAttachmentWhitelistResult

// UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody defines body for UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult for application/json ContentType.
type UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody = NoteAttachmentWhitelistResult

// CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody defines body for CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResult for application/json ContentType.
type CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody = NoteTextWhitelistResult

// UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody defines body for UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResult for application/json ContentType.
type UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody = NoteTextWhitelistResult

// CREATENotificationFilterEmailForUserJSONRequestBody defines body for CREATENotificationFilterEmailForUser for application/json ContentType.
type CREATENotificationFilterEmailForUserJSONRequestBody = NotificationFilterEmail

// CREATENotificationFilterFailureForUserJSONRequestBody defines body for CREATENotificationFilterFailureForUser for application/json ContentType.
type CREATENotificationFilterFailureForUserJSONRequestBody = NotificationFilterFailure

// CREATENotificationFilterPushForUserJSONRequestBody defines body for CREATENotificationFilterPushForUser for application/json ContentType.
type CREATENotificationFilterPushForUserJSONRequestBody = NotificationFilterPush

// CREATENotificationFilterUrlForUserJSONRequestBody defines body for CREATENotificationFilterUrlForUser for application/json ContentType.
type CREATENotificationFilterUrlForUserJSONRequestBody = NotificationFilterUrl

// CREATEOauthClientForUserJSONRequestBody defines body for CREATEOauthClientForUser for application/json ContentType.
type CREATEOauthClientForUserJSONRequestBody = OauthClient

// UPDATEOauthClientForUserJSONRequestBody defines body for UPDATEOauthClientForUser for application/json ContentType.
type UPDATEOauthClientForUserJSONRequestBody = OauthClient

// CREATECallbackUrlForUserOauthClientJSONRequestBody defines body for CREATECallbackUrlForUserOauthClient for application/json ContentType.
type CREATECallbackUrlForUserOauthClientJSONRequestBody = OauthCallbackUrl

// UPDATECallbackUrlForUserOauthClientJSONRequestBody defines body for UPDATECallbackUrlForUserOauthClient for application/json ContentType.
type UPDATECallbackUrlForUserOauthClientJSONRequestBody = OauthCallbackUrl

// CREATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody defines body for CREATEPaymentServiceProviderDraftPaymentForUser for application/json ContentType.
type CREATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody = PaymentServiceProviderDraftPayment

// UPDATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody defines body for UPDATEPaymentServiceProviderDraftPaymentForUser for application/json ContentType.
type UPDATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody = PaymentServiceProviderDraftPayment

// CREATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody defines body for CREATEPaymentServiceProviderIssuerTransactionForUser for application/json ContentType.
type CREATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody = PaymentServiceProviderIssuerTransaction

// UPDATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody defines body for UPDATEPaymentServiceProviderIssuerTransactionForUser for application/json ContentType.
type UPDATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody = PaymentServiceProviderIssuerTransaction

// UPDATEShareInviteMonetaryAccountResponseForUserJSONRequestBody defines body for UPDATEShareInviteMonetaryAccountResponseForUser for application/json ContentType.
type UPDATEShareInviteMonetaryAccountResponseForUserJSONRequestBody = ShareInviteMonetaryAccountResponse

// CREATETokenQrRequestIdealForUserJSONRequestBody defines body for CREATETokenQrRequestIdealForUser for application/json ContentType.
type CREATETokenQrRequestIdealForUserJSONRequestBody = TokenQrRequestIdeal

// CREATETokenQrRequestSofortForUserJSONRequestBody defines body for CREATETokenQrRequestSofortForUser for application/json ContentType.
type CREATETokenQrRequestSofortForUserJSONRequestBody = TokenQrRequestSofort

// CREATETransferwiseQuoteForUserJSONRequestBody defines body for CREATETransferwiseQuoteForUser for application/json ContentType.
type CREATETransferwiseQuoteForUserJSONRequestBody = TransferwiseQuote

// CREATETransferwiseQuoteTemporaryForUserJSONRequestBody defines body for CREATETransferwiseQuoteTemporaryForUser for application/json ContentType.
type CREATETransferwiseQuoteTemporaryForUserJSONRequestBody = TransferwiseQuoteTemporary

// CREATETransferwiseRecipientForUserTransferwiseQuoteJSONRequestBody defines body for CREATETransferwiseRecipientForUserTransferwiseQuote for application/json ContentType.
type CREATETransferwiseRecipientForUserTransferwiseQuoteJSONRequestBody = TransferwiseAccountQuote

// CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteJSONRequestBody defines body for CREATETransferwiseRecipientRequirementForUserTransferwiseQuote for application/json ContentType.
type CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteJSONRequestBody = TransferwiseAccountRequirement

// CREATETransferwiseTransferForUserTransferwiseQuoteJSONRequestBody defines body for CREATETransferwiseTransferForUserTransferwiseQuote for application/json ContentType.
type CREATETransferwiseTransferForUserTransferwiseQuoteJSONRequestBody = TransferwiseTransfer

// CREATETransferwiseTransferRequirementForUserTransferwiseQuoteJSONRequestBody defines body for CREATETransferwiseTransferRequirementForUserTransferwiseQuote for application/json ContentType.
type CREATETransferwiseTransferRequirementForUserTransferwiseQuoteJSONRequestBody = TransferwiseTransferRequirement

// CREATETransferwiseUserForUserJSONRequestBody defines body for CREATETransferwiseUserForUser for application/json ContentType.
type CREATETransferwiseUserForUserJSONRequestBody = TransferwiseUser

// CREATEWhitelistSddOneOffForUserJSONRequestBody defines body for CREATEWhitelistSddOneOffForUser for application/json ContentType.
type CREATEWhitelistSddOneOffForUserJSONRequestBody = WhitelistSddOneOff

// UPDATEWhitelistSddOneOffForUserJSONRequestBody defines body for UPDATEWhitelistSddOneOffForUser for application/json ContentType.
type UPDATEWhitelistSddOneOffForUserJSONRequestBody = WhitelistSddOneOff

// CREATEWhitelistSddRecurringForUserJSONRequestBody defines body for CREATEWhitelistSddRecurringForUser for application/json ContentType.
type CREATEWhitelistSddRecurringForUserJSONRequestBody = WhitelistSddRecurring

// UPDATEWhitelistSddRecurringForUserJSONRequestBody defines body for UPDATEWhitelistSddRecurringForUser for application/json ContentType.
type UPDATEWhitelistSddRecurringForUserJSONRequestBody = WhitelistSddRecurring

// The interface specification for the client above.
type ClientInterface interface {

	// CREATEAttachmentPublic request
	CREATEAttachmentPublic(ctx context.Context, apiKey string, params *CREATEAttachmentPublicParams, body CREATEAttachmentPublicJSONRequestBody, reqEditors ...RequestEditorFn) (Result[AttachmentPublicCreate], error)

	// ListAllContentForAttachmentPublic request
	ListAllContentForAttachmentPublic(ctx context.Context, apiKey string, attachmentPublicUUID string, params *ListAllContentForAttachmentPublicParams, reqEditors ...RequestEditorFn) (Result[[]AttachmentPublicContentListing], error)

	// READAttachmentPublic request
	READAttachmentPublic(ctx context.Context, apiKey string, itemId int, params *READAttachmentPublicParams, reqEditors ...RequestEditorFn) (Result[AttachmentPublicRead], error)

	// CREATEAvatar request
	CREATEAvatar(ctx context.Context, apiKey string, params *CREATEAvatarParams, body CREATEAvatarJSONRequestBody, reqEditors ...RequestEditorFn) (Result[AvatarCreate], error)

	// READAvatar request
	READAvatar(ctx context.Context, apiKey string, itemId int, params *READAvatarParams, reqEditors ...RequestEditorFn) (Result[AvatarRead], error)

	// ListAllDevice request
	ListAllDevice(ctx context.Context, apiKey string, params *ListAllDeviceParams, reqEditors ...RequestEditorFn) (Result[[]DeviceListing], error)

	// ListAllDeviceServer request
	ListAllDeviceServer(ctx context.Context, apiKey string, params *ListAllDeviceServerParams, reqEditors ...RequestEditorFn) (Result[[]DeviceServerListing], error)

	// CREATEDeviceServer request
	CREATEDeviceServer(ctx context.Context, apiKey string, params *CREATEDeviceServerParams, body CREATEDeviceServerJSONRequestBody, reqEditors ...RequestEditorFn) (Result[DeviceServerCreate], error)

	// READDeviceServer request
	READDeviceServer(ctx context.Context, apiKey string, itemId int, params *READDeviceServerParams, reqEditors ...RequestEditorFn) (Result[DeviceServerRead], error)

	// READDevice request
	READDevice(ctx context.Context, apiKey string, itemId int, params *READDeviceParams, reqEditors ...RequestEditorFn) (Result[DeviceRead], error)

	// ListAllInstallation request
	ListAllInstallation(ctx context.Context, apiKey string, params *ListAllInstallationParams, reqEditors ...RequestEditorFn) (Result[[]InstallationListing], error)

	// CREATEInstallation request
	CREATEInstallation(ctx context.Context, apiKey string, params *CREATEInstallationParams, body CREATEInstallationJSONRequestBody, reqEditors ...RequestEditorFn) (Result[[]InstallationCreate], error)

	// ListAllServerPublicKeyForInstallation request
	ListAllServerPublicKeyForInstallation(ctx context.Context, apiKey string, installationID int, params *ListAllServerPublicKeyForInstallationParams, reqEditors ...RequestEditorFn) (Result[[]InstallationServerPublicKeyListing], error)

	// READInstallation request
	READInstallation(ctx context.Context, apiKey string, itemId int, params *READInstallationParams, reqEditors ...RequestEditorFn) (Result[InstallationRead], error)

	// CREATEPaymentServiceProviderCredential request
	CREATEPaymentServiceProviderCredential(ctx context.Context, apiKey string, params *CREATEPaymentServiceProviderCredentialParams, body CREATEPaymentServiceProviderCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderCredentialCreate], error)

	// READPaymentServiceProviderCredential request
	READPaymentServiceProviderCredential(ctx context.Context, apiKey string, itemId int, params *READPaymentServiceProviderCredentialParams, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderCredentialRead], error)

	// CREATESandboxUserCompany request
	CREATESandboxUserCompany(ctx context.Context, apiKey string, params *CREATESandboxUserCompanyParams, body CREATESandboxUserCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (Result[SandboxUserCompanyCreate], error)

	// CREATESandboxUserPerson request
	CREATESandboxUserPerson(ctx context.Context, apiKey string, params *CREATESandboxUserPersonParams, body CREATESandboxUserPersonJSONRequestBody, reqEditors ...RequestEditorFn) (Result[SandboxUserPersonCreate], error)

	// CREATEServerError request
	CREATEServerError(ctx context.Context, apiKey string, params *CREATEServerErrorParams, body CREATEServerErrorJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ServerErrorCreate], error)

	// CREATESessionServer request
	CREATESessionServer(ctx context.Context, apiKey string, params *CREATESessionServerParams, body CREATESessionServerJSONRequestBody, reqEditors ...RequestEditorFn) (Result[[]SessionServerCreate], error)

	// DELETESession request
	DELETESession(ctx context.Context, apiKey string, itemId int, params *DELETESessionParams, reqEditors ...RequestEditorFn) (Result[SessionDelete], error)

	// ListAllUser request
	ListAllUser(ctx context.Context, apiKey string, params *ListAllUserParams, reqEditors ...RequestEditorFn) (Result[[]UserListing], error)

	// READUserCompany request
	READUserCompany(ctx context.Context, apiKey string, itemId int, params *READUserCompanyParams, reqEditors ...RequestEditorFn) (Result[UserCompanyRead], error)

	// UPDATEUserCompany request
	UPDATEUserCompany(ctx context.Context, apiKey string, itemId int, params *UPDATEUserCompanyParams, body UPDATEUserCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (Result[UserCompanyUpdate], error)

	// ListAllNameForUserCompany request
	ListAllNameForUserCompany(ctx context.Context, apiKey string, userCompanyID int, params *ListAllNameForUserCompanyParams, reqEditors ...RequestEditorFn) (Result[[]UserCompanyNameListing], error)

	// READUserPaymentServiceProvider request
	READUserPaymentServiceProvider(ctx context.Context, apiKey string, itemId int, params *READUserPaymentServiceProviderParams, reqEditors ...RequestEditorFn) (Result[UserPaymentServiceProviderRead], error)

	// READUserPerson request
	READUserPerson(ctx context.Context, apiKey string, itemId int, params *READUserPersonParams, reqEditors ...RequestEditorFn) (Result[UserPersonRead], error)

	// UPDATEUserPerson request
	UPDATEUserPerson(ctx context.Context, apiKey string, itemId int, params *UPDATEUserPersonParams, body UPDATEUserPersonJSONRequestBody, reqEditors ...RequestEditorFn) (Result[UserPersonUpdate], error)

	// READUser request
	READUser(ctx context.Context, apiKey string, itemId int, params *READUserParams, reqEditors ...RequestEditorFn) (Result[UserRead], error)

	// ListAllAdditionalTransactionInformationCategoryForUser request
	ListAllAdditionalTransactionInformationCategoryForUser(ctx context.Context, apiKey string, userID int, params *ListAllAdditionalTransactionInformationCategoryForUserParams, reqEditors ...RequestEditorFn) (Result[[]AdditionalTransactionInformationCategoryListing], error)

	// CREATEAdditionalTransactionInformationCategoryUserDefinedForUser request
	CREATEAdditionalTransactionInformationCategoryUserDefinedForUser(ctx context.Context, apiKey string, userID int, params *CREATEAdditionalTransactionInformationCategoryUserDefinedForUserParams, body CREATEAdditionalTransactionInformationCategoryUserDefinedForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[AdditionalTransactionInformationCategoryUserDefinedCreate], error)

	// ListAllContentForUserAttachment request
	ListAllContentForUserAttachment(ctx context.Context, apiKey string, userID int, attachmentID int, params *ListAllContentForUserAttachmentParams, reqEditors ...RequestEditorFn) (Result[[]AttachmentUserContentListing], error)

	// READAttachmentForUser request
	READAttachmentForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READAttachmentForUserParams, reqEditors ...RequestEditorFn) (Result[AttachmentUserRead], error)

	// ListAllBillingContractSubscriptionForUser request
	ListAllBillingContractSubscriptionForUser(ctx context.Context, apiKey string, userID int, params *ListAllBillingContractSubscriptionForUserParams, reqEditors ...RequestEditorFn) (Result[[]BillingContractSubscriptionListing], error)

	// ListAllBunqmeFundraiserProfileForUser request
	ListAllBunqmeFundraiserProfileForUser(ctx context.Context, apiKey string, userID int, params *ListAllBunqmeFundraiserProfileForUserParams, reqEditors ...RequestEditorFn) (Result[[]BunqMeFundraiserProfileUserListing], error)

	// READBunqmeFundraiserProfileForUser request
	READBunqmeFundraiserProfileForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READBunqmeFundraiserProfileForUserParams, reqEditors ...RequestEditorFn) (Result[BunqMeFundraiserProfileUserRead], error)

	// ListAllCardForUser request
	ListAllCardForUser(ctx context.Context, apiKey string, userID int, params *ListAllCardForUserParams, reqEditors ...RequestEditorFn) (Result[[]CardListing], error)

	// CREATECardBatchForUser request
	CREATECardBatchForUser(ctx context.Context, apiKey string, userID int, params *CREATECardBatchForUserParams, body CREATECardBatchForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardBatchCreate], error)

	// CREATECardBatchReplaceForUser request
	CREATECardBatchReplaceForUser(ctx context.Context, apiKey string, userID int, params *CREATECardBatchReplaceForUserParams, body CREATECardBatchReplaceForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardBatchReplaceCreate], error)

	// CREATECardCreditForUser request
	CREATECardCreditForUser(ctx context.Context, apiKey string, userID int, params *CREATECardCreditForUserParams, body CREATECardCreditForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardCreditCreate], error)

	// CREATECardDebitForUser request
	CREATECardDebitForUser(ctx context.Context, apiKey string, userID int, params *CREATECardDebitForUserParams, body CREATECardDebitForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardDebitCreate], error)

	// ListAllCardNameForUser request
	ListAllCardNameForUser(ctx context.Context, apiKey string, userID int, params *ListAllCardNameForUserParams, reqEditors ...RequestEditorFn) (Result[[]CardNameListing], error)

	// ListAllExportStatementCardForUserCard request
	ListAllExportStatementCardForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllExportStatementCardForUserCardParams, reqEditors ...RequestEditorFn) (Result[[]ExportStatementCardListing], error)

	// ListAllExportStatementCardCsvForUserCard request
	ListAllExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllExportStatementCardCsvForUserCardParams, reqEditors ...RequestEditorFn) (Result[[]ExportStatementCardCsvListing], error)

	// CREATEExportStatementCardCsvForUserCard request
	CREATEExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEExportStatementCardCsvForUserCardParams, body CREATEExportStatementCardCsvForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ExportStatementCardCsvCreate], error)

	// DELETEExportStatementCardCsvForUserCard request
	DELETEExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *DELETEExportStatementCardCsvForUserCardParams, reqEditors ...RequestEditorFn) (Result[ExportStatementCardCsvDelete], error)

	// READExportStatementCardCsvForUserCard request
	READExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READExportStatementCardCsvForUserCardParams, reqEditors ...RequestEditorFn) (Result[ExportStatementCardCsvRead], error)

	// ListAllExportStatementCardPdfForUserCard request
	ListAllExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllExportStatementCardPdfForUserCardParams, reqEditors ...RequestEditorFn) (Result[[]ExportStatementCardPdfListing], error)

	// CREATEExportStatementCardPdfForUserCard request
	CREATEExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEExportStatementCardPdfForUserCardParams, body CREATEExportStatementCardPdfForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ExportStatementCardPdfCreate], error)

	// DELETEExportStatementCardPdfForUserCard request
	DELETEExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *DELETEExportStatementCardPdfForUserCardParams, reqEditors ...RequestEditorFn) (Result[ExportStatementCardPdfDelete], error)

	// READExportStatementCardPdfForUserCard request
	READExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READExportStatementCardPdfForUserCardParams, reqEditors ...RequestEditorFn) (Result[ExportStatementCardPdfRead], error)

	// ListAllContentForUserCardExportStatementCard request
	ListAllContentForUserCardExportStatementCard(ctx context.Context, apiKey string, userID int, cardID int, exportStatementCardID int, params *ListAllContentForUserCardExportStatementCardParams, reqEditors ...RequestEditorFn) (Result[[]ExportStatementCardContentListing], error)

	// READExportStatementCardForUserCard request
	READExportStatementCardForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READExportStatementCardForUserCardParams, reqEditors ...RequestEditorFn) (Result[ExportStatementCardRead], error)

	// ListAllGeneratedCvc2ForUserCard request
	ListAllGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllGeneratedCvc2ForUserCardParams, reqEditors ...RequestEditorFn) (Result[[]CardGeneratedCvc2Listing], error)

	// CREATEGeneratedCvc2ForUserCard request
	CREATEGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEGeneratedCvc2ForUserCardParams, body CREATEGeneratedCvc2ForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardGeneratedCvc2Create], error)

	// READGeneratedCvc2ForUserCard request
	READGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READGeneratedCvc2ForUserCardParams, reqEditors ...RequestEditorFn) (Result[CardGeneratedCvc2Read], error)

	// UPDATEGeneratedCvc2ForUserCard request
	UPDATEGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *UPDATEGeneratedCvc2ForUserCardParams, body UPDATEGeneratedCvc2ForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardGeneratedCvc2Update], error)

	// CREATEReplaceForUserCard request
	CREATEReplaceForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEReplaceForUserCardParams, body CREATEReplaceForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardReplaceCreate], error)

	// READCardForUser request
	READCardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCardForUserParams, reqEditors ...RequestEditorFn) (Result[CardRead], error)

	// UPDATECardForUser request
	UPDATECardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATECardForUserParams, body UPDATECardForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CardUpdate], error)

	// ListAllCertificatePinnedForUser request
	ListAllCertificatePinnedForUser(ctx context.Context, apiKey string, userID int, params *ListAllCertificatePinnedForUserParams, reqEditors ...RequestEditorFn) (Result[[]CertificatePinnedListing], error)

	// CREATECertificatePinnedForUser request
	CREATECertificatePinnedForUser(ctx context.Context, apiKey string, userID int, params *CREATECertificatePinnedForUserParams, body CREATECertificatePinnedForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CertificatePinnedCreate], error)

	// DELETECertificatePinnedForUser request
	DELETECertificatePinnedForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETECertificatePinnedForUserParams, reqEditors ...RequestEditorFn) (Result[CertificatePinnedDelete], error)

	// READCertificatePinnedForUser request
	READCertificatePinnedForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCertificatePinnedForUserParams, reqEditors ...RequestEditorFn) (Result[CertificatePinnedRead], error)

	// READChallengeRequestForUser request
	READChallengeRequestForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READChallengeRequestForUserParams, reqEditors ...RequestEditorFn) (Result[MasterCardIdentityCheckChallengeRequestUserRead], error)

	// UPDATEChallengeRequestForUser request
	UPDATEChallengeRequestForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEChallengeRequestForUserParams, body UPDATEChallengeRequestForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MasterCardIdentityCheckChallengeRequestUserUpdate], error)

	// ListAllContentForUserChatConversationAttachment request
	ListAllContentForUserChatConversationAttachment(ctx context.Context, apiKey string, userID int, chatConversationID int, attachmentID int, params *ListAllContentForUserChatConversationAttachmentParams, reqEditors ...RequestEditorFn) (Result[[]AttachmentConversationContentListing], error)

	// ListAllCompanyForUser request
	ListAllCompanyForUser(ctx context.Context, apiKey string, userID int, params *ListAllCompanyForUserParams, reqEditors ...RequestEditorFn) (Result[[]CompanyListing], error)

	// CREATECompanyForUser request
	CREATECompanyForUser(ctx context.Context, apiKey string, userID int, params *CREATECompanyForUserParams, body CREATECompanyForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CompanyCreate], error)

	// READCompanyForUser request
	READCompanyForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCompanyForUserParams, reqEditors ...RequestEditorFn) (Result[CompanyRead], error)

	// UPDATECompanyForUser request
	UPDATECompanyForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATECompanyForUserParams, body UPDATECompanyForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CompanyUpdate], error)

	// CREATEConfirmationOfFundsForUser request
	CREATEConfirmationOfFundsForUser(ctx context.Context, apiKey string, userID int, params *CREATEConfirmationOfFundsForUserParams, body CREATEConfirmationOfFundsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ConfirmationOfFundsCreate], error)

	// ListAllCredentialPasswordIpForUser request
	ListAllCredentialPasswordIpForUser(ctx context.Context, apiKey string, userID int, params *ListAllCredentialPasswordIpForUserParams, reqEditors ...RequestEditorFn) (Result[[]UserCredentialPasswordIpListing], error)

	// ListAllIpForUserCredentialPasswordIp request
	ListAllIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, params *ListAllIpForUserCredentialPasswordIpParams, reqEditors ...RequestEditorFn) (Result[[]PermittedIpListing], error)

	// CREATEIpForUserCredentialPasswordIp request
	CREATEIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, params *CREATEIpForUserCredentialPasswordIpParams, body CREATEIpForUserCredentialPasswordIpJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PermittedIpCreate], error)

	// READIpForUserCredentialPasswordIp request
	READIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, itemId int, params *READIpForUserCredentialPasswordIpParams, reqEditors ...RequestEditorFn) (Result[PermittedIpRead], error)

	// UPDATEIpForUserCredentialPasswordIp request
	UPDATEIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, itemId int, params *UPDATEIpForUserCredentialPasswordIpParams, body UPDATEIpForUserCredentialPasswordIpJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PermittedIpUpdate], error)

	// READCredentialPasswordIpForUser request
	READCredentialPasswordIpForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCredentialPasswordIpForUserParams, reqEditors ...RequestEditorFn) (Result[UserCredentialPasswordIpRead], error)

	// ListAllCurrencyCloudBeneficiaryForUser request
	ListAllCurrencyCloudBeneficiaryForUser(ctx context.Context, apiKey string, userID int, params *ListAllCurrencyCloudBeneficiaryForUserParams, reqEditors ...RequestEditorFn) (Result[[]CurrencyCloudBeneficiaryListing], error)

	// CREATECurrencyCloudBeneficiaryForUser request
	CREATECurrencyCloudBeneficiaryForUser(ctx context.Context, apiKey string, userID int, params *CREATECurrencyCloudBeneficiaryForUserParams, body CREATECurrencyCloudBeneficiaryForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CurrencyCloudBeneficiaryCreate], error)

	// ListAllCurrencyCloudBeneficiaryRequirementForUser request
	ListAllCurrencyCloudBeneficiaryRequirementForUser(ctx context.Context, apiKey string, userID int, params *ListAllCurrencyCloudBeneficiaryRequirementForUserParams, reqEditors ...RequestEditorFn) (Result[[]CurrencyCloudBeneficiaryRequirementListing], error)

	// READCurrencyCloudBeneficiaryForUser request
	READCurrencyCloudBeneficiaryForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCurrencyCloudBeneficiaryForUserParams, reqEditors ...RequestEditorFn) (Result[CurrencyCloudBeneficiaryRead], error)

	// ListAllEventForUser request
	ListAllEventForUser(ctx context.Context, apiKey string, userID int, params *ListAllEventForUserParams, reqEditors ...RequestEditorFn) (Result[[]EventListing], error)

	// READEventForUser request
	READEventForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READEventForUserParams, reqEditors ...RequestEditorFn) (Result[EventRead], error)

	// ListAllExportAnnualOverviewForUser request
	ListAllExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, params *ListAllExportAnnualOverviewForUserParams, reqEditors ...RequestEditorFn) (Result[[]ExportAnnualOverviewListing], error)

	// CREATEExportAnnualOverviewForUser request
	CREATEExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, params *CREATEExportAnnualOverviewForUserParams, body CREATEExportAnnualOverviewForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ExportAnnualOverviewCreate], error)

	// ListAllContentForUserExportAnnualOverview request
	ListAllContentForUserExportAnnualOverview(ctx context.Context, apiKey string, userID int, exportAnnualOverviewID int, params *ListAllContentForUserExportAnnualOverviewParams, reqEditors ...RequestEditorFn) (Result[[]ExportAnnualOverviewContentListing], error)

	// DELETEExportAnnualOverviewForUser request
	DELETEExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETEExportAnnualOverviewForUserParams, reqEditors ...RequestEditorFn) (Result[ExportAnnualOverviewDelete], error)

	// READExportAnnualOverviewForUser request
	READExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READExportAnnualOverviewForUserParams, reqEditors ...RequestEditorFn) (Result[ExportAnnualOverviewRead], error)

	// READFeatureAnnouncementForUser request
	READFeatureAnnouncementForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READFeatureAnnouncementForUserParams, reqEditors ...RequestEditorFn) (Result[FeatureAnnouncementRead], error)

	// ListAllInsightPreferenceDateForUser request
	ListAllInsightPreferenceDateForUser(ctx context.Context, apiKey string, userID int, params *ListAllInsightPreferenceDateForUserParams, reqEditors ...RequestEditorFn) (Result[[]InsightPreferenceDateListing], error)

	// ListAllInsightsForUser request
	ListAllInsightsForUser(ctx context.Context, apiKey string, userID int, params *ListAllInsightsForUserParams, reqEditors ...RequestEditorFn) (Result[[]InsightListing], error)

	// ListAllInsightsSearchForUser request
	ListAllInsightsSearchForUser(ctx context.Context, apiKey string, userID int, params *ListAllInsightsSearchForUserParams, reqEditors ...RequestEditorFn) (Result[[]InsightEventListing], error)

	// ListAllInvoiceForUser request
	ListAllInvoiceForUser(ctx context.Context, apiKey string, userID int, params *ListAllInvoiceForUserParams, reqEditors ...RequestEditorFn) (Result[[]InvoiceByUserListing], error)

	// CREATEInvoiceExportForUserInvoice request
	CREATEInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, params *CREATEInvoiceExportForUserInvoiceParams, body CREATEInvoiceExportForUserInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (Result[InvoiceExportPdfCreate], error)

	// DELETEInvoiceExportForUserInvoice request
	DELETEInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, itemId int, params *DELETEInvoiceExportForUserInvoiceParams, reqEditors ...RequestEditorFn) (Result[InvoiceExportPdfDelete], error)

	// READInvoiceExportForUserInvoice request
	READInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, itemId int, params *READInvoiceExportForUserInvoiceParams, reqEditors ...RequestEditorFn) (Result[InvoiceExportPdfRead], error)

	// UPDATEInvoiceExportForUserInvoice request
	UPDATEInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, itemId int, params *UPDATEInvoiceExportForUserInvoiceParams, body UPDATEInvoiceExportForUserInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (Result[InvoiceExportPdfUpdate], error)

	// ListAllPdfContentForUserInvoice request
	ListAllPdfContentForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, params *ListAllPdfContentForUserInvoiceParams, reqEditors ...RequestEditorFn) (Result[[]InvoiceExportPdfContentListing], error)

	// READInvoiceForUser request
	READInvoiceForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READInvoiceForUserParams, reqEditors ...RequestEditorFn) (Result[InvoiceByUserRead], error)

	// ListAllLegalNameForUser request
	ListAllLegalNameForUser(ctx context.Context, apiKey string, userID int, params *ListAllLegalNameForUserParams, reqEditors ...RequestEditorFn) (Result[[]UserLegalNameListing], error)

	// ListAllLimitForUser request
	ListAllLimitForUser(ctx context.Context, apiKey string, userID int, params *ListAllLimitForUserParams, reqEditors ...RequestEditorFn) (Result[[]CustomerLimitListing], error)

	// ListAllMonetaryAccountForUser request
	ListAllMonetaryAccountForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountForUserParams, reqEditors ...RequestEditorFn) (Result[[]MonetaryAccountListing], error)

	// ListAllMonetaryAccountBankForUser request
	ListAllMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountBankForUserParams, reqEditors ...RequestEditorFn) (Result[[]MonetaryAccountBankListing], error)

	// CREATEMonetaryAccountBankForUser request
	CREATEMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountBankForUserParams, body CREATEMonetaryAccountBankForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountBankCreate], error)

	// READMonetaryAccountBankForUser request
	READMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountBankForUserParams, reqEditors ...RequestEditorFn) (Result[MonetaryAccountBankRead], error)

	// UPDATEMonetaryAccountBankForUser request
	UPDATEMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountBankForUserParams, body UPDATEMonetaryAccountBankForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountBankUpdate], error)

	// ListAllMonetaryAccountCardForUser request
	ListAllMonetaryAccountCardForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountCardForUserParams, reqEditors ...RequestEditorFn) (Result[[]MonetaryAccountCardListing], error)

	// READMonetaryAccountCardForUser request
	READMonetaryAccountCardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountCardForUserParams, reqEditors ...RequestEditorFn) (Result[MonetaryAccountCardRead], error)

	// UPDATEMonetaryAccountCardForUser request
	UPDATEMonetaryAccountCardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountCardForUserParams, body UPDATEMonetaryAccountCardForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountCardUpdate], error)

	// ListAllMonetaryAccountExternalForUser request
	ListAllMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountExternalForUserParams, reqEditors ...RequestEditorFn) (Result[[]MonetaryAccountExternalListing], error)

	// CREATEMonetaryAccountExternalForUser request
	CREATEMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountExternalForUserParams, body CREATEMonetaryAccountExternalForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountExternalCreate], error)

	// ListAllMonetaryAccountExternalSavingsForUser request
	ListAllMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountExternalSavingsForUserParams, reqEditors ...RequestEditorFn) (Result[[]MonetaryAccountExternalSavingsListing], error)

	// CREATEMonetaryAccountExternalSavingsForUser request
	CREATEMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountExternalSavingsForUserParams, body CREATEMonetaryAccountExternalSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountExternalSavingsCreate], error)

	// READMonetaryAccountExternalSavingsForUser request
	READMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountExternalSavingsForUserParams, reqEditors ...RequestEditorFn) (Result[MonetaryAccountExternalSavingsRead], error)

	// UPDATEMonetaryAccountExternalSavingsForUser request
	UPDATEMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountExternalSavingsForUserParams, body UPDATEMonetaryAccountExternalSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountExternalSavingsUpdate], error)

	// READMonetaryAccountExternalForUser request
	READMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountExternalForUserParams, reqEditors ...RequestEditorFn) (Result[MonetaryAccountExternalRead], error)

	// UPDATEMonetaryAccountExternalForUser request
	UPDATEMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountExternalForUserParams, body UPDATEMonetaryAccountExternalForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountExternalUpdate], error)

	// ListAllMonetaryAccountJointForUser request
	ListAllMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountJointForUserParams, reqEditors ...RequestEditorFn) (Result[[]MonetaryAccountJointListing], error)

	// CREATEMonetaryAccountJointForUser request
	CREATEMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountJointForUserParams, body CREATEMonetaryAccountJointForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountJointCreate], error)

	// READMonetaryAccountJointForUser request
	READMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountJointForUserParams, reqEditors ...RequestEditorFn) (Result[MonetaryAccountJointRead], error)

	// UPDATEMonetaryAccountJointForUser request
	UPDATEMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountJointForUserParams, body UPDATEMonetaryAccountJointForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountJointUpdate], error)

	// ListAllMonetaryAccountSavingsForUser request
	ListAllMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountSavingsForUserParams, reqEditors ...RequestEditorFn) (Result[[]MonetaryAccountSavingsListing], error)

	// CREATEMonetaryAccountSavingsForUser request
	CREATEMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountSavingsForUserParams, body CREATEMonetaryAccountSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountSavingsCreate], error)

	// READMonetaryAccountSavingsForUser request
	READMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountSavingsForUserParams, reqEditors ...RequestEditorFn) (Result[MonetaryAccountSavingsRead], error)

	// UPDATEMonetaryAccountSavingsForUser request
	UPDATEMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountSavingsForUserParams, body UPDATEMonetaryAccountSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[MonetaryAccountSavingsUpdate], error)

	// READMonetaryAccountForUser request
	READMonetaryAccountForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountForUserParams, reqEditors ...RequestEditorFn) (Result[MonetaryAccountRead], error)

	// ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransaction request
	ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentAdyenCardTransactionListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction request
	CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentAdyenCardTransactionCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransaction request
	DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentAdyenCardTransactionDelete], error)

	// READNoteAttachmentForUserMonetaryAccountAdyenCardTransaction request
	READNoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentAdyenCardTransactionRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction request
	UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentAdyenCardTransactionUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountAdyenCardTransaction request
	ListAllNoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *ListAllNoteTextForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextAdyenCardTransactionListing], error)

	// CREATENoteTextForUserMonetaryAccountAdyenCardTransaction request
	CREATENoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, body CREATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextAdyenCardTransactionCreate], error)

	// DELETENoteTextForUserMonetaryAccountAdyenCardTransaction request
	DELETENoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextAdyenCardTransactionDelete], error)

	// READNoteTextForUserMonetaryAccountAdyenCardTransaction request
	READNoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextAdyenCardTransactionRead], error)

	// UPDATENoteTextForUserMonetaryAccountAdyenCardTransaction request
	UPDATENoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, body UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextAdyenCardTransactionUpdate], error)

	// CREATEAttachmentForUserMonetaryAccount request
	CREATEAttachmentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEAttachmentForUserMonetaryAccountParams, body CREATEAttachmentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[AttachmentMonetaryAccountCreate], error)

	// ListAllContentForUserMonetaryAccountAttachment request
	ListAllContentForUserMonetaryAccountAttachment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, attachmentID int, params *ListAllContentForUserMonetaryAccountAttachmentParams, reqEditors ...RequestEditorFn) (Result[[]AttachmentMonetaryAccountContentListing], error)

	// ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult request
	ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentBunqMeFundraiserResultListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult request
	CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, body CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBunqMeFundraiserResultCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult request
	DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBunqMeFundraiserResultDelete], error)

	// READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult request
	READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBunqMeFundraiserResultRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult request
	UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, body UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBunqMeFundraiserResultUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResult request
	ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextBunqMeFundraiserResultListing], error)

	// CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResult request
	CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, body CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextBunqMeFundraiserResultCreate], error)

	// DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResult request
	DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (Result[NoteTextBunqMeFundraiserResultDelete], error)

	// READNoteTextForUserMonetaryAccountBunqmeFundraiserResult request
	READNoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *READNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (Result[NoteTextBunqMeFundraiserResultRead], error)

	// UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResult request
	UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, body UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextBunqMeFundraiserResultUpdate], error)

	// READBunqmeFundraiserResultForUserMonetaryAccount request
	READBunqmeFundraiserResultForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READBunqmeFundraiserResultForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[BunqMeFundraiserResultRead], error)

	// ListAllBunqmeTabForUserMonetaryAccount request
	ListAllBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllBunqmeTabForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]BunqMeTabListing], error)

	// CREATEBunqmeTabForUserMonetaryAccount request
	CREATEBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEBunqmeTabForUserMonetaryAccountParams, body CREATEBunqmeTabForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[BunqMeTabCreate], error)

	// READBunqmeTabResultResponseForUserMonetaryAccount request
	READBunqmeTabResultResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READBunqmeTabResultResponseForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[BunqMeTabResultResponseRead], error)

	// READBunqmeTabForUserMonetaryAccount request
	READBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READBunqmeTabForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[BunqMeTabRead], error)

	// UPDATEBunqmeTabForUserMonetaryAccount request
	UPDATEBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEBunqmeTabForUserMonetaryAccountParams, body UPDATEBunqmeTabForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[BunqMeTabUpdate], error)

	// CREATECurrencyCloudPaymentQuoteForUserMonetaryAccount request
	CREATECurrencyCloudPaymentQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountParams, body CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CurrencyCloudPaymentQuoteCreate], error)

	// ListAllCurrencyConversionForUserMonetaryAccount request
	ListAllCurrencyConversionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllCurrencyConversionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]CurrencyConversionListing], error)

	// CREATECurrencyConversionQuoteForUserMonetaryAccount request
	CREATECurrencyConversionQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATECurrencyConversionQuoteForUserMonetaryAccountParams, body CREATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CurrencyConversionQuoteCreate], error)

	// READCurrencyConversionQuoteForUserMonetaryAccount request
	READCurrencyConversionQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READCurrencyConversionQuoteForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[CurrencyConversionQuoteRead], error)

	// UPDATECurrencyConversionQuoteForUserMonetaryAccount request
	UPDATECurrencyConversionQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATECurrencyConversionQuoteForUserMonetaryAccountParams, body UPDATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[CurrencyConversionQuoteUpdate], error)

	// READCurrencyConversionForUserMonetaryAccount request
	READCurrencyConversionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READCurrencyConversionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[CurrencyConversionRead], error)

	// ListAllCustomerStatementForUserMonetaryAccount request
	ListAllCustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllCustomerStatementForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]ExportStatementListing], error)

	// CREATECustomerStatementForUserMonetaryAccount request
	CREATECustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATECustomerStatementForUserMonetaryAccountParams, body CREATECustomerStatementForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ExportStatementCreate], error)

	// ListAllContentForUserMonetaryAccountCustomerStatement request
	ListAllContentForUserMonetaryAccountCustomerStatement(ctx context.Context, apiKey string, userID int, monetaryAccountID int, customerStatementID int, params *ListAllContentForUserMonetaryAccountCustomerStatementParams, reqEditors ...RequestEditorFn) (Result[[]ExportStatementContentListing], error)

	// DELETECustomerStatementForUserMonetaryAccount request
	DELETECustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETECustomerStatementForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[ExportStatementDelete], error)

	// READCustomerStatementForUserMonetaryAccount request
	READCustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READCustomerStatementForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[ExportStatementRead], error)

	// ListAllDraftPaymentForUserMonetaryAccount request
	ListAllDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllDraftPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]DraftPaymentListing], error)

	// CREATEDraftPaymentForUserMonetaryAccount request
	CREATEDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEDraftPaymentForUserMonetaryAccountParams, body CREATEDraftPaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[DraftPaymentCreate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountDraftPayment request
	ListAllNoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentDraftPaymentListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountDraftPayment request
	CREATENoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, body CREATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentDraftPaymentCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountDraftPayment request
	DELETENoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentDraftPaymentDelete], error)

	// READNoteAttachmentForUserMonetaryAccountDraftPayment request
	READNoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentDraftPaymentRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountDraftPayment request
	UPDATENoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentDraftPaymentUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountDraftPayment request
	ListAllNoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *ListAllNoteTextForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextDraftPaymentListing], error)

	// CREATENoteTextForUserMonetaryAccountDraftPayment request
	CREATENoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteTextForUserMonetaryAccountDraftPaymentParams, body CREATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextDraftPaymentCreate], error)

	// DELETENoteTextForUserMonetaryAccountDraftPayment request
	DELETENoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextDraftPaymentDelete], error)

	// READNoteTextForUserMonetaryAccountDraftPayment request
	READNoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextDraftPaymentRead], error)

	// UPDATENoteTextForUserMonetaryAccountDraftPayment request
	UPDATENoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountDraftPaymentParams, body UPDATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextDraftPaymentUpdate], error)

	// READDraftPaymentForUserMonetaryAccount request
	READDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READDraftPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[DraftPaymentRead], error)

	// UPDATEDraftPaymentForUserMonetaryAccount request
	UPDATEDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEDraftPaymentForUserMonetaryAccountParams, body UPDATEDraftPaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[DraftPaymentUpdate], error)

	// CREATEStatementForUserMonetaryAccountEvent request
	CREATEStatementForUserMonetaryAccountEvent(ctx context.Context, apiKey string, userID int, monetaryAccountID int, eventID int, params *CREATEStatementForUserMonetaryAccountEventParams, body CREATEStatementForUserMonetaryAccountEventJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ExportStatementPaymentCreate], error)

	// READStatementForUserMonetaryAccountEvent request
	READStatementForUserMonetaryAccountEvent(ctx context.Context, apiKey string, userID int, monetaryAccountID int, eventID int, itemId int, params *READStatementForUserMonetaryAccountEventParams, reqEditors ...RequestEditorFn) (Result[ExportStatementPaymentRead], error)

	// ListAllContentForUserMonetaryAccountEventStatement request
	ListAllContentForUserMonetaryAccountEventStatement(ctx context.Context, apiKey string, userID int, monetaryAccountID int, eventID int, statementID int, params *ListAllContentForUserMonetaryAccountEventStatementParams, reqEditors ...RequestEditorFn) (Result[[]ExportStatementPaymentContentListing], error)

	// ListAllExportRibForUserMonetaryAccount request
	ListAllExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllExportRibForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]ExportRibListing], error)

	// CREATEExportRibForUserMonetaryAccount request
	CREATEExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEExportRibForUserMonetaryAccountParams, body CREATEExportRibForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ExportRibCreate], error)

	// ListAllContentForUserMonetaryAccountExportRib request
	ListAllContentForUserMonetaryAccountExportRib(ctx context.Context, apiKey string, userID int, monetaryAccountID int, exportRibID int, params *ListAllContentForUserMonetaryAccountExportRibParams, reqEditors ...RequestEditorFn) (Result[[]ExportRibContentListing], error)

	// DELETEExportRibForUserMonetaryAccount request
	DELETEExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETEExportRibForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[ExportRibDelete], error)

	// READExportRibForUserMonetaryAccount request
	READExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READExportRibForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[ExportRibRead], error)

	// ListAllIdealMerchantTransactionForUserMonetaryAccount request
	ListAllIdealMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllIdealMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]IdealMerchantTransactionListing], error)

	// CREATEIdealMerchantTransactionForUserMonetaryAccount request
	CREATEIdealMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEIdealMerchantTransactionForUserMonetaryAccountParams, body CREATEIdealMerchantTransactionForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[IdealMerchantTransactionCreate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction request
	ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentIdealMerchantTransactionListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction request
	CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentIdealMerchantTransactionCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction request
	DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentIdealMerchantTransactionDelete], error)

	// READNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction request
	READNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentIdealMerchantTransactionRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction request
	UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentIdealMerchantTransactionUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountIdealMerchantTransaction request
	ListAllNoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextIdealMerchantTransactionListing], error)

	// CREATENoteTextForUserMonetaryAccountIdealMerchantTransaction request
	CREATENoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextIdealMerchantTransactionCreate], error)

	// DELETENoteTextForUserMonetaryAccountIdealMerchantTransaction request
	DELETENoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextIdealMerchantTransactionDelete], error)

	// READNoteTextForUserMonetaryAccountIdealMerchantTransaction request
	READNoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextIdealMerchantTransactionRead], error)

	// UPDATENoteTextForUserMonetaryAccountIdealMerchantTransaction request
	UPDATENoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextIdealMerchantTransactionUpdate], error)

	// READIdealMerchantTransactionForUserMonetaryAccount request
	READIdealMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READIdealMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[IdealMerchantTransactionRead], error)

	// ListAllInvoiceForUserMonetaryAccount request
	ListAllInvoiceForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllInvoiceForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]InvoiceListing], error)

	// READInvoiceForUserMonetaryAccount request
	READInvoiceForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READInvoiceForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[InvoiceRead], error)

	// ListAllMastercardActionForUserMonetaryAccount request
	ListAllMastercardActionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllMastercardActionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]MasterCardActionListing], error)

	// READMastercardActionForUserMonetaryAccount request
	READMastercardActionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READMastercardActionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[MasterCardActionRead], error)

	// ListAllNoteAttachmentForUserMonetaryAccountMastercardAction request
	ListAllNoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllNoteAttachmentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentMasterCardActionListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountMastercardAction request
	CREATENoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteAttachmentForUserMonetaryAccountMastercardActionParams, body CREATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentMasterCardActionCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountMastercardAction request
	DELETENoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentMasterCardActionDelete], error)

	// READNoteAttachmentForUserMonetaryAccountMastercardAction request
	READNoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentMasterCardActionRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountMastercardAction request
	UPDATENoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountMastercardActionParams, body UPDATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentMasterCardActionUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountMastercardAction request
	ListAllNoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllNoteTextForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextMasterCardActionListing], error)

	// CREATENoteTextForUserMonetaryAccountMastercardAction request
	CREATENoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteTextForUserMonetaryAccountMastercardActionParams, body CREATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextMasterCardActionCreate], error)

	// DELETENoteTextForUserMonetaryAccountMastercardAction request
	DELETENoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (Result[NoteTextMasterCardActionDelete], error)

	// READNoteTextForUserMonetaryAccountMastercardAction request
	READNoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *READNoteTextForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (Result[NoteTextMasterCardActionRead], error)

	// UPDATENoteTextForUserMonetaryAccountMastercardAction request
	UPDATENoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountMastercardActionParams, body UPDATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextMasterCardActionUpdate], error)

	// ListAllPaymentForUserMonetaryAccountMastercardAction request
	ListAllPaymentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllPaymentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (Result[[]MasterCardPaymentListing], error)

	// ListAllNotificationFilterUrlForUserMonetaryAccount request
	ListAllNotificationFilterUrlForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllNotificationFilterUrlForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]NotificationFilterUrlMonetaryAccountListing], error)

	// CREATENotificationFilterUrlForUserMonetaryAccount request
	CREATENotificationFilterUrlForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATENotificationFilterUrlForUserMonetaryAccountParams, body CREATENotificationFilterUrlForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NotificationFilterUrlMonetaryAccountCreate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction request
	ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentOpenBankingMerchantTransactionListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction request
	CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentOpenBankingMerchantTransactionCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction request
	DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentOpenBankingMerchantTransactionDelete], error)

	// READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction request
	READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentOpenBankingMerchantTransactionRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction request
	UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentOpenBankingMerchantTransactionUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction request
	ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextOpenBankingMerchantTransactionListing], error)

	// CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction request
	CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextOpenBankingMerchantTransactionCreate], error)

	// DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction request
	DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextOpenBankingMerchantTransactionDelete], error)

	// READNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction request
	READNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextOpenBankingMerchantTransactionRead], error)

	// UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction request
	UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextOpenBankingMerchantTransactionUpdate], error)

	// ListAllPaymentForUserMonetaryAccount request
	ListAllPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]PaymentListing], error)

	// CREATEPaymentForUserMonetaryAccount request
	CREATEPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEPaymentForUserMonetaryAccountParams, body CREATEPaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentCreate], error)

	// ListAllPaymentAutoAllocateForUserMonetaryAccount request
	ListAllPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllPaymentAutoAllocateForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]PaymentAutoAllocateListing], error)

	// CREATEPaymentAutoAllocateForUserMonetaryAccount request
	CREATEPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEPaymentAutoAllocateForUserMonetaryAccountParams, body CREATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentAutoAllocateCreate], error)

	// DELETEPaymentAutoAllocateForUserMonetaryAccount request
	DELETEPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETEPaymentAutoAllocateForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[PaymentAutoAllocateDelete], error)

	// READPaymentAutoAllocateForUserMonetaryAccount request
	READPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READPaymentAutoAllocateForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[PaymentAutoAllocateRead], error)

	// UPDATEPaymentAutoAllocateForUserMonetaryAccount request
	UPDATEPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentAutoAllocateForUserMonetaryAccountParams, body UPDATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentAutoAllocateUpdate], error)

	// ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocate request
	ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocate(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentAutoAllocateID int, params *ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateParams, reqEditors ...RequestEditorFn) (Result[[]PaymentAutoAllocateDefinitionListing], error)

	// ListAllInstanceForUserMonetaryAccountPaymentAutoAllocate request
	ListAllInstanceForUserMonetaryAccountPaymentAutoAllocate(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentAutoAllocateID int, params *ListAllInstanceForUserMonetaryAccountPaymentAutoAllocateParams, reqEditors ...RequestEditorFn) (Result[[]PaymentAutoAllocateInstanceListing], error)

	// READInstanceForUserMonetaryAccountPaymentAutoAllocate request
	READInstanceForUserMonetaryAccountPaymentAutoAllocate(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentAutoAllocateID int, itemId int, params *READInstanceForUserMonetaryAccountPaymentAutoAllocateParams, reqEditors ...RequestEditorFn) (Result[PaymentAutoAllocateInstanceRead], error)

	// ListAllPaymentBatchForUserMonetaryAccount request
	ListAllPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllPaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]PaymentBatchListing], error)

	// CREATEPaymentBatchForUserMonetaryAccount request
	CREATEPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEPaymentBatchForUserMonetaryAccountParams, body CREATEPaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentBatchCreate], error)

	// READPaymentBatchForUserMonetaryAccount request
	READPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READPaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[PaymentBatchRead], error)

	// UPDATEPaymentBatchForUserMonetaryAccount request
	UPDATEPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentBatchForUserMonetaryAccountParams, body UPDATEPaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentBatchUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountPaymentBatch request
	ListAllNoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentPaymentBatchListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountPaymentBatch request
	CREATENoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentBatchCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountPaymentBatch request
	DELETENoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentBatchDelete], error)

	// READNoteAttachmentForUserMonetaryAccountPaymentBatch request
	READNoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentBatchRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountPaymentBatch request
	UPDATENoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentBatchUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountPaymentBatch request
	ListAllNoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *ListAllNoteTextForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextPaymentBatchListing], error)

	// CREATENoteTextForUserMonetaryAccountPaymentBatch request
	CREATENoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteTextForUserMonetaryAccountPaymentBatchParams, body CREATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentBatchCreate], error)

	// DELETENoteTextForUserMonetaryAccountPaymentBatch request
	DELETENoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentBatchDelete], error)

	// READNoteTextForUserMonetaryAccountPaymentBatch request
	READNoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentBatchRead], error)

	// UPDATENoteTextForUserMonetaryAccountPaymentBatch request
	UPDATENoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentBatchParams, body UPDATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentBatchUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayed request
	ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentPaymentDelayedListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountPaymentDelayed request
	CREATENoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentDelayedCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountPaymentDelayed request
	DELETENoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentDelayedDelete], error)

	// READNoteAttachmentForUserMonetaryAccountPaymentDelayed request
	READNoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentDelayedRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayed request
	UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentDelayedUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountPaymentDelayed request
	ListAllNoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *ListAllNoteTextForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextPaymentDelayedListing], error)

	// CREATENoteTextForUserMonetaryAccountPaymentDelayed request
	CREATENoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteTextForUserMonetaryAccountPaymentDelayedParams, body CREATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentDelayedCreate], error)

	// DELETENoteTextForUserMonetaryAccountPaymentDelayed request
	DELETENoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentDelayedDelete], error)

	// READNoteTextForUserMonetaryAccountPaymentDelayed request
	READNoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentDelayedRead], error)

	// UPDATENoteTextForUserMonetaryAccountPaymentDelayed request
	UPDATENoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentDelayedParams, body UPDATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentDelayedUpdate], error)

	// READPaymentForUserMonetaryAccount request
	READPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[PaymentRead], error)

	// ListAllNoteAttachmentForUserMonetaryAccountPayment request
	ListAllNoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentPaymentListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountPayment request
	CREATENoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountPayment request
	DELETENoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentDelete], error)

	// READNoteAttachmentForUserMonetaryAccountPayment request
	READNoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountPayment request
	UPDATENoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentPaymentUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountPayment request
	ListAllNoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *ListAllNoteTextForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextPaymentListing], error)

	// CREATENoteTextForUserMonetaryAccountPayment request
	CREATENoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteTextForUserMonetaryAccountPaymentParams, body CREATENoteTextForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentCreate], error)

	// DELETENoteTextForUserMonetaryAccountPayment request
	DELETENoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentDelete], error)

	// READNoteTextForUserMonetaryAccountPayment request
	READNoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentRead], error)

	// UPDATENoteTextForUserMonetaryAccountPayment request
	UPDATENoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentParams, body UPDATENoteTextForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextPaymentUpdate], error)

	// ListAllRequestInquiryForUserMonetaryAccount request
	ListAllRequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllRequestInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]RequestInquiryListing], error)

	// CREATERequestInquiryForUserMonetaryAccount request
	CREATERequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATERequestInquiryForUserMonetaryAccountParams, body CREATERequestInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[RequestInquiryCreate], error)

	// ListAllRequestInquiryBatchForUserMonetaryAccount request
	ListAllRequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllRequestInquiryBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]RequestInquiryBatchListing], error)

	// CREATERequestInquiryBatchForUserMonetaryAccount request
	CREATERequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATERequestInquiryBatchForUserMonetaryAccountParams, body CREATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[RequestInquiryBatchCreate], error)

	// READRequestInquiryBatchForUserMonetaryAccount request
	READRequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READRequestInquiryBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[RequestInquiryBatchRead], error)

	// UPDATERequestInquiryBatchForUserMonetaryAccount request
	UPDATERequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryBatchForUserMonetaryAccountParams, body UPDATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[RequestInquiryBatchUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatch request
	ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentRequestInquiryBatchListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch request
	CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, body CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryBatchCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatch request
	DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryBatchDelete], error)

	// READNoteAttachmentForUserMonetaryAccountRequestInquiryBatch request
	READNoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryBatchRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch request
	UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryBatchUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountRequestInquiryBatch request
	ListAllNoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *ListAllNoteTextForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextRequestInquiryBatchListing], error)

	// CREATENoteTextForUserMonetaryAccountRequestInquiryBatch request
	CREATENoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, body CREATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryBatchCreate], error)

	// DELETENoteTextForUserMonetaryAccountRequestInquiryBatch request
	DELETENoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryBatchDelete], error)

	// READNoteTextForUserMonetaryAccountRequestInquiryBatch request
	READNoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryBatchRead], error)

	// UPDATENoteTextForUserMonetaryAccountRequestInquiryBatch request
	UPDATENoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, body UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryBatchUpdate], error)

	// READRequestInquiryForUserMonetaryAccount request
	READRequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READRequestInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[RequestInquiryRead], error)

	// UPDATERequestInquiryForUserMonetaryAccount request
	UPDATERequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryForUserMonetaryAccountParams, body UPDATERequestInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[RequestInquiryUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountRequestInquiry request
	ListAllNoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentRequestInquiryListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountRequestInquiry request
	CREATENoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, body CREATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountRequestInquiry request
	DELETENoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryDelete], error)

	// READNoteAttachmentForUserMonetaryAccountRequestInquiry request
	READNoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountRequestInquiry request
	UPDATENoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestInquiryUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountRequestInquiry request
	ListAllNoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *ListAllNoteTextForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextRequestInquiryListing], error)

	// CREATENoteTextForUserMonetaryAccountRequestInquiry request
	CREATENoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryParams, body CREATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryCreate], error)

	// DELETENoteTextForUserMonetaryAccountRequestInquiry request
	DELETENoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryDelete], error)

	// READNoteTextForUserMonetaryAccountRequestInquiry request
	READNoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryRead], error)

	// UPDATENoteTextForUserMonetaryAccountRequestInquiry request
	UPDATENoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryParams, body UPDATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextRequestInquiryUpdate], error)

	// ListAllRequestResponseForUserMonetaryAccount request
	ListAllRequestResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllRequestResponseForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]RequestResponseListing], error)

	// READRequestResponseForUserMonetaryAccount request
	READRequestResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READRequestResponseForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[RequestResponseRead], error)

	// UPDATERequestResponseForUserMonetaryAccount request
	UPDATERequestResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestResponseForUserMonetaryAccountParams, body UPDATERequestResponseForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[RequestResponseUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountRequestResponse request
	ListAllNoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentRequestResponseListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountRequestResponse request
	CREATENoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestResponseParams, body CREATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestResponseCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountRequestResponse request
	DELETENoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestResponseDelete], error)

	// READNoteAttachmentForUserMonetaryAccountRequestResponse request
	READNoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestResponseRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountRequestResponse request
	UPDATENoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestResponseParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentRequestResponseUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountRequestResponse request
	ListAllNoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *ListAllNoteTextForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextRequestResponseListing], error)

	// CREATENoteTextForUserMonetaryAccountRequestResponse request
	CREATENoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteTextForUserMonetaryAccountRequestResponseParams, body CREATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextRequestResponseCreate], error)

	// DELETENoteTextForUserMonetaryAccountRequestResponse request
	DELETENoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (Result[NoteTextRequestResponseDelete], error)

	// READNoteTextForUserMonetaryAccountRequestResponse request
	READNoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (Result[NoteTextRequestResponseRead], error)

	// UPDATENoteTextForUserMonetaryAccountRequestResponse request
	UPDATENoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestResponseParams, body UPDATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextRequestResponseUpdate], error)

	// ListAllScheduleForUserMonetaryAccount request
	ListAllScheduleForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllScheduleForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]ScheduleListing], error)

	// ListAllSchedulePaymentForUserMonetaryAccount request
	ListAllSchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllSchedulePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]SchedulePaymentListing], error)

	// CREATESchedulePaymentForUserMonetaryAccount request
	CREATESchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATESchedulePaymentForUserMonetaryAccountParams, body CREATESchedulePaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[SchedulePaymentCreate], error)

	// CREATESchedulePaymentBatchForUserMonetaryAccount request
	CREATESchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATESchedulePaymentBatchForUserMonetaryAccountParams, body CREATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[SchedulePaymentBatchCreate], error)

	// DELETESchedulePaymentBatchForUserMonetaryAccount request
	DELETESchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETESchedulePaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[SchedulePaymentBatchDelete], error)

	// READSchedulePaymentBatchForUserMonetaryAccount request
	READSchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSchedulePaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[SchedulePaymentBatchRead], error)

	// UPDATESchedulePaymentBatchForUserMonetaryAccount request
	UPDATESchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentBatchForUserMonetaryAccountParams, body UPDATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[SchedulePaymentBatchUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch request
	ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentSchedulePaymentBatchListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch request
	CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, body CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentBatchCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch request
	DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentBatchDelete], error)

	// READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch request
	READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentBatchRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch request
	UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentBatchUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatch request
	ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextSchedulePaymentBatchListing], error)

	// CREATENoteTextForUserMonetaryAccountSchedulePaymentBatch request
	CREATENoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, body CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentBatchCreate], error)

	// DELETENoteTextForUserMonetaryAccountSchedulePaymentBatch request
	DELETENoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentBatchDelete], error)

	// READNoteTextForUserMonetaryAccountSchedulePaymentBatch request
	READNoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentBatchRead], error)

	// UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatch request
	UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, body UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentBatchUpdate], error)

	// DELETESchedulePaymentForUserMonetaryAccount request
	DELETESchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETESchedulePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[SchedulePaymentDelete], error)

	// READSchedulePaymentForUserMonetaryAccount request
	READSchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSchedulePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[SchedulePaymentRead], error)

	// UPDATESchedulePaymentForUserMonetaryAccount request
	UPDATESchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentForUserMonetaryAccountParams, body UPDATESchedulePaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[SchedulePaymentUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountSchedulePayment request
	ListAllNoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentSchedulePaymentListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountSchedulePayment request
	CREATENoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, body CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountSchedulePayment request
	DELETENoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentDelete], error)

	// READNoteAttachmentForUserMonetaryAccountSchedulePayment request
	READNoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountSchedulePayment request
	UPDATENoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSchedulePaymentUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountSchedulePayment request
	ListAllNoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *ListAllNoteTextForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextSchedulePaymentListing], error)

	// CREATENoteTextForUserMonetaryAccountSchedulePayment request
	CREATENoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentParams, body CREATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentCreate], error)

	// DELETENoteTextForUserMonetaryAccountSchedulePayment request
	DELETENoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentDelete], error)

	// READNoteTextForUserMonetaryAccountSchedulePayment request
	READNoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentRead], error)

	// UPDATENoteTextForUserMonetaryAccountSchedulePayment request
	UPDATENoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentParams, body UPDATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextSchedulePaymentUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch request
	ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentScheduleRequestBatchListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch request
	CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestBatchCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch request
	DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestBatchDelete], error)

	// READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch request
	READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestBatchRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch request
	UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestBatchUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch request
	ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextScheduleRequestBatchListing], error)

	// CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch request
	CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, body CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestBatchCreate], error)

	// DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch request
	DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestBatchDelete], error)

	// READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch request
	READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestBatchRead], error)

	// UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch request
	UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, body UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestBatchUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry request
	ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentScheduleRequestListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry request
	CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry request
	DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestDelete], error)

	// READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry request
	READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry request
	UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleRequestUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiry request
	ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextScheduleRequestListing], error)

	// CREATENoteTextForUserMonetaryAccountScheduleRequestInquiry request
	CREATENoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, body CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestCreate], error)

	// DELETENoteTextForUserMonetaryAccountScheduleRequestInquiry request
	DELETENoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestDelete], error)

	// READNoteTextForUserMonetaryAccountScheduleRequestInquiry request
	READNoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestRead], error)

	// UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiry request
	UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, body UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleRequestUpdate], error)

	// READScheduleForUserMonetaryAccount request
	READScheduleForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READScheduleForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[ScheduleRead], error)

	// ListAllScheduleInstanceForUserMonetaryAccountSchedule request
	ListAllScheduleInstanceForUserMonetaryAccountSchedule(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, params *ListAllScheduleInstanceForUserMonetaryAccountScheduleParams, reqEditors ...RequestEditorFn) (Result[[]ScheduleInstanceListing], error)

	// READScheduleInstanceForUserMonetaryAccountSchedule request
	READScheduleInstanceForUserMonetaryAccountSchedule(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, itemId int, params *READScheduleInstanceForUserMonetaryAccountScheduleParams, reqEditors ...RequestEditorFn) (Result[ScheduleInstanceRead], error)

	// UPDATEScheduleInstanceForUserMonetaryAccountSchedule request
	UPDATEScheduleInstanceForUserMonetaryAccountSchedule(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, itemId int, params *UPDATEScheduleInstanceForUserMonetaryAccountScheduleParams, body UPDATEScheduleInstanceForUserMonetaryAccountScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ScheduleInstanceUpdate], error)

	// ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance request
	ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentScheduleInstanceListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance request
	CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleInstanceCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance request
	DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleInstanceDelete], error)

	// READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance request
	READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleInstanceRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance request
	UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentScheduleInstanceUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstance request
	ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextScheduleInstanceListing], error)

	// CREATENoteTextForUserMonetaryAccountScheduleScheduleInstance request
	CREATENoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, body CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleInstanceCreate], error)

	// DELETENoteTextForUserMonetaryAccountScheduleScheduleInstance request
	DELETENoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleInstanceDelete], error)

	// READNoteTextForUserMonetaryAccountScheduleScheduleInstance request
	READNoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleInstanceRead], error)

	// UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstance request
	UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, body UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextScheduleInstanceUpdate], error)

	// ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccount request
	ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]ShareInviteMonetaryAccountInquiryListing], error)

	// CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount request
	CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, body CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ShareInviteMonetaryAccountInquiryCreate], error)

	// READShareInviteMonetaryAccountInquiryForUserMonetaryAccount request
	READShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[ShareInviteMonetaryAccountInquiryRead], error)

	// UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount request
	UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, body UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ShareInviteMonetaryAccountInquiryUpdate], error)

	// ListAllSofortMerchantTransactionForUserMonetaryAccount request
	ListAllSofortMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllSofortMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]SofortMerchantTransactionListing], error)

	// READSofortMerchantTransactionForUserMonetaryAccount request
	READSofortMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSofortMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[SofortMerchantTransactionRead], error)

	// ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction request
	ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentSofortMerchantTransactionListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction request
	CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSofortMerchantTransactionCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction request
	DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSofortMerchantTransactionDelete], error)

	// READNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction request
	READNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSofortMerchantTransactionRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction request
	UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentSofortMerchantTransactionUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountSofortMerchantTransaction request
	ListAllNoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextSofortMerchantTransactionListing], error)

	// CREATENoteTextForUserMonetaryAccountSofortMerchantTransaction request
	CREATENoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextSofortMerchantTransactionCreate], error)

	// DELETENoteTextForUserMonetaryAccountSofortMerchantTransaction request
	DELETENoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextSofortMerchantTransactionDelete], error)

	// READNoteTextForUserMonetaryAccountSofortMerchantTransaction request
	READNoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (Result[NoteTextSofortMerchantTransactionRead], error)

	// UPDATENoteTextForUserMonetaryAccountSofortMerchantTransaction request
	UPDATENoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextSofortMerchantTransactionUpdate], error)

	// READSwitchServicePaymentForUserMonetaryAccount request
	READSwitchServicePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSwitchServicePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[BankSwitchServiceNetherlandsIncomingPaymentRead], error)

	// ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePayment request
	ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountSwitchServicePayment request
	CREATENoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, body CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountSwitchServicePayment request
	DELETENoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentDelete], error)

	// READNoteAttachmentForUserMonetaryAccountSwitchServicePayment request
	READNoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePayment request
	UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountSwitchServicePayment request
	ListAllNoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *ListAllNoteTextForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing], error)

	// CREATENoteTextForUserMonetaryAccountSwitchServicePayment request
	CREATENoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, body CREATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentCreate], error)

	// DELETENoteTextForUserMonetaryAccountSwitchServicePayment request
	DELETENoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentDelete], error)

	// READNoteTextForUserMonetaryAccountSwitchServicePayment request
	READNoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentRead], error)

	// UPDATENoteTextForUserMonetaryAccountSwitchServicePayment request
	UPDATENoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, body UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentUpdate], error)

	// ListAllWhitelistSddForUserMonetaryAccount request
	ListAllWhitelistSddForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllWhitelistSddForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[[]WhitelistSddMonetaryAccountPayingListing], error)

	// READWhitelistSddForUserMonetaryAccount request
	READWhitelistSddForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READWhitelistSddForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (Result[WhitelistSddMonetaryAccountPayingRead], error)

	// ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult request
	ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (Result[[]NoteAttachmentWhitelistResultListing], error)

	// CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult request
	CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, body CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentWhitelistResultCreate], error)

	// DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult request
	DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentWhitelistResultDelete], error)

	// READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult request
	READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (Result[NoteAttachmentWhitelistResultRead], error)

	// UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult request
	UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, body UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteAttachmentWhitelistResultUpdate], error)

	// ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResult request
	ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (Result[[]NoteTextWhitelistResultListing], error)

	// CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResult request
	CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, body CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextWhitelistResultCreate], error)

	// DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResult request
	DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (Result[NoteTextWhitelistResultDelete], error)

	// READNoteTextForUserMonetaryAccountWhitelistWhitelistResult request
	READNoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *READNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (Result[NoteTextWhitelistResultRead], error)

	// UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResult request
	UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, body UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NoteTextWhitelistResultUpdate], error)

	// ListAllNotificationFilterEmailForUser request
	ListAllNotificationFilterEmailForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterEmailForUserParams, reqEditors ...RequestEditorFn) (Result[[]NotificationFilterEmailListing], error)

	// CREATENotificationFilterEmailForUser request
	CREATENotificationFilterEmailForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterEmailForUserParams, body CREATENotificationFilterEmailForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NotificationFilterEmailCreate], error)

	// ListAllNotificationFilterFailureForUser request
	ListAllNotificationFilterFailureForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterFailureForUserParams, reqEditors ...RequestEditorFn) (Result[[]NotificationFilterFailureListing], error)

	// CREATENotificationFilterFailureForUser request
	CREATENotificationFilterFailureForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterFailureForUserParams, body CREATENotificationFilterFailureForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NotificationFilterFailureCreate], error)

	// ListAllNotificationFilterPushForUser request
	ListAllNotificationFilterPushForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterPushForUserParams, reqEditors ...RequestEditorFn) (Result[[]NotificationFilterPushListing], error)

	// CREATENotificationFilterPushForUser request
	CREATENotificationFilterPushForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterPushForUserParams, body CREATENotificationFilterPushForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NotificationFilterPushCreate], error)

	// ListAllNotificationFilterUrlForUser request
	ListAllNotificationFilterUrlForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterUrlForUserParams, reqEditors ...RequestEditorFn) (Result[[]NotificationFilterUrlListing], error)

	// CREATENotificationFilterUrlForUser request
	CREATENotificationFilterUrlForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterUrlForUserParams, body CREATENotificationFilterUrlForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[NotificationFilterUrlCreate], error)

	// ListAllOauthClientForUser request
	ListAllOauthClientForUser(ctx context.Context, apiKey string, userID int, params *ListAllOauthClientForUserParams, reqEditors ...RequestEditorFn) (Result[[]OauthClientListing], error)

	// CREATEOauthClientForUser request
	CREATEOauthClientForUser(ctx context.Context, apiKey string, userID int, params *CREATEOauthClientForUserParams, body CREATEOauthClientForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[OauthClientCreate], error)

	// READOauthClientForUser request
	READOauthClientForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READOauthClientForUserParams, reqEditors ...RequestEditorFn) (Result[OauthClientRead], error)

	// UPDATEOauthClientForUser request
	UPDATEOauthClientForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEOauthClientForUserParams, body UPDATEOauthClientForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[OauthClientUpdate], error)

	// ListAllCallbackUrlForUserOauthClient request
	ListAllCallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, params *ListAllCallbackUrlForUserOauthClientParams, reqEditors ...RequestEditorFn) (Result[[]OauthCallbackUrlListing], error)

	// CREATECallbackUrlForUserOauthClient request
	CREATECallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, params *CREATECallbackUrlForUserOauthClientParams, body CREATECallbackUrlForUserOauthClientJSONRequestBody, reqEditors ...RequestEditorFn) (Result[OauthCallbackUrlCreate], error)

	// DELETECallbackUrlForUserOauthClient request
	DELETECallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, itemId int, params *DELETECallbackUrlForUserOauthClientParams, reqEditors ...RequestEditorFn) (Result[OauthCallbackUrlDelete], error)

	// READCallbackUrlForUserOauthClient request
	READCallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, itemId int, params *READCallbackUrlForUserOauthClientParams, reqEditors ...RequestEditorFn) (Result[OauthCallbackUrlRead], error)

	// UPDATECallbackUrlForUserOauthClient request
	UPDATECallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, itemId int, params *UPDATECallbackUrlForUserOauthClientParams, body UPDATECallbackUrlForUserOauthClientJSONRequestBody, reqEditors ...RequestEditorFn) (Result[OauthCallbackUrlUpdate], error)

	// ListAllPaymentAutoAllocateForUser request
	ListAllPaymentAutoAllocateForUser(ctx context.Context, apiKey string, userID int, params *ListAllPaymentAutoAllocateForUserParams, reqEditors ...RequestEditorFn) (Result[[]PaymentAutoAllocateUserListing], error)

	// ListAllPaymentServiceProviderDraftPaymentForUser request
	ListAllPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, params *ListAllPaymentServiceProviderDraftPaymentForUserParams, reqEditors ...RequestEditorFn) (Result[[]PaymentServiceProviderDraftPaymentListing], error)

	// CREATEPaymentServiceProviderDraftPaymentForUser request
	CREATEPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, params *CREATEPaymentServiceProviderDraftPaymentForUserParams, body CREATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderDraftPaymentCreate], error)

	// READPaymentServiceProviderDraftPaymentForUser request
	READPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READPaymentServiceProviderDraftPaymentForUserParams, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderDraftPaymentRead], error)

	// UPDATEPaymentServiceProviderDraftPaymentForUser request
	UPDATEPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEPaymentServiceProviderDraftPaymentForUserParams, body UPDATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderDraftPaymentUpdate], error)

	// ListAllPaymentServiceProviderIssuerTransactionForUser request
	ListAllPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, params *ListAllPaymentServiceProviderIssuerTransactionForUserParams, reqEditors ...RequestEditorFn) (Result[[]PaymentServiceProviderIssuerTransactionListing], error)

	// CREATEPaymentServiceProviderIssuerTransactionForUser request
	CREATEPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, params *CREATEPaymentServiceProviderIssuerTransactionForUserParams, body CREATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderIssuerTransactionCreate], error)

	// READPaymentServiceProviderIssuerTransactionForUser request
	READPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READPaymentServiceProviderIssuerTransactionForUserParams, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderIssuerTransactionRead], error)

	// UPDATEPaymentServiceProviderIssuerTransactionForUser request
	UPDATEPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEPaymentServiceProviderIssuerTransactionForUserParams, body UPDATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[PaymentServiceProviderIssuerTransactionUpdate], error)

	// ListAllScheduleForUser request
	ListAllScheduleForUser(ctx context.Context, apiKey string, userID int, params *ListAllScheduleForUserParams, reqEditors ...RequestEditorFn) (Result[[]ScheduleUserListing], error)

	// ListAllShareInviteMonetaryAccountResponseForUser request
	ListAllShareInviteMonetaryAccountResponseForUser(ctx context.Context, apiKey string, userID int, params *ListAllShareInviteMonetaryAccountResponseForUserParams, reqEditors ...RequestEditorFn) (Result[[]ShareInviteMonetaryAccountResponseListing], error)

	// READShareInviteMonetaryAccountResponseForUser request
	READShareInviteMonetaryAccountResponseForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READShareInviteMonetaryAccountResponseForUserParams, reqEditors ...RequestEditorFn) (Result[ShareInviteMonetaryAccountResponseRead], error)

	// UPDATEShareInviteMonetaryAccountResponseForUser request
	UPDATEShareInviteMonetaryAccountResponseForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEShareInviteMonetaryAccountResponseForUserParams, body UPDATEShareInviteMonetaryAccountResponseForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[ShareInviteMonetaryAccountResponseUpdate], error)

	// CREATETokenQrRequestIdealForUser request
	CREATETokenQrRequestIdealForUser(ctx context.Context, apiKey string, userID int, params *CREATETokenQrRequestIdealForUserParams, body CREATETokenQrRequestIdealForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TokenQrRequestIdealCreate], error)

	// CREATETokenQrRequestSofortForUser request
	CREATETokenQrRequestSofortForUser(ctx context.Context, apiKey string, userID int, params *CREATETokenQrRequestSofortForUserParams, body CREATETokenQrRequestSofortForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TokenQrRequestSofortCreate], error)

	// ListAllTransferwiseCurrencyForUser request
	ListAllTransferwiseCurrencyForUser(ctx context.Context, apiKey string, userID int, params *ListAllTransferwiseCurrencyForUserParams, reqEditors ...RequestEditorFn) (Result[[]TransferwiseCurrencyListing], error)

	// CREATETransferwiseQuoteForUser request
	CREATETransferwiseQuoteForUser(ctx context.Context, apiKey string, userID int, params *CREATETransferwiseQuoteForUserParams, body CREATETransferwiseQuoteForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TransferwiseQuoteCreate], error)

	// CREATETransferwiseQuoteTemporaryForUser request
	CREATETransferwiseQuoteTemporaryForUser(ctx context.Context, apiKey string, userID int, params *CREATETransferwiseQuoteTemporaryForUserParams, body CREATETransferwiseQuoteTemporaryForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TransferwiseQuoteTemporaryCreate], error)

	// READTransferwiseQuoteTemporaryForUser request
	READTransferwiseQuoteTemporaryForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READTransferwiseQuoteTemporaryForUserParams, reqEditors ...RequestEditorFn) (Result[TransferwiseQuoteTemporaryRead], error)

	// READTransferwiseQuoteForUser request
	READTransferwiseQuoteForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READTransferwiseQuoteForUserParams, reqEditors ...RequestEditorFn) (Result[TransferwiseQuoteRead], error)

	// ListAllTransferwiseRecipientForUserTransferwiseQuote request
	ListAllTransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseRecipientForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (Result[[]TransferwiseAccountQuoteListing], error)

	// CREATETransferwiseRecipientForUserTransferwiseQuote request
	CREATETransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientForUserTransferwiseQuoteParams, body CREATETransferwiseRecipientForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TransferwiseAccountQuoteCreate], error)

	// ListAllTransferwiseRecipientRequirementForUserTransferwiseQuote request
	ListAllTransferwiseRecipientRequirementForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (Result[[]TransferwiseAccountRequirementListing], error)

	// CREATETransferwiseRecipientRequirementForUserTransferwiseQuote request
	CREATETransferwiseRecipientRequirementForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteParams, body CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TransferwiseAccountRequirementCreate], error)

	// DELETETransferwiseRecipientForUserTransferwiseQuote request
	DELETETransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, itemId int, params *DELETETransferwiseRecipientForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (Result[TransferwiseAccountQuoteDelete], error)

	// READTransferwiseRecipientForUserTransferwiseQuote request
	READTransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, itemId int, params *READTransferwiseRecipientForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (Result[TransferwiseAccountQuoteRead], error)

	// ListAllTransferwiseTransferForUserTransferwiseQuote request
	ListAllTransferwiseTransferForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseTransferForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (Result[[]TransferwiseTransferListing], error)

	// CREATETransferwiseTransferForUserTransferwiseQuote request
	CREATETransferwiseTransferForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferForUserTransferwiseQuoteParams, body CREATETransferwiseTransferForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TransferwiseTransferCreate], error)

	// CREATETransferwiseTransferRequirementForUserTransferwiseQuote request
	CREATETransferwiseTransferRequirementForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferRequirementForUserTransferwiseQuoteParams, body CREATETransferwiseTransferRequirementForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TransferwiseTransferRequirementCreate], error)

	// READTransferwiseTransferForUserTransferwiseQuote request
	READTransferwiseTransferForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, itemId int, params *READTransferwiseTransferForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (Result[TransferwiseTransferRead], error)

	// ListAllTransferwiseUserForUser request
	ListAllTransferwiseUserForUser(ctx context.Context, apiKey string, userID int, params *ListAllTransferwiseUserForUserParams, reqEditors ...RequestEditorFn) (Result[[]TransferwiseUserListing], error)

	// CREATETransferwiseUserForUser request
	CREATETransferwiseUserForUser(ctx context.Context, apiKey string, userID int, params *CREATETransferwiseUserForUserParams, body CREATETransferwiseUserForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[TransferwiseUserCreate], error)

	// ListAllTreeProgressForUser request
	ListAllTreeProgressForUser(ctx context.Context, apiKey string, userID int, params *ListAllTreeProgressForUserParams, reqEditors ...RequestEditorFn) (Result[[]TreeProgressListing], error)

	// ListAllWhitelistSddForUser request
	ListAllWhitelistSddForUser(ctx context.Context, apiKey string, userID int, params *ListAllWhitelistSddForUserParams, reqEditors ...RequestEditorFn) (Result[[]WhitelistSddListing], error)

	// ListAllWhitelistSddOneOffForUser request
	ListAllWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, params *ListAllWhitelistSddOneOffForUserParams, reqEditors ...RequestEditorFn) (Result[[]WhitelistSddOneOffListing], error)

	// CREATEWhitelistSddOneOffForUser request
	CREATEWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, params *CREATEWhitelistSddOneOffForUserParams, body CREATEWhitelistSddOneOffForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[WhitelistSddOneOffCreate], error)

	// DELETEWhitelistSddOneOffForUser request
	DELETEWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETEWhitelistSddOneOffForUserParams, reqEditors ...RequestEditorFn) (Result[WhitelistSddOneOffDelete], error)

	// READWhitelistSddOneOffForUser request
	READWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READWhitelistSddOneOffForUserParams, reqEditors ...RequestEditorFn) (Result[WhitelistSddOneOffRead], error)

	// UPDATEWhitelistSddOneOffForUser request
	UPDATEWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEWhitelistSddOneOffForUserParams, body UPDATEWhitelistSddOneOffForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[WhitelistSddOneOffUpdate], error)

	// ListAllWhitelistSddRecurringForUser request
	ListAllWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, params *ListAllWhitelistSddRecurringForUserParams, reqEditors ...RequestEditorFn) (Result[[]WhitelistSddRecurringListing], error)

	// CREATEWhitelistSddRecurringForUser request
	CREATEWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, params *CREATEWhitelistSddRecurringForUserParams, body CREATEWhitelistSddRecurringForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[WhitelistSddRecurringCreate], error)

	// DELETEWhitelistSddRecurringForUser request
	DELETEWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETEWhitelistSddRecurringForUserParams, reqEditors ...RequestEditorFn) (Result[WhitelistSddRecurringDelete], error)

	// READWhitelistSddRecurringForUser request
	READWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READWhitelistSddRecurringForUserParams, reqEditors ...RequestEditorFn) (Result[WhitelistSddRecurringRead], error)

	// UPDATEWhitelistSddRecurringForUser request
	UPDATEWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEWhitelistSddRecurringForUserParams, body UPDATEWhitelistSddRecurringForUserJSONRequestBody, reqEditors ...RequestEditorFn) (Result[WhitelistSddRecurringUpdate], error)

	// READWhitelistSddForUser request
	READWhitelistSddForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READWhitelistSddForUserParams, reqEditors ...RequestEditorFn) (Result[WhitelistSddRead], error)
}

func (c *Client) CREATEAttachmentPublic(ctx context.Context, apiKey string, params *CREATEAttachmentPublicParams, body CREATEAttachmentPublicJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[AttachmentPublicCreate], err error) {
	req, err := NewCREATEAttachmentPublicRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[AttachmentPublicCreate](rsp)
}

func (c *Client) ListAllContentForAttachmentPublic(ctx context.Context, apiKey string, attachmentPublicUUID string, params *ListAllContentForAttachmentPublicParams, reqEditors ...RequestEditorFn) (res Result[[]AttachmentPublicContentListing], err error) {
	req, err := NewListAllContentForAttachmentPublicRequest(c.Server, attachmentPublicUUID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]AttachmentPublicContentListing](rsp)
}

func (c *Client) READAttachmentPublic(ctx context.Context, apiKey string, itemId int, params *READAttachmentPublicParams, reqEditors ...RequestEditorFn) (res Result[AttachmentPublicRead], err error) {
	req, err := NewREADAttachmentPublicRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[AttachmentPublicRead](rsp)
}

func (c *Client) CREATEAvatar(ctx context.Context, apiKey string, params *CREATEAvatarParams, body CREATEAvatarJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[AvatarCreate], err error) {
	req, err := NewCREATEAvatarRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[AvatarCreate](rsp)
}

func (c *Client) READAvatar(ctx context.Context, apiKey string, itemId int, params *READAvatarParams, reqEditors ...RequestEditorFn) (res Result[AvatarRead], err error) {
	req, err := NewREADAvatarRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[AvatarRead](rsp)
}

func (c *Client) ListAllDevice(ctx context.Context, apiKey string, params *ListAllDeviceParams, reqEditors ...RequestEditorFn) (res Result[[]DeviceListing], err error) {
	req, err := NewListAllDeviceRequest(c.Server, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]DeviceListing](rsp)
}

func (c *Client) ListAllDeviceServer(ctx context.Context, apiKey string, params *ListAllDeviceServerParams, reqEditors ...RequestEditorFn) (res Result[[]DeviceServerListing], err error) {
	req, err := NewListAllDeviceServerRequest(c.Server, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]DeviceServerListing](rsp)
}

func (c *Client) CREATEDeviceServer(ctx context.Context, apiKey string, params *CREATEDeviceServerParams, body CREATEDeviceServerJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[DeviceServerCreate], err error) {
	req, err := NewCREATEDeviceServerRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[DeviceServerCreate](rsp)
}

func (c *Client) READDeviceServer(ctx context.Context, apiKey string, itemId int, params *READDeviceServerParams, reqEditors ...RequestEditorFn) (res Result[DeviceServerRead], err error) {
	req, err := NewREADDeviceServerRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[DeviceServerRead](rsp)
}

func (c *Client) READDevice(ctx context.Context, apiKey string, itemId int, params *READDeviceParams, reqEditors ...RequestEditorFn) (res Result[DeviceRead], err error) {
	req, err := NewREADDeviceRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[DeviceRead](rsp)
}

func (c *Client) ListAllInstallation(ctx context.Context, apiKey string, params *ListAllInstallationParams, reqEditors ...RequestEditorFn) (res Result[[]InstallationListing], err error) {
	req, err := NewListAllInstallationRequest(c.Server, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InstallationListing](rsp)
}

func (c *Client) CREATEInstallation(ctx context.Context, apiKey string, params *CREATEInstallationParams, body CREATEInstallationJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[[]InstallationCreate], err error) {
	req, err := NewCREATEInstallationRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InstallationCreate](rsp)
}

func (c *Client) ListAllServerPublicKeyForInstallation(ctx context.Context, apiKey string, installationID int, params *ListAllServerPublicKeyForInstallationParams, reqEditors ...RequestEditorFn) (res Result[[]InstallationServerPublicKeyListing], err error) {
	req, err := NewListAllServerPublicKeyForInstallationRequest(c.Server, installationID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InstallationServerPublicKeyListing](rsp)
}

func (c *Client) READInstallation(ctx context.Context, apiKey string, itemId int, params *READInstallationParams, reqEditors ...RequestEditorFn) (res Result[InstallationRead], err error) {
	req, err := NewREADInstallationRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[InstallationRead](rsp)
}

func (c *Client) CREATEPaymentServiceProviderCredential(ctx context.Context, apiKey string, params *CREATEPaymentServiceProviderCredentialParams, body CREATEPaymentServiceProviderCredentialJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderCredentialCreate], err error) {
	req, err := NewCREATEPaymentServiceProviderCredentialRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderCredentialCreate](rsp)
}

func (c *Client) READPaymentServiceProviderCredential(ctx context.Context, apiKey string, itemId int, params *READPaymentServiceProviderCredentialParams, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderCredentialRead], err error) {
	req, err := NewREADPaymentServiceProviderCredentialRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderCredentialRead](rsp)
}

func (c *Client) CREATESandboxUserCompany(ctx context.Context, apiKey string, params *CREATESandboxUserCompanyParams, body CREATESandboxUserCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[SandboxUserCompanyCreate], err error) {
	req, err := NewCREATESandboxUserCompanyRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SandboxUserCompanyCreate](rsp)
}

func (c *Client) CREATESandboxUserPerson(ctx context.Context, apiKey string, params *CREATESandboxUserPersonParams, body CREATESandboxUserPersonJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[SandboxUserPersonCreate], err error) {
	req, err := NewCREATESandboxUserPersonRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SandboxUserPersonCreate](rsp)
}

func (c *Client) CREATEServerError(ctx context.Context, apiKey string, params *CREATEServerErrorParams, body CREATEServerErrorJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ServerErrorCreate], err error) {
	req, err := NewCREATEServerErrorRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ServerErrorCreate](rsp)
}

func (c *Client) CREATESessionServer(ctx context.Context, apiKey string, params *CREATESessionServerParams, body CREATESessionServerJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[[]SessionServerCreate], err error) {
	req, err := NewCREATESessionServerRequest(c.Server, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]SessionServerCreate](rsp)
}

func (c *Client) DELETESession(ctx context.Context, apiKey string, itemId int, params *DELETESessionParams, reqEditors ...RequestEditorFn) (res Result[SessionDelete], err error) {
	req, err := NewDELETESessionRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SessionDelete](rsp)
}

func (c *Client) ListAllUser(ctx context.Context, apiKey string, params *ListAllUserParams, reqEditors ...RequestEditorFn) (res Result[[]UserListing], err error) {
	req, err := NewListAllUserRequest(c.Server, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]UserListing](rsp)
}

func (c *Client) READUserCompany(ctx context.Context, apiKey string, itemId int, params *READUserCompanyParams, reqEditors ...RequestEditorFn) (res Result[UserCompanyRead], err error) {
	req, err := NewREADUserCompanyRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[UserCompanyRead](rsp)
}

func (c *Client) UPDATEUserCompany(ctx context.Context, apiKey string, itemId int, params *UPDATEUserCompanyParams, body UPDATEUserCompanyJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[UserCompanyUpdate], err error) {
	req, err := NewUPDATEUserCompanyRequest(c.Server, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[UserCompanyUpdate](rsp)
}

func (c *Client) ListAllNameForUserCompany(ctx context.Context, apiKey string, userCompanyID int, params *ListAllNameForUserCompanyParams, reqEditors ...RequestEditorFn) (res Result[[]UserCompanyNameListing], err error) {
	req, err := NewListAllNameForUserCompanyRequest(c.Server, userCompanyID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]UserCompanyNameListing](rsp)
}

func (c *Client) READUserPaymentServiceProvider(ctx context.Context, apiKey string, itemId int, params *READUserPaymentServiceProviderParams, reqEditors ...RequestEditorFn) (res Result[UserPaymentServiceProviderRead], err error) {
	req, err := NewREADUserPaymentServiceProviderRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[UserPaymentServiceProviderRead](rsp)
}

func (c *Client) READUserPerson(ctx context.Context, apiKey string, itemId int, params *READUserPersonParams, reqEditors ...RequestEditorFn) (res Result[UserPersonRead], err error) {
	req, err := NewREADUserPersonRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[UserPersonRead](rsp)
}

func (c *Client) UPDATEUserPerson(ctx context.Context, apiKey string, itemId int, params *UPDATEUserPersonParams, body UPDATEUserPersonJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[UserPersonUpdate], err error) {
	req, err := NewUPDATEUserPersonRequest(c.Server, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[UserPersonUpdate](rsp)
}

func (c *Client) READUser(ctx context.Context, apiKey string, itemId int, params *READUserParams, reqEditors ...RequestEditorFn) (res Result[UserRead], err error) {
	req, err := NewREADUserRequest(c.Server, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[UserRead](rsp)
}

func (c *Client) ListAllAdditionalTransactionInformationCategoryForUser(ctx context.Context, apiKey string, userID int, params *ListAllAdditionalTransactionInformationCategoryForUserParams, reqEditors ...RequestEditorFn) (res Result[[]AdditionalTransactionInformationCategoryListing], err error) {
	req, err := NewListAllAdditionalTransactionInformationCategoryForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]AdditionalTransactionInformationCategoryListing](rsp)
}

func (c *Client) CREATEAdditionalTransactionInformationCategoryUserDefinedForUser(ctx context.Context, apiKey string, userID int, params *CREATEAdditionalTransactionInformationCategoryUserDefinedForUserParams, body CREATEAdditionalTransactionInformationCategoryUserDefinedForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[AdditionalTransactionInformationCategoryUserDefinedCreate], err error) {
	req, err := NewCREATEAdditionalTransactionInformationCategoryUserDefinedForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[AdditionalTransactionInformationCategoryUserDefinedCreate](rsp)
}

func (c *Client) ListAllContentForUserAttachment(ctx context.Context, apiKey string, userID int, attachmentID int, params *ListAllContentForUserAttachmentParams, reqEditors ...RequestEditorFn) (res Result[[]AttachmentUserContentListing], err error) {
	req, err := NewListAllContentForUserAttachmentRequest(c.Server, userID, attachmentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]AttachmentUserContentListing](rsp)
}

func (c *Client) READAttachmentForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READAttachmentForUserParams, reqEditors ...RequestEditorFn) (res Result[AttachmentUserRead], err error) {
	req, err := NewREADAttachmentForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[AttachmentUserRead](rsp)
}

func (c *Client) ListAllBillingContractSubscriptionForUser(ctx context.Context, apiKey string, userID int, params *ListAllBillingContractSubscriptionForUserParams, reqEditors ...RequestEditorFn) (res Result[[]BillingContractSubscriptionListing], err error) {
	req, err := NewListAllBillingContractSubscriptionForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]BillingContractSubscriptionListing](rsp)
}

func (c *Client) ListAllBunqmeFundraiserProfileForUser(ctx context.Context, apiKey string, userID int, params *ListAllBunqmeFundraiserProfileForUserParams, reqEditors ...RequestEditorFn) (res Result[[]BunqMeFundraiserProfileUserListing], err error) {
	req, err := NewListAllBunqmeFundraiserProfileForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]BunqMeFundraiserProfileUserListing](rsp)
}

func (c *Client) READBunqmeFundraiserProfileForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READBunqmeFundraiserProfileForUserParams, reqEditors ...RequestEditorFn) (res Result[BunqMeFundraiserProfileUserRead], err error) {
	req, err := NewREADBunqmeFundraiserProfileForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[BunqMeFundraiserProfileUserRead](rsp)
}

func (c *Client) ListAllCardForUser(ctx context.Context, apiKey string, userID int, params *ListAllCardForUserParams, reqEditors ...RequestEditorFn) (res Result[[]CardListing], err error) {
	req, err := NewListAllCardForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CardListing](rsp)
}

func (c *Client) CREATECardBatchForUser(ctx context.Context, apiKey string, userID int, params *CREATECardBatchForUserParams, body CREATECardBatchForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardBatchCreate], err error) {
	req, err := NewCREATECardBatchForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardBatchCreate](rsp)
}

func (c *Client) CREATECardBatchReplaceForUser(ctx context.Context, apiKey string, userID int, params *CREATECardBatchReplaceForUserParams, body CREATECardBatchReplaceForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardBatchReplaceCreate], err error) {
	req, err := NewCREATECardBatchReplaceForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardBatchReplaceCreate](rsp)
}

func (c *Client) CREATECardCreditForUser(ctx context.Context, apiKey string, userID int, params *CREATECardCreditForUserParams, body CREATECardCreditForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardCreditCreate], err error) {
	req, err := NewCREATECardCreditForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardCreditCreate](rsp)
}

func (c *Client) CREATECardDebitForUser(ctx context.Context, apiKey string, userID int, params *CREATECardDebitForUserParams, body CREATECardDebitForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardDebitCreate], err error) {
	req, err := NewCREATECardDebitForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardDebitCreate](rsp)
}

func (c *Client) ListAllCardNameForUser(ctx context.Context, apiKey string, userID int, params *ListAllCardNameForUserParams, reqEditors ...RequestEditorFn) (res Result[[]CardNameListing], err error) {
	req, err := NewListAllCardNameForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CardNameListing](rsp)
}

func (c *Client) ListAllExportStatementCardForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllExportStatementCardForUserCardParams, reqEditors ...RequestEditorFn) (res Result[[]ExportStatementCardListing], err error) {
	req, err := NewListAllExportStatementCardForUserCardRequest(c.Server, userID, cardID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportStatementCardListing](rsp)
}

func (c *Client) ListAllExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllExportStatementCardCsvForUserCardParams, reqEditors ...RequestEditorFn) (res Result[[]ExportStatementCardCsvListing], err error) {
	req, err := NewListAllExportStatementCardCsvForUserCardRequest(c.Server, userID, cardID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportStatementCardCsvListing](rsp)
}

func (c *Client) CREATEExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEExportStatementCardCsvForUserCardParams, body CREATEExportStatementCardCsvForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ExportStatementCardCsvCreate], err error) {
	req, err := NewCREATEExportStatementCardCsvForUserCardRequest(c.Server, userID, cardID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCardCsvCreate](rsp)
}

func (c *Client) DELETEExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *DELETEExportStatementCardCsvForUserCardParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementCardCsvDelete], err error) {
	req, err := NewDELETEExportStatementCardCsvForUserCardRequest(c.Server, userID, cardID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCardCsvDelete](rsp)
}

func (c *Client) READExportStatementCardCsvForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READExportStatementCardCsvForUserCardParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementCardCsvRead], err error) {
	req, err := NewREADExportStatementCardCsvForUserCardRequest(c.Server, userID, cardID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCardCsvRead](rsp)
}

func (c *Client) ListAllExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllExportStatementCardPdfForUserCardParams, reqEditors ...RequestEditorFn) (res Result[[]ExportStatementCardPdfListing], err error) {
	req, err := NewListAllExportStatementCardPdfForUserCardRequest(c.Server, userID, cardID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportStatementCardPdfListing](rsp)
}

func (c *Client) CREATEExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEExportStatementCardPdfForUserCardParams, body CREATEExportStatementCardPdfForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ExportStatementCardPdfCreate], err error) {
	req, err := NewCREATEExportStatementCardPdfForUserCardRequest(c.Server, userID, cardID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCardPdfCreate](rsp)
}

func (c *Client) DELETEExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *DELETEExportStatementCardPdfForUserCardParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementCardPdfDelete], err error) {
	req, err := NewDELETEExportStatementCardPdfForUserCardRequest(c.Server, userID, cardID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCardPdfDelete](rsp)
}

func (c *Client) READExportStatementCardPdfForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READExportStatementCardPdfForUserCardParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementCardPdfRead], err error) {
	req, err := NewREADExportStatementCardPdfForUserCardRequest(c.Server, userID, cardID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCardPdfRead](rsp)
}

func (c *Client) ListAllContentForUserCardExportStatementCard(ctx context.Context, apiKey string, userID int, cardID int, exportStatementCardID int, params *ListAllContentForUserCardExportStatementCardParams, reqEditors ...RequestEditorFn) (res Result[[]ExportStatementCardContentListing], err error) {
	req, err := NewListAllContentForUserCardExportStatementCardRequest(c.Server, userID, cardID, exportStatementCardID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportStatementCardContentListing](rsp)
}

func (c *Client) READExportStatementCardForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READExportStatementCardForUserCardParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementCardRead], err error) {
	req, err := NewREADExportStatementCardForUserCardRequest(c.Server, userID, cardID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCardRead](rsp)
}

func (c *Client) ListAllGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *ListAllGeneratedCvc2ForUserCardParams, reqEditors ...RequestEditorFn) (res Result[[]CardGeneratedCvc2Listing], err error) {
	req, err := NewListAllGeneratedCvc2ForUserCardRequest(c.Server, userID, cardID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CardGeneratedCvc2Listing](rsp)
}

func (c *Client) CREATEGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEGeneratedCvc2ForUserCardParams, body CREATEGeneratedCvc2ForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardGeneratedCvc2Create], err error) {
	req, err := NewCREATEGeneratedCvc2ForUserCardRequest(c.Server, userID, cardID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardGeneratedCvc2Create](rsp)
}

func (c *Client) READGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *READGeneratedCvc2ForUserCardParams, reqEditors ...RequestEditorFn) (res Result[CardGeneratedCvc2Read], err error) {
	req, err := NewREADGeneratedCvc2ForUserCardRequest(c.Server, userID, cardID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardGeneratedCvc2Read](rsp)
}

func (c *Client) UPDATEGeneratedCvc2ForUserCard(ctx context.Context, apiKey string, userID int, cardID int, itemId int, params *UPDATEGeneratedCvc2ForUserCardParams, body UPDATEGeneratedCvc2ForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardGeneratedCvc2Update], err error) {
	req, err := NewUPDATEGeneratedCvc2ForUserCardRequest(c.Server, userID, cardID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardGeneratedCvc2Update](rsp)
}

func (c *Client) CREATEReplaceForUserCard(ctx context.Context, apiKey string, userID int, cardID int, params *CREATEReplaceForUserCardParams, body CREATEReplaceForUserCardJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardReplaceCreate], err error) {
	req, err := NewCREATEReplaceForUserCardRequest(c.Server, userID, cardID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardReplaceCreate](rsp)
}

func (c *Client) READCardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCardForUserParams, reqEditors ...RequestEditorFn) (res Result[CardRead], err error) {
	req, err := NewREADCardForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardRead](rsp)
}

func (c *Client) UPDATECardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATECardForUserParams, body UPDATECardForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CardUpdate], err error) {
	req, err := NewUPDATECardForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CardUpdate](rsp)
}

func (c *Client) ListAllCertificatePinnedForUser(ctx context.Context, apiKey string, userID int, params *ListAllCertificatePinnedForUserParams, reqEditors ...RequestEditorFn) (res Result[[]CertificatePinnedListing], err error) {
	req, err := NewListAllCertificatePinnedForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CertificatePinnedListing](rsp)
}

func (c *Client) CREATECertificatePinnedForUser(ctx context.Context, apiKey string, userID int, params *CREATECertificatePinnedForUserParams, body CREATECertificatePinnedForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CertificatePinnedCreate], err error) {
	req, err := NewCREATECertificatePinnedForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CertificatePinnedCreate](rsp)
}

func (c *Client) DELETECertificatePinnedForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETECertificatePinnedForUserParams, reqEditors ...RequestEditorFn) (res Result[CertificatePinnedDelete], err error) {
	req, err := NewDELETECertificatePinnedForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CertificatePinnedDelete](rsp)
}

func (c *Client) READCertificatePinnedForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCertificatePinnedForUserParams, reqEditors ...RequestEditorFn) (res Result[CertificatePinnedRead], err error) {
	req, err := NewREADCertificatePinnedForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CertificatePinnedRead](rsp)
}

func (c *Client) READChallengeRequestForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READChallengeRequestForUserParams, reqEditors ...RequestEditorFn) (res Result[MasterCardIdentityCheckChallengeRequestUserRead], err error) {
	req, err := NewREADChallengeRequestForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MasterCardIdentityCheckChallengeRequestUserRead](rsp)
}

func (c *Client) UPDATEChallengeRequestForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEChallengeRequestForUserParams, body UPDATEChallengeRequestForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MasterCardIdentityCheckChallengeRequestUserUpdate], err error) {
	req, err := NewUPDATEChallengeRequestForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MasterCardIdentityCheckChallengeRequestUserUpdate](rsp)
}

func (c *Client) ListAllContentForUserChatConversationAttachment(ctx context.Context, apiKey string, userID int, chatConversationID int, attachmentID int, params *ListAllContentForUserChatConversationAttachmentParams, reqEditors ...RequestEditorFn) (res Result[[]AttachmentConversationContentListing], err error) {
	req, err := NewListAllContentForUserChatConversationAttachmentRequest(c.Server, userID, chatConversationID, attachmentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]AttachmentConversationContentListing](rsp)
}

func (c *Client) ListAllCompanyForUser(ctx context.Context, apiKey string, userID int, params *ListAllCompanyForUserParams, reqEditors ...RequestEditorFn) (res Result[[]CompanyListing], err error) {
	req, err := NewListAllCompanyForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CompanyListing](rsp)
}

func (c *Client) CREATECompanyForUser(ctx context.Context, apiKey string, userID int, params *CREATECompanyForUserParams, body CREATECompanyForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CompanyCreate], err error) {
	req, err := NewCREATECompanyForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CompanyCreate](rsp)
}

func (c *Client) READCompanyForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCompanyForUserParams, reqEditors ...RequestEditorFn) (res Result[CompanyRead], err error) {
	req, err := NewREADCompanyForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CompanyRead](rsp)
}

func (c *Client) UPDATECompanyForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATECompanyForUserParams, body UPDATECompanyForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CompanyUpdate], err error) {
	req, err := NewUPDATECompanyForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CompanyUpdate](rsp)
}

func (c *Client) CREATEConfirmationOfFundsForUser(ctx context.Context, apiKey string, userID int, params *CREATEConfirmationOfFundsForUserParams, body CREATEConfirmationOfFundsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ConfirmationOfFundsCreate], err error) {
	req, err := NewCREATEConfirmationOfFundsForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ConfirmationOfFundsCreate](rsp)
}

func (c *Client) ListAllCredentialPasswordIpForUser(ctx context.Context, apiKey string, userID int, params *ListAllCredentialPasswordIpForUserParams, reqEditors ...RequestEditorFn) (res Result[[]UserCredentialPasswordIpListing], err error) {
	req, err := NewListAllCredentialPasswordIpForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]UserCredentialPasswordIpListing](rsp)
}

func (c *Client) ListAllIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, params *ListAllIpForUserCredentialPasswordIpParams, reqEditors ...RequestEditorFn) (res Result[[]PermittedIpListing], err error) {
	req, err := NewListAllIpForUserCredentialPasswordIpRequest(c.Server, userID, credentialPasswordIpID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PermittedIpListing](rsp)
}

func (c *Client) CREATEIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, params *CREATEIpForUserCredentialPasswordIpParams, body CREATEIpForUserCredentialPasswordIpJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PermittedIpCreate], err error) {
	req, err := NewCREATEIpForUserCredentialPasswordIpRequest(c.Server, userID, credentialPasswordIpID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PermittedIpCreate](rsp)
}

func (c *Client) READIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, itemId int, params *READIpForUserCredentialPasswordIpParams, reqEditors ...RequestEditorFn) (res Result[PermittedIpRead], err error) {
	req, err := NewREADIpForUserCredentialPasswordIpRequest(c.Server, userID, credentialPasswordIpID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PermittedIpRead](rsp)
}

func (c *Client) UPDATEIpForUserCredentialPasswordIp(ctx context.Context, apiKey string, userID int, credentialPasswordIpID int, itemId int, params *UPDATEIpForUserCredentialPasswordIpParams, body UPDATEIpForUserCredentialPasswordIpJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PermittedIpUpdate], err error) {
	req, err := NewUPDATEIpForUserCredentialPasswordIpRequest(c.Server, userID, credentialPasswordIpID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PermittedIpUpdate](rsp)
}

func (c *Client) READCredentialPasswordIpForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCredentialPasswordIpForUserParams, reqEditors ...RequestEditorFn) (res Result[UserCredentialPasswordIpRead], err error) {
	req, err := NewREADCredentialPasswordIpForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[UserCredentialPasswordIpRead](rsp)
}

func (c *Client) ListAllCurrencyCloudBeneficiaryForUser(ctx context.Context, apiKey string, userID int, params *ListAllCurrencyCloudBeneficiaryForUserParams, reqEditors ...RequestEditorFn) (res Result[[]CurrencyCloudBeneficiaryListing], err error) {
	req, err := NewListAllCurrencyCloudBeneficiaryForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CurrencyCloudBeneficiaryListing](rsp)
}

func (c *Client) CREATECurrencyCloudBeneficiaryForUser(ctx context.Context, apiKey string, userID int, params *CREATECurrencyCloudBeneficiaryForUserParams, body CREATECurrencyCloudBeneficiaryForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CurrencyCloudBeneficiaryCreate], err error) {
	req, err := NewCREATECurrencyCloudBeneficiaryForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CurrencyCloudBeneficiaryCreate](rsp)
}

func (c *Client) ListAllCurrencyCloudBeneficiaryRequirementForUser(ctx context.Context, apiKey string, userID int, params *ListAllCurrencyCloudBeneficiaryRequirementForUserParams, reqEditors ...RequestEditorFn) (res Result[[]CurrencyCloudBeneficiaryRequirementListing], err error) {
	req, err := NewListAllCurrencyCloudBeneficiaryRequirementForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CurrencyCloudBeneficiaryRequirementListing](rsp)
}

func (c *Client) READCurrencyCloudBeneficiaryForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READCurrencyCloudBeneficiaryForUserParams, reqEditors ...RequestEditorFn) (res Result[CurrencyCloudBeneficiaryRead], err error) {
	req, err := NewREADCurrencyCloudBeneficiaryForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CurrencyCloudBeneficiaryRead](rsp)
}

func (c *Client) ListAllEventForUser(ctx context.Context, apiKey string, userID int, params *ListAllEventForUserParams, reqEditors ...RequestEditorFn) (res Result[[]EventListing], err error) {
	req, err := NewListAllEventForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]EventListing](rsp)
}

func (c *Client) READEventForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READEventForUserParams, reqEditors ...RequestEditorFn) (res Result[EventRead], err error) {
	req, err := NewREADEventForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[EventRead](rsp)
}

func (c *Client) ListAllExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, params *ListAllExportAnnualOverviewForUserParams, reqEditors ...RequestEditorFn) (res Result[[]ExportAnnualOverviewListing], err error) {
	req, err := NewListAllExportAnnualOverviewForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportAnnualOverviewListing](rsp)
}

func (c *Client) CREATEExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, params *CREATEExportAnnualOverviewForUserParams, body CREATEExportAnnualOverviewForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ExportAnnualOverviewCreate], err error) {
	req, err := NewCREATEExportAnnualOverviewForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportAnnualOverviewCreate](rsp)
}

func (c *Client) ListAllContentForUserExportAnnualOverview(ctx context.Context, apiKey string, userID int, exportAnnualOverviewID int, params *ListAllContentForUserExportAnnualOverviewParams, reqEditors ...RequestEditorFn) (res Result[[]ExportAnnualOverviewContentListing], err error) {
	req, err := NewListAllContentForUserExportAnnualOverviewRequest(c.Server, userID, exportAnnualOverviewID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportAnnualOverviewContentListing](rsp)
}

func (c *Client) DELETEExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETEExportAnnualOverviewForUserParams, reqEditors ...RequestEditorFn) (res Result[ExportAnnualOverviewDelete], err error) {
	req, err := NewDELETEExportAnnualOverviewForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportAnnualOverviewDelete](rsp)
}

func (c *Client) READExportAnnualOverviewForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READExportAnnualOverviewForUserParams, reqEditors ...RequestEditorFn) (res Result[ExportAnnualOverviewRead], err error) {
	req, err := NewREADExportAnnualOverviewForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportAnnualOverviewRead](rsp)
}

func (c *Client) READFeatureAnnouncementForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READFeatureAnnouncementForUserParams, reqEditors ...RequestEditorFn) (res Result[FeatureAnnouncementRead], err error) {
	req, err := NewREADFeatureAnnouncementForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[FeatureAnnouncementRead](rsp)
}

func (c *Client) ListAllInsightPreferenceDateForUser(ctx context.Context, apiKey string, userID int, params *ListAllInsightPreferenceDateForUserParams, reqEditors ...RequestEditorFn) (res Result[[]InsightPreferenceDateListing], err error) {
	req, err := NewListAllInsightPreferenceDateForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InsightPreferenceDateListing](rsp)
}

func (c *Client) ListAllInsightsForUser(ctx context.Context, apiKey string, userID int, params *ListAllInsightsForUserParams, reqEditors ...RequestEditorFn) (res Result[[]InsightListing], err error) {
	req, err := NewListAllInsightsForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InsightListing](rsp)
}

func (c *Client) ListAllInsightsSearchForUser(ctx context.Context, apiKey string, userID int, params *ListAllInsightsSearchForUserParams, reqEditors ...RequestEditorFn) (res Result[[]InsightEventListing], err error) {
	req, err := NewListAllInsightsSearchForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InsightEventListing](rsp)
}

func (c *Client) ListAllInvoiceForUser(ctx context.Context, apiKey string, userID int, params *ListAllInvoiceForUserParams, reqEditors ...RequestEditorFn) (res Result[[]InvoiceByUserListing], err error) {
	req, err := NewListAllInvoiceForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InvoiceByUserListing](rsp)
}

func (c *Client) CREATEInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, params *CREATEInvoiceExportForUserInvoiceParams, body CREATEInvoiceExportForUserInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[InvoiceExportPdfCreate], err error) {
	req, err := NewCREATEInvoiceExportForUserInvoiceRequest(c.Server, userID, invoiceID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[InvoiceExportPdfCreate](rsp)
}

func (c *Client) DELETEInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, itemId int, params *DELETEInvoiceExportForUserInvoiceParams, reqEditors ...RequestEditorFn) (res Result[InvoiceExportPdfDelete], err error) {
	req, err := NewDELETEInvoiceExportForUserInvoiceRequest(c.Server, userID, invoiceID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[InvoiceExportPdfDelete](rsp)
}

func (c *Client) READInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, itemId int, params *READInvoiceExportForUserInvoiceParams, reqEditors ...RequestEditorFn) (res Result[InvoiceExportPdfRead], err error) {
	req, err := NewREADInvoiceExportForUserInvoiceRequest(c.Server, userID, invoiceID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[InvoiceExportPdfRead](rsp)
}

func (c *Client) UPDATEInvoiceExportForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, itemId int, params *UPDATEInvoiceExportForUserInvoiceParams, body UPDATEInvoiceExportForUserInvoiceJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[InvoiceExportPdfUpdate], err error) {
	req, err := NewUPDATEInvoiceExportForUserInvoiceRequest(c.Server, userID, invoiceID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[InvoiceExportPdfUpdate](rsp)
}

func (c *Client) ListAllPdfContentForUserInvoice(ctx context.Context, apiKey string, userID int, invoiceID int, params *ListAllPdfContentForUserInvoiceParams, reqEditors ...RequestEditorFn) (res Result[[]InvoiceExportPdfContentListing], err error) {
	req, err := NewListAllPdfContentForUserInvoiceRequest(c.Server, userID, invoiceID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InvoiceExportPdfContentListing](rsp)
}

func (c *Client) READInvoiceForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READInvoiceForUserParams, reqEditors ...RequestEditorFn) (res Result[InvoiceByUserRead], err error) {
	req, err := NewREADInvoiceForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[InvoiceByUserRead](rsp)
}

func (c *Client) ListAllLegalNameForUser(ctx context.Context, apiKey string, userID int, params *ListAllLegalNameForUserParams, reqEditors ...RequestEditorFn) (res Result[[]UserLegalNameListing], err error) {
	req, err := NewListAllLegalNameForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]UserLegalNameListing](rsp)
}

func (c *Client) ListAllLimitForUser(ctx context.Context, apiKey string, userID int, params *ListAllLimitForUserParams, reqEditors ...RequestEditorFn) (res Result[[]CustomerLimitListing], err error) {
	req, err := NewListAllLimitForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CustomerLimitListing](rsp)
}

func (c *Client) ListAllMonetaryAccountForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountForUserParams, reqEditors ...RequestEditorFn) (res Result[[]MonetaryAccountListing], err error) {
	req, err := NewListAllMonetaryAccountForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MonetaryAccountListing](rsp)
}

func (c *Client) ListAllMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountBankForUserParams, reqEditors ...RequestEditorFn) (res Result[[]MonetaryAccountBankListing], err error) {
	req, err := NewListAllMonetaryAccountBankForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MonetaryAccountBankListing](rsp)
}

func (c *Client) CREATEMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountBankForUserParams, body CREATEMonetaryAccountBankForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountBankCreate], err error) {
	req, err := NewCREATEMonetaryAccountBankForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountBankCreate](rsp)
}

func (c *Client) READMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountBankForUserParams, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountBankRead], err error) {
	req, err := NewREADMonetaryAccountBankForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountBankRead](rsp)
}

func (c *Client) UPDATEMonetaryAccountBankForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountBankForUserParams, body UPDATEMonetaryAccountBankForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountBankUpdate], err error) {
	req, err := NewUPDATEMonetaryAccountBankForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountBankUpdate](rsp)
}

func (c *Client) ListAllMonetaryAccountCardForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountCardForUserParams, reqEditors ...RequestEditorFn) (res Result[[]MonetaryAccountCardListing], err error) {
	req, err := NewListAllMonetaryAccountCardForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MonetaryAccountCardListing](rsp)
}

func (c *Client) READMonetaryAccountCardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountCardForUserParams, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountCardRead], err error) {
	req, err := NewREADMonetaryAccountCardForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountCardRead](rsp)
}

func (c *Client) UPDATEMonetaryAccountCardForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountCardForUserParams, body UPDATEMonetaryAccountCardForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountCardUpdate], err error) {
	req, err := NewUPDATEMonetaryAccountCardForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountCardUpdate](rsp)
}

func (c *Client) ListAllMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountExternalForUserParams, reqEditors ...RequestEditorFn) (res Result[[]MonetaryAccountExternalListing], err error) {
	req, err := NewListAllMonetaryAccountExternalForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MonetaryAccountExternalListing](rsp)
}

func (c *Client) CREATEMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountExternalForUserParams, body CREATEMonetaryAccountExternalForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountExternalCreate], err error) {
	req, err := NewCREATEMonetaryAccountExternalForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountExternalCreate](rsp)
}

func (c *Client) ListAllMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountExternalSavingsForUserParams, reqEditors ...RequestEditorFn) (res Result[[]MonetaryAccountExternalSavingsListing], err error) {
	req, err := NewListAllMonetaryAccountExternalSavingsForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MonetaryAccountExternalSavingsListing](rsp)
}

func (c *Client) CREATEMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountExternalSavingsForUserParams, body CREATEMonetaryAccountExternalSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountExternalSavingsCreate], err error) {
	req, err := NewCREATEMonetaryAccountExternalSavingsForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountExternalSavingsCreate](rsp)
}

func (c *Client) READMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountExternalSavingsForUserParams, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountExternalSavingsRead], err error) {
	req, err := NewREADMonetaryAccountExternalSavingsForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountExternalSavingsRead](rsp)
}

func (c *Client) UPDATEMonetaryAccountExternalSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountExternalSavingsForUserParams, body UPDATEMonetaryAccountExternalSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountExternalSavingsUpdate], err error) {
	req, err := NewUPDATEMonetaryAccountExternalSavingsForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountExternalSavingsUpdate](rsp)
}

func (c *Client) READMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountExternalForUserParams, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountExternalRead], err error) {
	req, err := NewREADMonetaryAccountExternalForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountExternalRead](rsp)
}

func (c *Client) UPDATEMonetaryAccountExternalForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountExternalForUserParams, body UPDATEMonetaryAccountExternalForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountExternalUpdate], err error) {
	req, err := NewUPDATEMonetaryAccountExternalForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountExternalUpdate](rsp)
}

func (c *Client) ListAllMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountJointForUserParams, reqEditors ...RequestEditorFn) (res Result[[]MonetaryAccountJointListing], err error) {
	req, err := NewListAllMonetaryAccountJointForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MonetaryAccountJointListing](rsp)
}

func (c *Client) CREATEMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountJointForUserParams, body CREATEMonetaryAccountJointForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountJointCreate], err error) {
	req, err := NewCREATEMonetaryAccountJointForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountJointCreate](rsp)
}

func (c *Client) READMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountJointForUserParams, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountJointRead], err error) {
	req, err := NewREADMonetaryAccountJointForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountJointRead](rsp)
}

func (c *Client) UPDATEMonetaryAccountJointForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountJointForUserParams, body UPDATEMonetaryAccountJointForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountJointUpdate], err error) {
	req, err := NewUPDATEMonetaryAccountJointForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountJointUpdate](rsp)
}

func (c *Client) ListAllMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, params *ListAllMonetaryAccountSavingsForUserParams, reqEditors ...RequestEditorFn) (res Result[[]MonetaryAccountSavingsListing], err error) {
	req, err := NewListAllMonetaryAccountSavingsForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MonetaryAccountSavingsListing](rsp)
}

func (c *Client) CREATEMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, params *CREATEMonetaryAccountSavingsForUserParams, body CREATEMonetaryAccountSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountSavingsCreate], err error) {
	req, err := NewCREATEMonetaryAccountSavingsForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountSavingsCreate](rsp)
}

func (c *Client) READMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountSavingsForUserParams, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountSavingsRead], err error) {
	req, err := NewREADMonetaryAccountSavingsForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountSavingsRead](rsp)
}

func (c *Client) UPDATEMonetaryAccountSavingsForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEMonetaryAccountSavingsForUserParams, body UPDATEMonetaryAccountSavingsForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountSavingsUpdate], err error) {
	req, err := NewUPDATEMonetaryAccountSavingsForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountSavingsUpdate](rsp)
}

func (c *Client) READMonetaryAccountForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READMonetaryAccountForUserParams, reqEditors ...RequestEditorFn) (res Result[MonetaryAccountRead], err error) {
	req, err := NewREADMonetaryAccountForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MonetaryAccountRead](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentAdyenCardTransactionListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentAdyenCardTransactionListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentAdyenCardTransactionCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentAdyenCardTransactionCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentAdyenCardTransactionDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentAdyenCardTransactionDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentAdyenCardTransactionRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentAdyenCardTransactionRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentAdyenCardTransactionUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentAdyenCardTransactionUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *ListAllNoteTextForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextAdyenCardTransactionListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextAdyenCardTransactionListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, body CREATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextAdyenCardTransactionCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextAdyenCardTransactionCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextAdyenCardTransactionDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextAdyenCardTransactionDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountAdyenCardTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextAdyenCardTransactionRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextAdyenCardTransactionRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountAdyenCardTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, body UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextAdyenCardTransactionUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountAdyenCardTransactionRequest(c.Server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextAdyenCardTransactionUpdate](rsp)
}

func (c *Client) CREATEAttachmentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEAttachmentForUserMonetaryAccountParams, body CREATEAttachmentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[AttachmentMonetaryAccountCreate], err error) {
	req, err := NewCREATEAttachmentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[AttachmentMonetaryAccountCreate](rsp)
}

func (c *Client) ListAllContentForUserMonetaryAccountAttachment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, attachmentID int, params *ListAllContentForUserMonetaryAccountAttachmentParams, reqEditors ...RequestEditorFn) (res Result[[]AttachmentMonetaryAccountContentListing], err error) {
	req, err := NewListAllContentForUserMonetaryAccountAttachmentRequest(c.Server, userID, monetaryAccountID, attachmentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]AttachmentMonetaryAccountContentListing](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentBunqMeFundraiserResultListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentBunqMeFundraiserResultListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, body CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBunqMeFundraiserResultCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBunqMeFundraiserResultCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBunqMeFundraiserResultDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBunqMeFundraiserResultDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBunqMeFundraiserResultRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBunqMeFundraiserResultRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, body UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBunqMeFundraiserResultUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBunqMeFundraiserResultUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextBunqMeFundraiserResultListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextBunqMeFundraiserResultListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, body CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextBunqMeFundraiserResultCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBunqMeFundraiserResultCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (res Result[NoteTextBunqMeFundraiserResultDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBunqMeFundraiserResultDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *READNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, reqEditors ...RequestEditorFn) (res Result[NoteTextBunqMeFundraiserResultRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBunqMeFundraiserResultRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, body UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextBunqMeFundraiserResultUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(c.Server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBunqMeFundraiserResultUpdate](rsp)
}

func (c *Client) READBunqmeFundraiserResultForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READBunqmeFundraiserResultForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[BunqMeFundraiserResultRead], err error) {
	req, err := NewREADBunqmeFundraiserResultForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[BunqMeFundraiserResultRead](rsp)
}

func (c *Client) ListAllBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllBunqmeTabForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]BunqMeTabListing], err error) {
	req, err := NewListAllBunqmeTabForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]BunqMeTabListing](rsp)
}

func (c *Client) CREATEBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEBunqmeTabForUserMonetaryAccountParams, body CREATEBunqmeTabForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[BunqMeTabCreate], err error) {
	req, err := NewCREATEBunqmeTabForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[BunqMeTabCreate](rsp)
}

func (c *Client) READBunqmeTabResultResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READBunqmeTabResultResponseForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[BunqMeTabResultResponseRead], err error) {
	req, err := NewREADBunqmeTabResultResponseForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[BunqMeTabResultResponseRead](rsp)
}

func (c *Client) READBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READBunqmeTabForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[BunqMeTabRead], err error) {
	req, err := NewREADBunqmeTabForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[BunqMeTabRead](rsp)
}

func (c *Client) UPDATEBunqmeTabForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEBunqmeTabForUserMonetaryAccountParams, body UPDATEBunqmeTabForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[BunqMeTabUpdate], err error) {
	req, err := NewUPDATEBunqmeTabForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[BunqMeTabUpdate](rsp)
}

func (c *Client) CREATECurrencyCloudPaymentQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountParams, body CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CurrencyCloudPaymentQuoteCreate], err error) {
	req, err := NewCREATECurrencyCloudPaymentQuoteForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CurrencyCloudPaymentQuoteCreate](rsp)
}

func (c *Client) ListAllCurrencyConversionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllCurrencyConversionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]CurrencyConversionListing], err error) {
	req, err := NewListAllCurrencyConversionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]CurrencyConversionListing](rsp)
}

func (c *Client) CREATECurrencyConversionQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATECurrencyConversionQuoteForUserMonetaryAccountParams, body CREATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CurrencyConversionQuoteCreate], err error) {
	req, err := NewCREATECurrencyConversionQuoteForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CurrencyConversionQuoteCreate](rsp)
}

func (c *Client) READCurrencyConversionQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READCurrencyConversionQuoteForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[CurrencyConversionQuoteRead], err error) {
	req, err := NewREADCurrencyConversionQuoteForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CurrencyConversionQuoteRead](rsp)
}

func (c *Client) UPDATECurrencyConversionQuoteForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATECurrencyConversionQuoteForUserMonetaryAccountParams, body UPDATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[CurrencyConversionQuoteUpdate], err error) {
	req, err := NewUPDATECurrencyConversionQuoteForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CurrencyConversionQuoteUpdate](rsp)
}

func (c *Client) READCurrencyConversionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READCurrencyConversionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[CurrencyConversionRead], err error) {
	req, err := NewREADCurrencyConversionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[CurrencyConversionRead](rsp)
}

func (c *Client) ListAllCustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllCustomerStatementForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]ExportStatementListing], err error) {
	req, err := NewListAllCustomerStatementForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportStatementListing](rsp)
}

func (c *Client) CREATECustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATECustomerStatementForUserMonetaryAccountParams, body CREATECustomerStatementForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ExportStatementCreate], err error) {
	req, err := NewCREATECustomerStatementForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementCreate](rsp)
}

func (c *Client) ListAllContentForUserMonetaryAccountCustomerStatement(ctx context.Context, apiKey string, userID int, monetaryAccountID int, customerStatementID int, params *ListAllContentForUserMonetaryAccountCustomerStatementParams, reqEditors ...RequestEditorFn) (res Result[[]ExportStatementContentListing], err error) {
	req, err := NewListAllContentForUserMonetaryAccountCustomerStatementRequest(c.Server, userID, monetaryAccountID, customerStatementID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportStatementContentListing](rsp)
}

func (c *Client) DELETECustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETECustomerStatementForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementDelete], err error) {
	req, err := NewDELETECustomerStatementForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementDelete](rsp)
}

func (c *Client) READCustomerStatementForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READCustomerStatementForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementRead], err error) {
	req, err := NewREADCustomerStatementForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementRead](rsp)
}

func (c *Client) ListAllDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllDraftPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]DraftPaymentListing], err error) {
	req, err := NewListAllDraftPaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]DraftPaymentListing](rsp)
}

func (c *Client) CREATEDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEDraftPaymentForUserMonetaryAccountParams, body CREATEDraftPaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[DraftPaymentCreate], err error) {
	req, err := NewCREATEDraftPaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[DraftPaymentCreate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentDraftPaymentListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentDraftPaymentListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, body CREATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentDraftPaymentCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentDraftPaymentCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentDraftPaymentDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentDraftPaymentDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentDraftPaymentRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentDraftPaymentRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentDraftPaymentUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentDraftPaymentUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *ListAllNoteTextForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextDraftPaymentListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextDraftPaymentListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteTextForUserMonetaryAccountDraftPaymentParams, body CREATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextDraftPaymentCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextDraftPaymentCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextDraftPaymentDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextDraftPaymentDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountDraftPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextDraftPaymentRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextDraftPaymentRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountDraftPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountDraftPaymentParams, body UPDATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextDraftPaymentUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountDraftPaymentRequest(c.Server, userID, monetaryAccountID, draftPaymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextDraftPaymentUpdate](rsp)
}

func (c *Client) READDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READDraftPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[DraftPaymentRead], err error) {
	req, err := NewREADDraftPaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[DraftPaymentRead](rsp)
}

func (c *Client) UPDATEDraftPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEDraftPaymentForUserMonetaryAccountParams, body UPDATEDraftPaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[DraftPaymentUpdate], err error) {
	req, err := NewUPDATEDraftPaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[DraftPaymentUpdate](rsp)
}

func (c *Client) CREATEStatementForUserMonetaryAccountEvent(ctx context.Context, apiKey string, userID int, monetaryAccountID int, eventID int, params *CREATEStatementForUserMonetaryAccountEventParams, body CREATEStatementForUserMonetaryAccountEventJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ExportStatementPaymentCreate], err error) {
	req, err := NewCREATEStatementForUserMonetaryAccountEventRequest(c.Server, userID, monetaryAccountID, eventID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementPaymentCreate](rsp)
}

func (c *Client) READStatementForUserMonetaryAccountEvent(ctx context.Context, apiKey string, userID int, monetaryAccountID int, eventID int, itemId int, params *READStatementForUserMonetaryAccountEventParams, reqEditors ...RequestEditorFn) (res Result[ExportStatementPaymentRead], err error) {
	req, err := NewREADStatementForUserMonetaryAccountEventRequest(c.Server, userID, monetaryAccountID, eventID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportStatementPaymentRead](rsp)
}

func (c *Client) ListAllContentForUserMonetaryAccountEventStatement(ctx context.Context, apiKey string, userID int, monetaryAccountID int, eventID int, statementID int, params *ListAllContentForUserMonetaryAccountEventStatementParams, reqEditors ...RequestEditorFn) (res Result[[]ExportStatementPaymentContentListing], err error) {
	req, err := NewListAllContentForUserMonetaryAccountEventStatementRequest(c.Server, userID, monetaryAccountID, eventID, statementID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportStatementPaymentContentListing](rsp)
}

func (c *Client) ListAllExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllExportRibForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]ExportRibListing], err error) {
	req, err := NewListAllExportRibForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportRibListing](rsp)
}

func (c *Client) CREATEExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEExportRibForUserMonetaryAccountParams, body CREATEExportRibForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ExportRibCreate], err error) {
	req, err := NewCREATEExportRibForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportRibCreate](rsp)
}

func (c *Client) ListAllContentForUserMonetaryAccountExportRib(ctx context.Context, apiKey string, userID int, monetaryAccountID int, exportRibID int, params *ListAllContentForUserMonetaryAccountExportRibParams, reqEditors ...RequestEditorFn) (res Result[[]ExportRibContentListing], err error) {
	req, err := NewListAllContentForUserMonetaryAccountExportRibRequest(c.Server, userID, monetaryAccountID, exportRibID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ExportRibContentListing](rsp)
}

func (c *Client) DELETEExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETEExportRibForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[ExportRibDelete], err error) {
	req, err := NewDELETEExportRibForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportRibDelete](rsp)
}

func (c *Client) READExportRibForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READExportRibForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[ExportRibRead], err error) {
	req, err := NewREADExportRibForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ExportRibRead](rsp)
}

func (c *Client) ListAllIdealMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllIdealMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]IdealMerchantTransactionListing], err error) {
	req, err := NewListAllIdealMerchantTransactionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]IdealMerchantTransactionListing](rsp)
}

func (c *Client) CREATEIdealMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEIdealMerchantTransactionForUserMonetaryAccountParams, body CREATEIdealMerchantTransactionForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[IdealMerchantTransactionCreate], err error) {
	req, err := NewCREATEIdealMerchantTransactionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[IdealMerchantTransactionCreate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentIdealMerchantTransactionListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentIdealMerchantTransactionListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentIdealMerchantTransactionCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentIdealMerchantTransactionCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentIdealMerchantTransactionDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentIdealMerchantTransactionDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentIdealMerchantTransactionRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentIdealMerchantTransactionRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentIdealMerchantTransactionUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentIdealMerchantTransactionUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextIdealMerchantTransactionListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextIdealMerchantTransactionListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextIdealMerchantTransactionCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextIdealMerchantTransactionCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextIdealMerchantTransactionDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextIdealMerchantTransactionDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountIdealMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextIdealMerchantTransactionRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextIdealMerchantTransactionRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountIdealMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextIdealMerchantTransactionUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(c.Server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextIdealMerchantTransactionUpdate](rsp)
}

func (c *Client) READIdealMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READIdealMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[IdealMerchantTransactionRead], err error) {
	req, err := NewREADIdealMerchantTransactionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[IdealMerchantTransactionRead](rsp)
}

func (c *Client) ListAllInvoiceForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllInvoiceForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]InvoiceListing], err error) {
	req, err := NewListAllInvoiceForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]InvoiceListing](rsp)
}

func (c *Client) READInvoiceForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READInvoiceForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[InvoiceRead], err error) {
	req, err := NewREADInvoiceForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[InvoiceRead](rsp)
}

func (c *Client) ListAllMastercardActionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllMastercardActionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]MasterCardActionListing], err error) {
	req, err := NewListAllMastercardActionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MasterCardActionListing](rsp)
}

func (c *Client) READMastercardActionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READMastercardActionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[MasterCardActionRead], err error) {
	req, err := NewREADMastercardActionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[MasterCardActionRead](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllNoteAttachmentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentMasterCardActionListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentMasterCardActionListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteAttachmentForUserMonetaryAccountMastercardActionParams, body CREATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentMasterCardActionCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentMasterCardActionCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentMasterCardActionDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentMasterCardActionDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentMasterCardActionRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentMasterCardActionRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountMastercardActionParams, body UPDATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentMasterCardActionUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentMasterCardActionUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllNoteTextForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextMasterCardActionListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextMasterCardActionListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteTextForUserMonetaryAccountMastercardActionParams, body CREATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextMasterCardActionCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextMasterCardActionCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextMasterCardActionDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextMasterCardActionDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *READNoteTextForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextMasterCardActionRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextMasterCardActionRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountMastercardActionParams, body UPDATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextMasterCardActionUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextMasterCardActionUpdate](rsp)
}

func (c *Client) ListAllPaymentForUserMonetaryAccountMastercardAction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllPaymentForUserMonetaryAccountMastercardActionParams, reqEditors ...RequestEditorFn) (res Result[[]MasterCardPaymentListing], err error) {
	req, err := NewListAllPaymentForUserMonetaryAccountMastercardActionRequest(c.Server, userID, monetaryAccountID, mastercardActionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]MasterCardPaymentListing](rsp)
}

func (c *Client) ListAllNotificationFilterUrlForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllNotificationFilterUrlForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]NotificationFilterUrlMonetaryAccountListing], err error) {
	req, err := NewListAllNotificationFilterUrlForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NotificationFilterUrlMonetaryAccountListing](rsp)
}

func (c *Client) CREATENotificationFilterUrlForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATENotificationFilterUrlForUserMonetaryAccountParams, body CREATENotificationFilterUrlForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NotificationFilterUrlMonetaryAccountCreate], err error) {
	req, err := NewCREATENotificationFilterUrlForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NotificationFilterUrlMonetaryAccountCreate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentOpenBankingMerchantTransactionListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentOpenBankingMerchantTransactionListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentOpenBankingMerchantTransactionCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentOpenBankingMerchantTransactionCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentOpenBankingMerchantTransactionDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentOpenBankingMerchantTransactionDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentOpenBankingMerchantTransactionRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentOpenBankingMerchantTransactionRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentOpenBankingMerchantTransactionUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentOpenBankingMerchantTransactionUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextOpenBankingMerchantTransactionListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextOpenBankingMerchantTransactionListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextOpenBankingMerchantTransactionCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextOpenBankingMerchantTransactionCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextOpenBankingMerchantTransactionDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextOpenBankingMerchantTransactionDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextOpenBankingMerchantTransactionRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextOpenBankingMerchantTransactionRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextOpenBankingMerchantTransactionUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(c.Server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextOpenBankingMerchantTransactionUpdate](rsp)
}

func (c *Client) ListAllPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentListing], err error) {
	req, err := NewListAllPaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentListing](rsp)
}

func (c *Client) CREATEPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEPaymentForUserMonetaryAccountParams, body CREATEPaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentCreate], err error) {
	req, err := NewCREATEPaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentCreate](rsp)
}

func (c *Client) ListAllPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllPaymentAutoAllocateForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentAutoAllocateListing], err error) {
	req, err := NewListAllPaymentAutoAllocateForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentAutoAllocateListing](rsp)
}

func (c *Client) CREATEPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEPaymentAutoAllocateForUserMonetaryAccountParams, body CREATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentAutoAllocateCreate], err error) {
	req, err := NewCREATEPaymentAutoAllocateForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentAutoAllocateCreate](rsp)
}

func (c *Client) DELETEPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETEPaymentAutoAllocateForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[PaymentAutoAllocateDelete], err error) {
	req, err := NewDELETEPaymentAutoAllocateForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentAutoAllocateDelete](rsp)
}

func (c *Client) READPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READPaymentAutoAllocateForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[PaymentAutoAllocateRead], err error) {
	req, err := NewREADPaymentAutoAllocateForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentAutoAllocateRead](rsp)
}

func (c *Client) UPDATEPaymentAutoAllocateForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentAutoAllocateForUserMonetaryAccountParams, body UPDATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentAutoAllocateUpdate], err error) {
	req, err := NewUPDATEPaymentAutoAllocateForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentAutoAllocateUpdate](rsp)
}

func (c *Client) ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocate(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentAutoAllocateID int, params *ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentAutoAllocateDefinitionListing], err error) {
	req, err := NewListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateRequest(c.Server, userID, monetaryAccountID, paymentAutoAllocateID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentAutoAllocateDefinitionListing](rsp)
}

func (c *Client) ListAllInstanceForUserMonetaryAccountPaymentAutoAllocate(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentAutoAllocateID int, params *ListAllInstanceForUserMonetaryAccountPaymentAutoAllocateParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentAutoAllocateInstanceListing], err error) {
	req, err := NewListAllInstanceForUserMonetaryAccountPaymentAutoAllocateRequest(c.Server, userID, monetaryAccountID, paymentAutoAllocateID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentAutoAllocateInstanceListing](rsp)
}

func (c *Client) READInstanceForUserMonetaryAccountPaymentAutoAllocate(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentAutoAllocateID int, itemId int, params *READInstanceForUserMonetaryAccountPaymentAutoAllocateParams, reqEditors ...RequestEditorFn) (res Result[PaymentAutoAllocateInstanceRead], err error) {
	req, err := NewREADInstanceForUserMonetaryAccountPaymentAutoAllocateRequest(c.Server, userID, monetaryAccountID, paymentAutoAllocateID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentAutoAllocateInstanceRead](rsp)
}

func (c *Client) ListAllPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllPaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentBatchListing], err error) {
	req, err := NewListAllPaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentBatchListing](rsp)
}

func (c *Client) CREATEPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEPaymentBatchForUserMonetaryAccountParams, body CREATEPaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentBatchCreate], err error) {
	req, err := NewCREATEPaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentBatchCreate](rsp)
}

func (c *Client) READPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READPaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[PaymentBatchRead], err error) {
	req, err := NewREADPaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentBatchRead](rsp)
}

func (c *Client) UPDATEPaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentBatchForUserMonetaryAccountParams, body UPDATEPaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentBatchUpdate], err error) {
	req, err := NewUPDATEPaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentBatchUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentPaymentBatchListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentPaymentBatchListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentBatchCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentBatchCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentBatchDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentBatchDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentBatchRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentBatchRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentBatchUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentBatchUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *ListAllNoteTextForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextPaymentBatchListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextPaymentBatchListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteTextForUserMonetaryAccountPaymentBatchParams, body CREATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentBatchCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentBatchCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentBatchDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentBatchDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentBatchRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentBatchRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountPaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentBatchParams, body UPDATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentBatchUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountPaymentBatchRequest(c.Server, userID, monetaryAccountID, paymentBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentBatchUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentPaymentDelayedListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentPaymentDelayedListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentDelayedCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentDelayedCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentDelayedDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentDelayedDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentDelayedRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentDelayedRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentDelayedUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentDelayedUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *ListAllNoteTextForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextPaymentDelayedListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextPaymentDelayedListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteTextForUserMonetaryAccountPaymentDelayedParams, body CREATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentDelayedCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentDelayedCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentDelayedDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentDelayedDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentDelayedParams, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentDelayedRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentDelayedRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountPaymentDelayed(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentDelayedParams, body UPDATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentDelayedUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountPaymentDelayedRequest(c.Server, userID, monetaryAccountID, paymentDelayedID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentDelayedUpdate](rsp)
}

func (c *Client) READPaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READPaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[PaymentRead], err error) {
	req, err := NewREADPaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentRead](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentPaymentListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentPaymentListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentPaymentUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentPaymentUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *ListAllNoteTextForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextPaymentListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextPaymentListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteTextForUserMonetaryAccountPaymentParams, body CREATENoteTextForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountPayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentParams, body UPDATENoteTextForUserMonetaryAccountPaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextPaymentUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountPaymentRequest(c.Server, userID, monetaryAccountID, paymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextPaymentUpdate](rsp)
}

func (c *Client) ListAllRequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllRequestInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]RequestInquiryListing], err error) {
	req, err := NewListAllRequestInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]RequestInquiryListing](rsp)
}

func (c *Client) CREATERequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATERequestInquiryForUserMonetaryAccountParams, body CREATERequestInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[RequestInquiryCreate], err error) {
	req, err := NewCREATERequestInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestInquiryCreate](rsp)
}

func (c *Client) ListAllRequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllRequestInquiryBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]RequestInquiryBatchListing], err error) {
	req, err := NewListAllRequestInquiryBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]RequestInquiryBatchListing](rsp)
}

func (c *Client) CREATERequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATERequestInquiryBatchForUserMonetaryAccountParams, body CREATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[RequestInquiryBatchCreate], err error) {
	req, err := NewCREATERequestInquiryBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestInquiryBatchCreate](rsp)
}

func (c *Client) READRequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READRequestInquiryBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[RequestInquiryBatchRead], err error) {
	req, err := NewREADRequestInquiryBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestInquiryBatchRead](rsp)
}

func (c *Client) UPDATERequestInquiryBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryBatchForUserMonetaryAccountParams, body UPDATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[RequestInquiryBatchUpdate], err error) {
	req, err := NewUPDATERequestInquiryBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestInquiryBatchUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentRequestInquiryBatchListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentRequestInquiryBatchListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, body CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryBatchCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryBatchCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryBatchDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryBatchDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryBatchRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryBatchRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryBatchUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryBatchUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *ListAllNoteTextForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextRequestInquiryBatchListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextRequestInquiryBatchListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, body CREATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryBatchCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryBatchCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryBatchDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryBatchDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryBatchRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryBatchRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, body UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryBatchUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryBatchUpdate](rsp)
}

func (c *Client) READRequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READRequestInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[RequestInquiryRead], err error) {
	req, err := NewREADRequestInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestInquiryRead](rsp)
}

func (c *Client) UPDATERequestInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryForUserMonetaryAccountParams, body UPDATERequestInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[RequestInquiryUpdate], err error) {
	req, err := NewUPDATERequestInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestInquiryUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentRequestInquiryListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentRequestInquiryListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, body CREATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestInquiryUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestInquiryUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *ListAllNoteTextForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextRequestInquiryListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextRequestInquiryListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryParams, body CREATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryParams, body UPDATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestInquiryUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountRequestInquiryRequest(c.Server, userID, monetaryAccountID, requestInquiryID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestInquiryUpdate](rsp)
}

func (c *Client) ListAllRequestResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllRequestResponseForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]RequestResponseListing], err error) {
	req, err := NewListAllRequestResponseForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]RequestResponseListing](rsp)
}

func (c *Client) READRequestResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READRequestResponseForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[RequestResponseRead], err error) {
	req, err := NewREADRequestResponseForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestResponseRead](rsp)
}

func (c *Client) UPDATERequestResponseForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestResponseForUserMonetaryAccountParams, body UPDATERequestResponseForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[RequestResponseUpdate], err error) {
	req, err := NewUPDATERequestResponseForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[RequestResponseUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentRequestResponseListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentRequestResponseListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestResponseParams, body CREATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestResponseCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestResponseCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestResponseDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestResponseDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestResponseRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestResponseRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestResponseParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentRequestResponseUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentRequestResponseUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *ListAllNoteTextForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextRequestResponseListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextRequestResponseListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteTextForUserMonetaryAccountRequestResponseParams, body CREATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestResponseCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestResponseCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestResponseDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestResponseDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestResponseParams, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestResponseRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestResponseRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountRequestResponse(ctx context.Context, apiKey string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestResponseParams, body UPDATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextRequestResponseUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountRequestResponseRequest(c.Server, userID, monetaryAccountID, requestResponseID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextRequestResponseUpdate](rsp)
}

func (c *Client) ListAllScheduleForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllScheduleForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]ScheduleListing], err error) {
	req, err := NewListAllScheduleForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ScheduleListing](rsp)
}

func (c *Client) ListAllSchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllSchedulePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]SchedulePaymentListing], err error) {
	req, err := NewListAllSchedulePaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]SchedulePaymentListing](rsp)
}

func (c *Client) CREATESchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATESchedulePaymentForUserMonetaryAccountParams, body CREATESchedulePaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentCreate], err error) {
	req, err := NewCREATESchedulePaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentCreate](rsp)
}

func (c *Client) CREATESchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATESchedulePaymentBatchForUserMonetaryAccountParams, body CREATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentBatchCreate], err error) {
	req, err := NewCREATESchedulePaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentBatchCreate](rsp)
}

func (c *Client) DELETESchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETESchedulePaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentBatchDelete], err error) {
	req, err := NewDELETESchedulePaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentBatchDelete](rsp)
}

func (c *Client) READSchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSchedulePaymentBatchForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentBatchRead], err error) {
	req, err := NewREADSchedulePaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentBatchRead](rsp)
}

func (c *Client) UPDATESchedulePaymentBatchForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentBatchForUserMonetaryAccountParams, body UPDATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentBatchUpdate], err error) {
	req, err := NewUPDATESchedulePaymentBatchForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentBatchUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentSchedulePaymentBatchListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentSchedulePaymentBatchListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, body CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentBatchCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentBatchCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentBatchDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentBatchDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentBatchRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentBatchRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentBatchUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentBatchUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextSchedulePaymentBatchListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextSchedulePaymentBatchListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, body CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentBatchCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentBatchCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentBatchDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentBatchDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountSchedulePaymentBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentBatchRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentBatchRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, body UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentBatchUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(c.Server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentBatchUpdate](rsp)
}

func (c *Client) DELETESchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *DELETESchedulePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentDelete], err error) {
	req, err := NewDELETESchedulePaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentDelete](rsp)
}

func (c *Client) READSchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSchedulePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentRead], err error) {
	req, err := NewREADSchedulePaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentRead](rsp)
}

func (c *Client) UPDATESchedulePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentForUserMonetaryAccountParams, body UPDATESchedulePaymentForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[SchedulePaymentUpdate], err error) {
	req, err := NewUPDATESchedulePaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SchedulePaymentUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentSchedulePaymentListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentSchedulePaymentListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, body CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSchedulePaymentUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSchedulePaymentUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *ListAllNoteTextForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextSchedulePaymentListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextSchedulePaymentListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentParams, body CREATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountSchedulePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountSchedulePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentParams, body UPDATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextSchedulePaymentUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentRequest(c.Server, userID, monetaryAccountID, schedulePaymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSchedulePaymentUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentScheduleRequestBatchListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentScheduleRequestBatchListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestBatchCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestBatchCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestBatchDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestBatchDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestBatchRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestBatchRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestBatchUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestBatchUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextScheduleRequestBatchListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextScheduleRequestBatchListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, body CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestBatchCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestBatchCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestBatchDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestBatchDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestBatchRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestBatchRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, body UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestBatchUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestBatchUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentScheduleRequestListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentScheduleRequestListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleRequestUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleRequestUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextScheduleRequestListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextScheduleRequestListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, body CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleRequestInquiryParams, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiry(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, body UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleRequestUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(c.Server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleRequestUpdate](rsp)
}

func (c *Client) READScheduleForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READScheduleForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[ScheduleRead], err error) {
	req, err := NewREADScheduleForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ScheduleRead](rsp)
}

func (c *Client) ListAllScheduleInstanceForUserMonetaryAccountSchedule(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, params *ListAllScheduleInstanceForUserMonetaryAccountScheduleParams, reqEditors ...RequestEditorFn) (res Result[[]ScheduleInstanceListing], err error) {
	req, err := NewListAllScheduleInstanceForUserMonetaryAccountScheduleRequest(c.Server, userID, monetaryAccountID, scheduleID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ScheduleInstanceListing](rsp)
}

func (c *Client) READScheduleInstanceForUserMonetaryAccountSchedule(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, itemId int, params *READScheduleInstanceForUserMonetaryAccountScheduleParams, reqEditors ...RequestEditorFn) (res Result[ScheduleInstanceRead], err error) {
	req, err := NewREADScheduleInstanceForUserMonetaryAccountScheduleRequest(c.Server, userID, monetaryAccountID, scheduleID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ScheduleInstanceRead](rsp)
}

func (c *Client) UPDATEScheduleInstanceForUserMonetaryAccountSchedule(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, itemId int, params *UPDATEScheduleInstanceForUserMonetaryAccountScheduleParams, body UPDATEScheduleInstanceForUserMonetaryAccountScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ScheduleInstanceUpdate], err error) {
	req, err := NewUPDATEScheduleInstanceForUserMonetaryAccountScheduleRequest(c.Server, userID, monetaryAccountID, scheduleID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ScheduleInstanceUpdate](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentScheduleInstanceListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentScheduleInstanceListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleInstanceCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleInstanceCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleInstanceDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleInstanceDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleInstanceRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleInstanceRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentScheduleInstanceUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentScheduleInstanceUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextScheduleInstanceListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextScheduleInstanceListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, body CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleInstanceCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleInstanceCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleInstanceDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleInstanceDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleInstanceRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleInstanceRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstance(ctx context.Context, apiKey string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, body UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextScheduleInstanceUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(c.Server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextScheduleInstanceUpdate](rsp)
}

func (c *Client) ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]ShareInviteMonetaryAccountInquiryListing], err error) {
	req, err := NewListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ShareInviteMonetaryAccountInquiryListing](rsp)
}

func (c *Client) CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, body CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ShareInviteMonetaryAccountInquiryCreate], err error) {
	req, err := NewCREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ShareInviteMonetaryAccountInquiryCreate](rsp)
}

func (c *Client) READShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[ShareInviteMonetaryAccountInquiryRead], err error) {
	req, err := NewREADShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ShareInviteMonetaryAccountInquiryRead](rsp)
}

func (c *Client) UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, body UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ShareInviteMonetaryAccountInquiryUpdate], err error) {
	req, err := NewUPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ShareInviteMonetaryAccountInquiryUpdate](rsp)
}

func (c *Client) ListAllSofortMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllSofortMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]SofortMerchantTransactionListing], err error) {
	req, err := NewListAllSofortMerchantTransactionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]SofortMerchantTransactionListing](rsp)
}

func (c *Client) READSofortMerchantTransactionForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSofortMerchantTransactionForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[SofortMerchantTransactionRead], err error) {
	req, err := NewREADSofortMerchantTransactionForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[SofortMerchantTransactionRead](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentSofortMerchantTransactionListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentSofortMerchantTransactionListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSofortMerchantTransactionCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSofortMerchantTransactionCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSofortMerchantTransactionDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSofortMerchantTransactionDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSofortMerchantTransactionRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSofortMerchantTransactionRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentSofortMerchantTransactionUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentSofortMerchantTransactionUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextSofortMerchantTransactionListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextSofortMerchantTransactionListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextSofortMerchantTransactionCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSofortMerchantTransactionCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextSofortMerchantTransactionDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSofortMerchantTransactionDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountSofortMerchantTransactionParams, reqEditors ...RequestEditorFn) (res Result[NoteTextSofortMerchantTransactionRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSofortMerchantTransactionRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountSofortMerchantTransaction(ctx context.Context, apiKey string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextSofortMerchantTransactionUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(c.Server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextSofortMerchantTransactionUpdate](rsp)
}

func (c *Client) READSwitchServicePaymentForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READSwitchServicePaymentForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[BankSwitchServiceNetherlandsIncomingPaymentRead], err error) {
	req, err := NewREADSwitchServicePaymentForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[BankSwitchServiceNetherlandsIncomingPaymentRead](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, body CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *ListAllNoteTextForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, body CREATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBankSwitchServiceNetherlandsIncomingPaymentCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBankSwitchServiceNetherlandsIncomingPaymentDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountSwitchServicePaymentParams, reqEditors ...RequestEditorFn) (res Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBankSwitchServiceNetherlandsIncomingPaymentRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountSwitchServicePayment(ctx context.Context, apiKey string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, body UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextBankSwitchServiceNetherlandsIncomingPaymentUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountSwitchServicePaymentRequest(c.Server, userID, monetaryAccountID, switchServicePaymentID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextBankSwitchServiceNetherlandsIncomingPaymentUpdate](rsp)
}

func (c *Client) ListAllWhitelistSddForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, params *ListAllWhitelistSddForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[[]WhitelistSddMonetaryAccountPayingListing], err error) {
	req, err := NewListAllWhitelistSddForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]WhitelistSddMonetaryAccountPayingListing](rsp)
}

func (c *Client) READWhitelistSddForUserMonetaryAccount(ctx context.Context, apiKey string, userID int, monetaryAccountID int, itemId int, params *READWhitelistSddForUserMonetaryAccountParams, reqEditors ...RequestEditorFn) (res Result[WhitelistSddMonetaryAccountPayingRead], err error) {
	req, err := NewREADWhitelistSddForUserMonetaryAccountRequest(c.Server, userID, monetaryAccountID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddMonetaryAccountPayingRead](rsp)
}

func (c *Client) ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (res Result[[]NoteAttachmentWhitelistResultListing], err error) {
	req, err := NewListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteAttachmentWhitelistResultListing](rsp)
}

func (c *Client) CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, body CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentWhitelistResultCreate], err error) {
	req, err := NewCREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentWhitelistResultCreate](rsp)
}

func (c *Client) DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentWhitelistResultDelete], err error) {
	req, err := NewDELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentWhitelistResultDelete](rsp)
}

func (c *Client) READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentWhitelistResultRead], err error) {
	req, err := NewREADNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentWhitelistResultRead](rsp)
}

func (c *Client) UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, body UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteAttachmentWhitelistResultUpdate], err error) {
	req, err := NewUPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteAttachmentWhitelistResultUpdate](rsp)
}

func (c *Client) ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (res Result[[]NoteTextWhitelistResultListing], err error) {
	req, err := NewListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NoteTextWhitelistResultListing](rsp)
}

func (c *Client) CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, body CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextWhitelistResultCreate], err error) {
	req, err := NewCREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextWhitelistResultCreate](rsp)
}

func (c *Client) DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (res Result[NoteTextWhitelistResultDelete], err error) {
	req, err := NewDELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextWhitelistResultDelete](rsp)
}

func (c *Client) READNoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *READNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, reqEditors ...RequestEditorFn) (res Result[NoteTextWhitelistResultRead], err error) {
	req, err := NewREADNoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextWhitelistResultRead](rsp)
}

func (c *Client) UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResult(ctx context.Context, apiKey string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, body UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NoteTextWhitelistResultUpdate], err error) {
	req, err := NewUPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(c.Server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NoteTextWhitelistResultUpdate](rsp)
}

func (c *Client) ListAllNotificationFilterEmailForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterEmailForUserParams, reqEditors ...RequestEditorFn) (res Result[[]NotificationFilterEmailListing], err error) {
	req, err := NewListAllNotificationFilterEmailForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NotificationFilterEmailListing](rsp)
}

func (c *Client) CREATENotificationFilterEmailForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterEmailForUserParams, body CREATENotificationFilterEmailForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NotificationFilterEmailCreate], err error) {
	req, err := NewCREATENotificationFilterEmailForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NotificationFilterEmailCreate](rsp)
}

func (c *Client) ListAllNotificationFilterFailureForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterFailureForUserParams, reqEditors ...RequestEditorFn) (res Result[[]NotificationFilterFailureListing], err error) {
	req, err := NewListAllNotificationFilterFailureForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NotificationFilterFailureListing](rsp)
}

func (c *Client) CREATENotificationFilterFailureForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterFailureForUserParams, body CREATENotificationFilterFailureForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NotificationFilterFailureCreate], err error) {
	req, err := NewCREATENotificationFilterFailureForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NotificationFilterFailureCreate](rsp)
}

func (c *Client) ListAllNotificationFilterPushForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterPushForUserParams, reqEditors ...RequestEditorFn) (res Result[[]NotificationFilterPushListing], err error) {
	req, err := NewListAllNotificationFilterPushForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NotificationFilterPushListing](rsp)
}

func (c *Client) CREATENotificationFilterPushForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterPushForUserParams, body CREATENotificationFilterPushForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NotificationFilterPushCreate], err error) {
	req, err := NewCREATENotificationFilterPushForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NotificationFilterPushCreate](rsp)
}

func (c *Client) ListAllNotificationFilterUrlForUser(ctx context.Context, apiKey string, userID int, params *ListAllNotificationFilterUrlForUserParams, reqEditors ...RequestEditorFn) (res Result[[]NotificationFilterUrlListing], err error) {
	req, err := NewListAllNotificationFilterUrlForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]NotificationFilterUrlListing](rsp)
}

func (c *Client) CREATENotificationFilterUrlForUser(ctx context.Context, apiKey string, userID int, params *CREATENotificationFilterUrlForUserParams, body CREATENotificationFilterUrlForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[NotificationFilterUrlCreate], err error) {
	req, err := NewCREATENotificationFilterUrlForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[NotificationFilterUrlCreate](rsp)
}

func (c *Client) ListAllOauthClientForUser(ctx context.Context, apiKey string, userID int, params *ListAllOauthClientForUserParams, reqEditors ...RequestEditorFn) (res Result[[]OauthClientListing], err error) {
	req, err := NewListAllOauthClientForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]OauthClientListing](rsp)
}

func (c *Client) CREATEOauthClientForUser(ctx context.Context, apiKey string, userID int, params *CREATEOauthClientForUserParams, body CREATEOauthClientForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[OauthClientCreate], err error) {
	req, err := NewCREATEOauthClientForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[OauthClientCreate](rsp)
}

func (c *Client) READOauthClientForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READOauthClientForUserParams, reqEditors ...RequestEditorFn) (res Result[OauthClientRead], err error) {
	req, err := NewREADOauthClientForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[OauthClientRead](rsp)
}

func (c *Client) UPDATEOauthClientForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEOauthClientForUserParams, body UPDATEOauthClientForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[OauthClientUpdate], err error) {
	req, err := NewUPDATEOauthClientForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[OauthClientUpdate](rsp)
}

func (c *Client) ListAllCallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, params *ListAllCallbackUrlForUserOauthClientParams, reqEditors ...RequestEditorFn) (res Result[[]OauthCallbackUrlListing], err error) {
	req, err := NewListAllCallbackUrlForUserOauthClientRequest(c.Server, userID, oauthClientID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]OauthCallbackUrlListing](rsp)
}

func (c *Client) CREATECallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, params *CREATECallbackUrlForUserOauthClientParams, body CREATECallbackUrlForUserOauthClientJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[OauthCallbackUrlCreate], err error) {
	req, err := NewCREATECallbackUrlForUserOauthClientRequest(c.Server, userID, oauthClientID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[OauthCallbackUrlCreate](rsp)
}

func (c *Client) DELETECallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, itemId int, params *DELETECallbackUrlForUserOauthClientParams, reqEditors ...RequestEditorFn) (res Result[OauthCallbackUrlDelete], err error) {
	req, err := NewDELETECallbackUrlForUserOauthClientRequest(c.Server, userID, oauthClientID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[OauthCallbackUrlDelete](rsp)
}

func (c *Client) READCallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, itemId int, params *READCallbackUrlForUserOauthClientParams, reqEditors ...RequestEditorFn) (res Result[OauthCallbackUrlRead], err error) {
	req, err := NewREADCallbackUrlForUserOauthClientRequest(c.Server, userID, oauthClientID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[OauthCallbackUrlRead](rsp)
}

func (c *Client) UPDATECallbackUrlForUserOauthClient(ctx context.Context, apiKey string, userID int, oauthClientID int, itemId int, params *UPDATECallbackUrlForUserOauthClientParams, body UPDATECallbackUrlForUserOauthClientJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[OauthCallbackUrlUpdate], err error) {
	req, err := NewUPDATECallbackUrlForUserOauthClientRequest(c.Server, userID, oauthClientID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[OauthCallbackUrlUpdate](rsp)
}

func (c *Client) ListAllPaymentAutoAllocateForUser(ctx context.Context, apiKey string, userID int, params *ListAllPaymentAutoAllocateForUserParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentAutoAllocateUserListing], err error) {
	req, err := NewListAllPaymentAutoAllocateForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentAutoAllocateUserListing](rsp)
}

func (c *Client) ListAllPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, params *ListAllPaymentServiceProviderDraftPaymentForUserParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentServiceProviderDraftPaymentListing], err error) {
	req, err := NewListAllPaymentServiceProviderDraftPaymentForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentServiceProviderDraftPaymentListing](rsp)
}

func (c *Client) CREATEPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, params *CREATEPaymentServiceProviderDraftPaymentForUserParams, body CREATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderDraftPaymentCreate], err error) {
	req, err := NewCREATEPaymentServiceProviderDraftPaymentForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderDraftPaymentCreate](rsp)
}

func (c *Client) READPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READPaymentServiceProviderDraftPaymentForUserParams, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderDraftPaymentRead], err error) {
	req, err := NewREADPaymentServiceProviderDraftPaymentForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderDraftPaymentRead](rsp)
}

func (c *Client) UPDATEPaymentServiceProviderDraftPaymentForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEPaymentServiceProviderDraftPaymentForUserParams, body UPDATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderDraftPaymentUpdate], err error) {
	req, err := NewUPDATEPaymentServiceProviderDraftPaymentForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderDraftPaymentUpdate](rsp)
}

func (c *Client) ListAllPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, params *ListAllPaymentServiceProviderIssuerTransactionForUserParams, reqEditors ...RequestEditorFn) (res Result[[]PaymentServiceProviderIssuerTransactionListing], err error) {
	req, err := NewListAllPaymentServiceProviderIssuerTransactionForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]PaymentServiceProviderIssuerTransactionListing](rsp)
}

func (c *Client) CREATEPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, params *CREATEPaymentServiceProviderIssuerTransactionForUserParams, body CREATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderIssuerTransactionCreate], err error) {
	req, err := NewCREATEPaymentServiceProviderIssuerTransactionForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderIssuerTransactionCreate](rsp)
}

func (c *Client) READPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READPaymentServiceProviderIssuerTransactionForUserParams, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderIssuerTransactionRead], err error) {
	req, err := NewREADPaymentServiceProviderIssuerTransactionForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderIssuerTransactionRead](rsp)
}

func (c *Client) UPDATEPaymentServiceProviderIssuerTransactionForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEPaymentServiceProviderIssuerTransactionForUserParams, body UPDATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[PaymentServiceProviderIssuerTransactionUpdate], err error) {
	req, err := NewUPDATEPaymentServiceProviderIssuerTransactionForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[PaymentServiceProviderIssuerTransactionUpdate](rsp)
}

func (c *Client) ListAllScheduleForUser(ctx context.Context, apiKey string, userID int, params *ListAllScheduleForUserParams, reqEditors ...RequestEditorFn) (res Result[[]ScheduleUserListing], err error) {
	req, err := NewListAllScheduleForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ScheduleUserListing](rsp)
}

func (c *Client) ListAllShareInviteMonetaryAccountResponseForUser(ctx context.Context, apiKey string, userID int, params *ListAllShareInviteMonetaryAccountResponseForUserParams, reqEditors ...RequestEditorFn) (res Result[[]ShareInviteMonetaryAccountResponseListing], err error) {
	req, err := NewListAllShareInviteMonetaryAccountResponseForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]ShareInviteMonetaryAccountResponseListing](rsp)
}

func (c *Client) READShareInviteMonetaryAccountResponseForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READShareInviteMonetaryAccountResponseForUserParams, reqEditors ...RequestEditorFn) (res Result[ShareInviteMonetaryAccountResponseRead], err error) {
	req, err := NewREADShareInviteMonetaryAccountResponseForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ShareInviteMonetaryAccountResponseRead](rsp)
}

func (c *Client) UPDATEShareInviteMonetaryAccountResponseForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEShareInviteMonetaryAccountResponseForUserParams, body UPDATEShareInviteMonetaryAccountResponseForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[ShareInviteMonetaryAccountResponseUpdate], err error) {
	req, err := NewUPDATEShareInviteMonetaryAccountResponseForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[ShareInviteMonetaryAccountResponseUpdate](rsp)
}

func (c *Client) CREATETokenQrRequestIdealForUser(ctx context.Context, apiKey string, userID int, params *CREATETokenQrRequestIdealForUserParams, body CREATETokenQrRequestIdealForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TokenQrRequestIdealCreate], err error) {
	req, err := NewCREATETokenQrRequestIdealForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TokenQrRequestIdealCreate](rsp)
}

func (c *Client) CREATETokenQrRequestSofortForUser(ctx context.Context, apiKey string, userID int, params *CREATETokenQrRequestSofortForUserParams, body CREATETokenQrRequestSofortForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TokenQrRequestSofortCreate], err error) {
	req, err := NewCREATETokenQrRequestSofortForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TokenQrRequestSofortCreate](rsp)
}

func (c *Client) ListAllTransferwiseCurrencyForUser(ctx context.Context, apiKey string, userID int, params *ListAllTransferwiseCurrencyForUserParams, reqEditors ...RequestEditorFn) (res Result[[]TransferwiseCurrencyListing], err error) {
	req, err := NewListAllTransferwiseCurrencyForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]TransferwiseCurrencyListing](rsp)
}

func (c *Client) CREATETransferwiseQuoteForUser(ctx context.Context, apiKey string, userID int, params *CREATETransferwiseQuoteForUserParams, body CREATETransferwiseQuoteForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TransferwiseQuoteCreate], err error) {
	req, err := NewCREATETransferwiseQuoteForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseQuoteCreate](rsp)
}

func (c *Client) CREATETransferwiseQuoteTemporaryForUser(ctx context.Context, apiKey string, userID int, params *CREATETransferwiseQuoteTemporaryForUserParams, body CREATETransferwiseQuoteTemporaryForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TransferwiseQuoteTemporaryCreate], err error) {
	req, err := NewCREATETransferwiseQuoteTemporaryForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseQuoteTemporaryCreate](rsp)
}

func (c *Client) READTransferwiseQuoteTemporaryForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READTransferwiseQuoteTemporaryForUserParams, reqEditors ...RequestEditorFn) (res Result[TransferwiseQuoteTemporaryRead], err error) {
	req, err := NewREADTransferwiseQuoteTemporaryForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseQuoteTemporaryRead](rsp)
}

func (c *Client) READTransferwiseQuoteForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READTransferwiseQuoteForUserParams, reqEditors ...RequestEditorFn) (res Result[TransferwiseQuoteRead], err error) {
	req, err := NewREADTransferwiseQuoteForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseQuoteRead](rsp)
}

func (c *Client) ListAllTransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseRecipientForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (res Result[[]TransferwiseAccountQuoteListing], err error) {
	req, err := NewListAllTransferwiseRecipientForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]TransferwiseAccountQuoteListing](rsp)
}

func (c *Client) CREATETransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientForUserTransferwiseQuoteParams, body CREATETransferwiseRecipientForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TransferwiseAccountQuoteCreate], err error) {
	req, err := NewCREATETransferwiseRecipientForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseAccountQuoteCreate](rsp)
}

func (c *Client) ListAllTransferwiseRecipientRequirementForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (res Result[[]TransferwiseAccountRequirementListing], err error) {
	req, err := NewListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]TransferwiseAccountRequirementListing](rsp)
}

func (c *Client) CREATETransferwiseRecipientRequirementForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteParams, body CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TransferwiseAccountRequirementCreate], err error) {
	req, err := NewCREATETransferwiseRecipientRequirementForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseAccountRequirementCreate](rsp)
}

func (c *Client) DELETETransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, itemId int, params *DELETETransferwiseRecipientForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (res Result[TransferwiseAccountQuoteDelete], err error) {
	req, err := NewDELETETransferwiseRecipientForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseAccountQuoteDelete](rsp)
}

func (c *Client) READTransferwiseRecipientForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, itemId int, params *READTransferwiseRecipientForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (res Result[TransferwiseAccountQuoteRead], err error) {
	req, err := NewREADTransferwiseRecipientForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseAccountQuoteRead](rsp)
}

func (c *Client) ListAllTransferwiseTransferForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseTransferForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (res Result[[]TransferwiseTransferListing], err error) {
	req, err := NewListAllTransferwiseTransferForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]TransferwiseTransferListing](rsp)
}

func (c *Client) CREATETransferwiseTransferForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferForUserTransferwiseQuoteParams, body CREATETransferwiseTransferForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TransferwiseTransferCreate], err error) {
	req, err := NewCREATETransferwiseTransferForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseTransferCreate](rsp)
}

func (c *Client) CREATETransferwiseTransferRequirementForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferRequirementForUserTransferwiseQuoteParams, body CREATETransferwiseTransferRequirementForUserTransferwiseQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TransferwiseTransferRequirementCreate], err error) {
	req, err := NewCREATETransferwiseTransferRequirementForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseTransferRequirementCreate](rsp)
}

func (c *Client) READTransferwiseTransferForUserTransferwiseQuote(ctx context.Context, apiKey string, userID int, transferwiseQuoteID int, itemId int, params *READTransferwiseTransferForUserTransferwiseQuoteParams, reqEditors ...RequestEditorFn) (res Result[TransferwiseTransferRead], err error) {
	req, err := NewREADTransferwiseTransferForUserTransferwiseQuoteRequest(c.Server, userID, transferwiseQuoteID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseTransferRead](rsp)
}

func (c *Client) ListAllTransferwiseUserForUser(ctx context.Context, apiKey string, userID int, params *ListAllTransferwiseUserForUserParams, reqEditors ...RequestEditorFn) (res Result[[]TransferwiseUserListing], err error) {
	req, err := NewListAllTransferwiseUserForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]TransferwiseUserListing](rsp)
}

func (c *Client) CREATETransferwiseUserForUser(ctx context.Context, apiKey string, userID int, params *CREATETransferwiseUserForUserParams, body CREATETransferwiseUserForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[TransferwiseUserCreate], err error) {
	req, err := NewCREATETransferwiseUserForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[TransferwiseUserCreate](rsp)
}

func (c *Client) ListAllTreeProgressForUser(ctx context.Context, apiKey string, userID int, params *ListAllTreeProgressForUserParams, reqEditors ...RequestEditorFn) (res Result[[]TreeProgressListing], err error) {
	req, err := NewListAllTreeProgressForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]TreeProgressListing](rsp)
}

func (c *Client) ListAllWhitelistSddForUser(ctx context.Context, apiKey string, userID int, params *ListAllWhitelistSddForUserParams, reqEditors ...RequestEditorFn) (res Result[[]WhitelistSddListing], err error) {
	req, err := NewListAllWhitelistSddForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]WhitelistSddListing](rsp)
}

func (c *Client) ListAllWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, params *ListAllWhitelistSddOneOffForUserParams, reqEditors ...RequestEditorFn) (res Result[[]WhitelistSddOneOffListing], err error) {
	req, err := NewListAllWhitelistSddOneOffForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]WhitelistSddOneOffListing](rsp)
}

func (c *Client) CREATEWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, params *CREATEWhitelistSddOneOffForUserParams, body CREATEWhitelistSddOneOffForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[WhitelistSddOneOffCreate], err error) {
	req, err := NewCREATEWhitelistSddOneOffForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddOneOffCreate](rsp)
}

func (c *Client) DELETEWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETEWhitelistSddOneOffForUserParams, reqEditors ...RequestEditorFn) (res Result[WhitelistSddOneOffDelete], err error) {
	req, err := NewDELETEWhitelistSddOneOffForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddOneOffDelete](rsp)
}

func (c *Client) READWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READWhitelistSddOneOffForUserParams, reqEditors ...RequestEditorFn) (res Result[WhitelistSddOneOffRead], err error) {
	req, err := NewREADWhitelistSddOneOffForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddOneOffRead](rsp)
}

func (c *Client) UPDATEWhitelistSddOneOffForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEWhitelistSddOneOffForUserParams, body UPDATEWhitelistSddOneOffForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[WhitelistSddOneOffUpdate], err error) {
	req, err := NewUPDATEWhitelistSddOneOffForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddOneOffUpdate](rsp)
}

func (c *Client) ListAllWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, params *ListAllWhitelistSddRecurringForUserParams, reqEditors ...RequestEditorFn) (res Result[[]WhitelistSddRecurringListing], err error) {
	req, err := NewListAllWhitelistSddRecurringForUserRequest(c.Server, userID, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSlice[[]WhitelistSddRecurringListing](rsp)
}

func (c *Client) CREATEWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, params *CREATEWhitelistSddRecurringForUserParams, body CREATEWhitelistSddRecurringForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[WhitelistSddRecurringCreate], err error) {
	req, err := NewCREATEWhitelistSddRecurringForUserRequest(c.Server, userID, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddRecurringCreate](rsp)
}

func (c *Client) DELETEWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, itemId int, params *DELETEWhitelistSddRecurringForUserParams, reqEditors ...RequestEditorFn) (res Result[WhitelistSddRecurringDelete], err error) {
	req, err := NewDELETEWhitelistSddRecurringForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddRecurringDelete](rsp)
}

func (c *Client) READWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READWhitelistSddRecurringForUserParams, reqEditors ...RequestEditorFn) (res Result[WhitelistSddRecurringRead], err error) {
	req, err := NewREADWhitelistSddRecurringForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddRecurringRead](rsp)
}

func (c *Client) UPDATEWhitelistSddRecurringForUser(ctx context.Context, apiKey string, userID int, itemId int, params *UPDATEWhitelistSddRecurringForUserParams, body UPDATEWhitelistSddRecurringForUserJSONRequestBody, reqEditors ...RequestEditorFn) (res Result[WhitelistSddRecurringUpdate], err error) {
	req, err := NewUPDATEWhitelistSddRecurringForUserRequest(c.Server, userID, itemId, params, body)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddRecurringUpdate](rsp)
}

func (c *Client) READWhitelistSddForUser(ctx context.Context, apiKey string, userID int, itemId int, params *READWhitelistSddForUserParams, reqEditors ...RequestEditorFn) (res Result[WhitelistSddRead], err error) {
	req, err := NewREADWhitelistSddForUserRequest(c.Server, userID, itemId, params)
	if err != nil {
		return
	}
	req = req.WithContext(ctx)
	if len(apiKey) > 0 {
		req.Header.Set("X-Bunq-Client-Authentication", apiKey)
	}
	err = c.applyEditors(ctx, req, reqEditors)
	if err != nil {
		return
	}
	rsp, err := c.Client.Do(req)
	if err != nil {
		return
	}
	err = c.applyResponseValidators(ctx, rsp)
	if err != nil {
		return
	}
	return ParseSingle[WhitelistSddRead](rsp)
}

// NewCREATEAttachmentPublicRequest calls the generic CREATEAttachmentPublic builder with application/json body
func NewCREATEAttachmentPublicRequest(server string, params *CREATEAttachmentPublicParams, body CREATEAttachmentPublicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEAttachmentPublicRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATEAttachmentPublicRequestWithBody generates requests for CREATEAttachmentPublic with any type of body
func NewCREATEAttachmentPublicRequestWithBody(server string, params *CREATEAttachmentPublicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachment-public")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllContentForAttachmentPublicRequest generates requests for ListAllContentForAttachmentPublic
func NewListAllContentForAttachmentPublicRequest(server string, attachmentPublicUUID string, params *ListAllContentForAttachmentPublicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = url.PathEscape(attachmentPublicUUID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachment-public/%s/content", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADAttachmentPublicRequest generates requests for READAttachmentPublic
func NewREADAttachmentPublicRequest(server string, itemId int, params *READAttachmentPublicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachment-public/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEAvatarRequest calls the generic CREATEAvatar builder with application/json body
func NewCREATEAvatarRequest(server string, params *CREATEAvatarParams, body CREATEAvatarJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEAvatarRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATEAvatarRequestWithBody generates requests for CREATEAvatar with any type of body
func NewCREATEAvatarRequestWithBody(server string, params *CREATEAvatarParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/avatar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADAvatarRequest generates requests for READAvatar
func NewREADAvatarRequest(server string, itemId int, params *READAvatarParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/avatar/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllDeviceRequest generates requests for ListAllDevice
func NewListAllDeviceRequest(server string, params *ListAllDeviceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllDeviceServerRequest generates requests for ListAllDeviceServer
func NewListAllDeviceServerRequest(server string, params *ListAllDeviceServerParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-server")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEDeviceServerRequest calls the generic CREATEDeviceServer builder with application/json body
func NewCREATEDeviceServerRequest(server string, params *CREATEDeviceServerParams, body CREATEDeviceServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEDeviceServerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATEDeviceServerRequestWithBody generates requests for CREATEDeviceServer with any type of body
func NewCREATEDeviceServerRequestWithBody(server string, params *CREATEDeviceServerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-server")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADDeviceServerRequest generates requests for READDeviceServer
func NewREADDeviceServerRequest(server string, itemId int, params *READDeviceServerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device-server/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADDeviceRequest generates requests for READDevice
func NewREADDeviceRequest(server string, itemId int, params *READDeviceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/device/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllInstallationRequest generates requests for ListAllInstallation
func NewListAllInstallationRequest(server string, params *ListAllInstallationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/installation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEInstallationRequest calls the generic CREATEInstallation builder with application/json body
func NewCREATEInstallationRequest(server string, params *CREATEInstallationParams, body CREATEInstallationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEInstallationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATEInstallationRequestWithBody generates requests for CREATEInstallation with any type of body
func NewCREATEInstallationRequestWithBody(server string, params *CREATEInstallationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/installation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllServerPublicKeyForInstallationRequest generates requests for ListAllServerPublicKeyForInstallation
func NewListAllServerPublicKeyForInstallationRequest(server string, installationID int, params *ListAllServerPublicKeyForInstallationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(installationID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/installation/%s/server-public-key", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADInstallationRequest generates requests for READInstallation
func NewREADInstallationRequest(server string, itemId int, params *READInstallationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/installation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEPaymentServiceProviderCredentialRequest calls the generic CREATEPaymentServiceProviderCredential builder with application/json body
func NewCREATEPaymentServiceProviderCredentialRequest(server string, params *CREATEPaymentServiceProviderCredentialParams, body CREATEPaymentServiceProviderCredentialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEPaymentServiceProviderCredentialRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATEPaymentServiceProviderCredentialRequestWithBody generates requests for CREATEPaymentServiceProviderCredential with any type of body
func NewCREATEPaymentServiceProviderCredentialRequestWithBody(server string, params *CREATEPaymentServiceProviderCredentialParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-service-provider-credential")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADPaymentServiceProviderCredentialRequest generates requests for READPaymentServiceProviderCredential
func NewREADPaymentServiceProviderCredentialRequest(server string, itemId int, params *READPaymentServiceProviderCredentialParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/payment-service-provider-credential/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATESandboxUserCompanyRequest calls the generic CREATESandboxUserCompany builder with application/json body
func NewCREATESandboxUserCompanyRequest(server string, params *CREATESandboxUserCompanyParams, body CREATESandboxUserCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATESandboxUserCompanyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATESandboxUserCompanyRequestWithBody generates requests for CREATESandboxUserCompany with any type of body
func NewCREATESandboxUserCompanyRequestWithBody(server string, params *CREATESandboxUserCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox-user-company")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATESandboxUserPersonRequest calls the generic CREATESandboxUserPerson builder with application/json body
func NewCREATESandboxUserPersonRequest(server string, params *CREATESandboxUserPersonParams, body CREATESandboxUserPersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATESandboxUserPersonRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATESandboxUserPersonRequestWithBody generates requests for CREATESandboxUserPerson with any type of body
func NewCREATESandboxUserPersonRequestWithBody(server string, params *CREATESandboxUserPersonParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sandbox-user-person")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATEServerErrorRequest calls the generic CREATEServerError builder with application/json body
func NewCREATEServerErrorRequest(server string, params *CREATEServerErrorParams, body CREATEServerErrorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEServerErrorRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATEServerErrorRequestWithBody generates requests for CREATEServerError with any type of body
func NewCREATEServerErrorRequestWithBody(server string, params *CREATEServerErrorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/server-error")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATESessionServerRequest calls the generic CREATESessionServer builder with application/json body
func NewCREATESessionServerRequest(server string, params *CREATESessionServerParams, body CREATESessionServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATESessionServerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCREATESessionServerRequestWithBody generates requests for CREATESessionServer with any type of body
func NewCREATESessionServerRequestWithBody(server string, params *CREATESessionServerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session-server")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETESessionRequest generates requests for DELETESession
func NewDELETESessionRequest(server string, itemId int, params *DELETESessionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllUserRequest generates requests for ListAllUser
func NewListAllUserRequest(server string, params *ListAllUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADUserCompanyRequest generates requests for READUserCompany
func NewREADUserCompanyRequest(server string, itemId int, params *READUserCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-company/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEUserCompanyRequest calls the generic UPDATEUserCompany builder with application/json body
func NewUPDATEUserCompanyRequest(server string, itemId int, params *UPDATEUserCompanyParams, body UPDATEUserCompanyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEUserCompanyRequestWithBody(server, itemId, params, "application/json", bodyReader)
}

// NewUPDATEUserCompanyRequestWithBody generates requests for UPDATEUserCompany with any type of body
func NewUPDATEUserCompanyRequestWithBody(server string, itemId int, params *UPDATEUserCompanyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-company/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNameForUserCompanyRequest generates requests for ListAllNameForUserCompany
func NewListAllNameForUserCompanyRequest(server string, userCompanyID int, params *ListAllNameForUserCompanyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userCompanyID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-company/%s/name", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADUserPaymentServiceProviderRequest generates requests for READUserPaymentServiceProvider
func NewREADUserPaymentServiceProviderRequest(server string, itemId int, params *READUserPaymentServiceProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-payment-service-provider/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADUserPersonRequest generates requests for READUserPerson
func NewREADUserPersonRequest(server string, itemId int, params *READUserPersonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-person/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEUserPersonRequest calls the generic UPDATEUserPerson builder with application/json body
func NewUPDATEUserPersonRequest(server string, itemId int, params *UPDATEUserPersonParams, body UPDATEUserPersonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEUserPersonRequestWithBody(server, itemId, params, "application/json", bodyReader)
}

// NewUPDATEUserPersonRequestWithBody generates requests for UPDATEUserPerson with any type of body
func NewUPDATEUserPersonRequestWithBody(server string, itemId int, params *UPDATEUserPersonParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user-person/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADUserRequest generates requests for READUser
func NewREADUserRequest(server string, itemId int, params *READUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllAdditionalTransactionInformationCategoryForUserRequest generates requests for ListAllAdditionalTransactionInformationCategoryForUser
func NewListAllAdditionalTransactionInformationCategoryForUserRequest(server string, userID int, params *ListAllAdditionalTransactionInformationCategoryForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/additional-transaction-information-category", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEAdditionalTransactionInformationCategoryUserDefinedForUserRequest calls the generic CREATEAdditionalTransactionInformationCategoryUserDefinedForUser builder with application/json body
func NewCREATEAdditionalTransactionInformationCategoryUserDefinedForUserRequest(server string, userID int, params *CREATEAdditionalTransactionInformationCategoryUserDefinedForUserParams, body CREATEAdditionalTransactionInformationCategoryUserDefinedForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEAdditionalTransactionInformationCategoryUserDefinedForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEAdditionalTransactionInformationCategoryUserDefinedForUserRequestWithBody generates requests for CREATEAdditionalTransactionInformationCategoryUserDefinedForUser with any type of body
func NewCREATEAdditionalTransactionInformationCategoryUserDefinedForUserRequestWithBody(server string, userID int, params *CREATEAdditionalTransactionInformationCategoryUserDefinedForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/additional-transaction-information-category-user-defined", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllContentForUserAttachmentRequest generates requests for ListAllContentForUserAttachment
func NewListAllContentForUserAttachmentRequest(server string, userID int, attachmentID int, params *ListAllContentForUserAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(attachmentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/attachment/%s/content", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADAttachmentForUserRequest generates requests for READAttachmentForUser
func NewREADAttachmentForUserRequest(server string, userID int, itemId int, params *READAttachmentForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/attachment/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllBillingContractSubscriptionForUserRequest generates requests for ListAllBillingContractSubscriptionForUser
func NewListAllBillingContractSubscriptionForUserRequest(server string, userID int, params *ListAllBillingContractSubscriptionForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/billing-contract-subscription", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllBunqmeFundraiserProfileForUserRequest generates requests for ListAllBunqmeFundraiserProfileForUser
func NewListAllBunqmeFundraiserProfileForUserRequest(server string, userID int, params *ListAllBunqmeFundraiserProfileForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/bunqme-fundraiser-profile", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADBunqmeFundraiserProfileForUserRequest generates requests for READBunqmeFundraiserProfileForUser
func NewREADBunqmeFundraiserProfileForUserRequest(server string, userID int, itemId int, params *READBunqmeFundraiserProfileForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/bunqme-fundraiser-profile/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllCardForUserRequest generates requests for ListAllCardForUser
func NewListAllCardForUserRequest(server string, userID int, params *ListAllCardForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATECardBatchForUserRequest calls the generic CREATECardBatchForUser builder with application/json body
func NewCREATECardBatchForUserRequest(server string, userID int, params *CREATECardBatchForUserParams, body CREATECardBatchForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECardBatchForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATECardBatchForUserRequestWithBody generates requests for CREATECardBatchForUser with any type of body
func NewCREATECardBatchForUserRequestWithBody(server string, userID int, params *CREATECardBatchForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card-batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATECardBatchReplaceForUserRequest calls the generic CREATECardBatchReplaceForUser builder with application/json body
func NewCREATECardBatchReplaceForUserRequest(server string, userID int, params *CREATECardBatchReplaceForUserParams, body CREATECardBatchReplaceForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECardBatchReplaceForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATECardBatchReplaceForUserRequestWithBody generates requests for CREATECardBatchReplaceForUser with any type of body
func NewCREATECardBatchReplaceForUserRequestWithBody(server string, userID int, params *CREATECardBatchReplaceForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card-batch-replace", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATECardCreditForUserRequest calls the generic CREATECardCreditForUser builder with application/json body
func NewCREATECardCreditForUserRequest(server string, userID int, params *CREATECardCreditForUserParams, body CREATECardCreditForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECardCreditForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATECardCreditForUserRequestWithBody generates requests for CREATECardCreditForUser with any type of body
func NewCREATECardCreditForUserRequestWithBody(server string, userID int, params *CREATECardCreditForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card-credit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATECardDebitForUserRequest calls the generic CREATECardDebitForUser builder with application/json body
func NewCREATECardDebitForUserRequest(server string, userID int, params *CREATECardDebitForUserParams, body CREATECardDebitForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECardDebitForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATECardDebitForUserRequestWithBody generates requests for CREATECardDebitForUser with any type of body
func NewCREATECardDebitForUserRequestWithBody(server string, userID int, params *CREATECardDebitForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card-debit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCardNameForUserRequest generates requests for ListAllCardNameForUser
func NewListAllCardNameForUserRequest(server string, userID int, params *ListAllCardNameForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card-name", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllExportStatementCardForUserCardRequest generates requests for ListAllExportStatementCardForUserCard
func NewListAllExportStatementCardForUserCardRequest(server string, userID int, cardID int, params *ListAllExportStatementCardForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllExportStatementCardCsvForUserCardRequest generates requests for ListAllExportStatementCardCsvForUserCard
func NewListAllExportStatementCardCsvForUserCardRequest(server string, userID int, cardID int, params *ListAllExportStatementCardCsvForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-csv", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEExportStatementCardCsvForUserCardRequest calls the generic CREATEExportStatementCardCsvForUserCard builder with application/json body
func NewCREATEExportStatementCardCsvForUserCardRequest(server string, userID int, cardID int, params *CREATEExportStatementCardCsvForUserCardParams, body CREATEExportStatementCardCsvForUserCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEExportStatementCardCsvForUserCardRequestWithBody(server, userID, cardID, params, "application/json", bodyReader)
}

// NewCREATEExportStatementCardCsvForUserCardRequestWithBody generates requests for CREATEExportStatementCardCsvForUserCard with any type of body
func NewCREATEExportStatementCardCsvForUserCardRequestWithBody(server string, userID int, cardID int, params *CREATEExportStatementCardCsvForUserCardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-csv", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETEExportStatementCardCsvForUserCardRequest generates requests for DELETEExportStatementCardCsvForUserCard
func NewDELETEExportStatementCardCsvForUserCardRequest(server string, userID int, cardID int, itemId int, params *DELETEExportStatementCardCsvForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-csv/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADExportStatementCardCsvForUserCardRequest generates requests for READExportStatementCardCsvForUserCard
func NewREADExportStatementCardCsvForUserCardRequest(server string, userID int, cardID int, itemId int, params *READExportStatementCardCsvForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-csv/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllExportStatementCardPdfForUserCardRequest generates requests for ListAllExportStatementCardPdfForUserCard
func NewListAllExportStatementCardPdfForUserCardRequest(server string, userID int, cardID int, params *ListAllExportStatementCardPdfForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-pdf", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEExportStatementCardPdfForUserCardRequest calls the generic CREATEExportStatementCardPdfForUserCard builder with application/json body
func NewCREATEExportStatementCardPdfForUserCardRequest(server string, userID int, cardID int, params *CREATEExportStatementCardPdfForUserCardParams, body CREATEExportStatementCardPdfForUserCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEExportStatementCardPdfForUserCardRequestWithBody(server, userID, cardID, params, "application/json", bodyReader)
}

// NewCREATEExportStatementCardPdfForUserCardRequestWithBody generates requests for CREATEExportStatementCardPdfForUserCard with any type of body
func NewCREATEExportStatementCardPdfForUserCardRequestWithBody(server string, userID int, cardID int, params *CREATEExportStatementCardPdfForUserCardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-pdf", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETEExportStatementCardPdfForUserCardRequest generates requests for DELETEExportStatementCardPdfForUserCard
func NewDELETEExportStatementCardPdfForUserCardRequest(server string, userID int, cardID int, itemId int, params *DELETEExportStatementCardPdfForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-pdf/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADExportStatementCardPdfForUserCardRequest generates requests for READExportStatementCardPdfForUserCard
func NewREADExportStatementCardPdfForUserCardRequest(server string, userID int, cardID int, itemId int, params *READExportStatementCardPdfForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card-pdf/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllContentForUserCardExportStatementCardRequest generates requests for ListAllContentForUserCardExportStatementCard
func NewListAllContentForUserCardExportStatementCardRequest(server string, userID int, cardID int, exportStatementCardID int, params *ListAllContentForUserCardExportStatementCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(exportStatementCardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card/%s/content", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADExportStatementCardForUserCardRequest generates requests for READExportStatementCardForUserCard
func NewREADExportStatementCardForUserCardRequest(server string, userID int, cardID int, itemId int, params *READExportStatementCardForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/export-statement-card/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllGeneratedCvc2ForUserCardRequest generates requests for ListAllGeneratedCvc2ForUserCard
func NewListAllGeneratedCvc2ForUserCardRequest(server string, userID int, cardID int, params *ListAllGeneratedCvc2ForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/generated-cvc2", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEGeneratedCvc2ForUserCardRequest calls the generic CREATEGeneratedCvc2ForUserCard builder with application/json body
func NewCREATEGeneratedCvc2ForUserCardRequest(server string, userID int, cardID int, params *CREATEGeneratedCvc2ForUserCardParams, body CREATEGeneratedCvc2ForUserCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEGeneratedCvc2ForUserCardRequestWithBody(server, userID, cardID, params, "application/json", bodyReader)
}

// NewCREATEGeneratedCvc2ForUserCardRequestWithBody generates requests for CREATEGeneratedCvc2ForUserCard with any type of body
func NewCREATEGeneratedCvc2ForUserCardRequestWithBody(server string, userID int, cardID int, params *CREATEGeneratedCvc2ForUserCardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/generated-cvc2", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADGeneratedCvc2ForUserCardRequest generates requests for READGeneratedCvc2ForUserCard
func NewREADGeneratedCvc2ForUserCardRequest(server string, userID int, cardID int, itemId int, params *READGeneratedCvc2ForUserCardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/generated-cvc2/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEGeneratedCvc2ForUserCardRequest calls the generic UPDATEGeneratedCvc2ForUserCard builder with application/json body
func NewUPDATEGeneratedCvc2ForUserCardRequest(server string, userID int, cardID int, itemId int, params *UPDATEGeneratedCvc2ForUserCardParams, body UPDATEGeneratedCvc2ForUserCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEGeneratedCvc2ForUserCardRequestWithBody(server, userID, cardID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEGeneratedCvc2ForUserCardRequestWithBody generates requests for UPDATEGeneratedCvc2ForUserCard with any type of body
func NewUPDATEGeneratedCvc2ForUserCardRequestWithBody(server string, userID int, cardID int, itemId int, params *UPDATEGeneratedCvc2ForUserCardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/generated-cvc2/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATEReplaceForUserCardRequest calls the generic CREATEReplaceForUserCard builder with application/json body
func NewCREATEReplaceForUserCardRequest(server string, userID int, cardID int, params *CREATEReplaceForUserCardParams, body CREATEReplaceForUserCardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEReplaceForUserCardRequestWithBody(server, userID, cardID, params, "application/json", bodyReader)
}

// NewCREATEReplaceForUserCardRequestWithBody generates requests for CREATEReplaceForUserCard with any type of body
func NewCREATEReplaceForUserCardRequestWithBody(server string, userID int, cardID int, params *CREATEReplaceForUserCardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(cardID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s/replace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADCardForUserRequest generates requests for READCardForUser
func NewREADCardForUserRequest(server string, userID int, itemId int, params *READCardForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATECardForUserRequest calls the generic UPDATECardForUser builder with application/json body
func NewUPDATECardForUserRequest(server string, userID int, itemId int, params *UPDATECardForUserParams, body UPDATECardForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATECardForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATECardForUserRequestWithBody generates requests for UPDATECardForUser with any type of body
func NewUPDATECardForUserRequestWithBody(server string, userID int, itemId int, params *UPDATECardForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/card/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCertificatePinnedForUserRequest generates requests for ListAllCertificatePinnedForUser
func NewListAllCertificatePinnedForUserRequest(server string, userID int, params *ListAllCertificatePinnedForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/certificate-pinned", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATECertificatePinnedForUserRequest calls the generic CREATECertificatePinnedForUser builder with application/json body
func NewCREATECertificatePinnedForUserRequest(server string, userID int, params *CREATECertificatePinnedForUserParams, body CREATECertificatePinnedForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECertificatePinnedForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATECertificatePinnedForUserRequestWithBody generates requests for CREATECertificatePinnedForUser with any type of body
func NewCREATECertificatePinnedForUserRequestWithBody(server string, userID int, params *CREATECertificatePinnedForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/certificate-pinned", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETECertificatePinnedForUserRequest generates requests for DELETECertificatePinnedForUser
func NewDELETECertificatePinnedForUserRequest(server string, userID int, itemId int, params *DELETECertificatePinnedForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/certificate-pinned/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADCertificatePinnedForUserRequest generates requests for READCertificatePinnedForUser
func NewREADCertificatePinnedForUserRequest(server string, userID int, itemId int, params *READCertificatePinnedForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/certificate-pinned/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADChallengeRequestForUserRequest generates requests for READChallengeRequestForUser
func NewREADChallengeRequestForUserRequest(server string, userID int, itemId int, params *READChallengeRequestForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/challenge-request/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEChallengeRequestForUserRequest calls the generic UPDATEChallengeRequestForUser builder with application/json body
func NewUPDATEChallengeRequestForUserRequest(server string, userID int, itemId int, params *UPDATEChallengeRequestForUserParams, body UPDATEChallengeRequestForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEChallengeRequestForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEChallengeRequestForUserRequestWithBody generates requests for UPDATEChallengeRequestForUser with any type of body
func NewUPDATEChallengeRequestForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEChallengeRequestForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/challenge-request/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllContentForUserChatConversationAttachmentRequest generates requests for ListAllContentForUserChatConversationAttachment
func NewListAllContentForUserChatConversationAttachmentRequest(server string, userID int, chatConversationID int, attachmentID int, params *ListAllContentForUserChatConversationAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(chatConversationID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(attachmentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/chat-conversation/%s/attachment/%s/content", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllCompanyForUserRequest generates requests for ListAllCompanyForUser
func NewListAllCompanyForUserRequest(server string, userID int, params *ListAllCompanyForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/company", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATECompanyForUserRequest calls the generic CREATECompanyForUser builder with application/json body
func NewCREATECompanyForUserRequest(server string, userID int, params *CREATECompanyForUserParams, body CREATECompanyForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECompanyForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATECompanyForUserRequestWithBody generates requests for CREATECompanyForUser with any type of body
func NewCREATECompanyForUserRequestWithBody(server string, userID int, params *CREATECompanyForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/company", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADCompanyForUserRequest generates requests for READCompanyForUser
func NewREADCompanyForUserRequest(server string, userID int, itemId int, params *READCompanyForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/company/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATECompanyForUserRequest calls the generic UPDATECompanyForUser builder with application/json body
func NewUPDATECompanyForUserRequest(server string, userID int, itemId int, params *UPDATECompanyForUserParams, body UPDATECompanyForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATECompanyForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATECompanyForUserRequestWithBody generates requests for UPDATECompanyForUser with any type of body
func NewUPDATECompanyForUserRequestWithBody(server string, userID int, itemId int, params *UPDATECompanyForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/company/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATEConfirmationOfFundsForUserRequest calls the generic CREATEConfirmationOfFundsForUser builder with application/json body
func NewCREATEConfirmationOfFundsForUserRequest(server string, userID int, params *CREATEConfirmationOfFundsForUserParams, body CREATEConfirmationOfFundsForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEConfirmationOfFundsForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEConfirmationOfFundsForUserRequestWithBody generates requests for CREATEConfirmationOfFundsForUser with any type of body
func NewCREATEConfirmationOfFundsForUserRequestWithBody(server string, userID int, params *CREATEConfirmationOfFundsForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/confirmation-of-funds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCredentialPasswordIpForUserRequest generates requests for ListAllCredentialPasswordIpForUser
func NewListAllCredentialPasswordIpForUserRequest(server string, userID int, params *ListAllCredentialPasswordIpForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/credential-password-ip", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllIpForUserCredentialPasswordIpRequest generates requests for ListAllIpForUserCredentialPasswordIp
func NewListAllIpForUserCredentialPasswordIpRequest(server string, userID int, credentialPasswordIpID int, params *ListAllIpForUserCredentialPasswordIpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(credentialPasswordIpID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/credential-password-ip/%s/ip", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEIpForUserCredentialPasswordIpRequest calls the generic CREATEIpForUserCredentialPasswordIp builder with application/json body
func NewCREATEIpForUserCredentialPasswordIpRequest(server string, userID int, credentialPasswordIpID int, params *CREATEIpForUserCredentialPasswordIpParams, body CREATEIpForUserCredentialPasswordIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEIpForUserCredentialPasswordIpRequestWithBody(server, userID, credentialPasswordIpID, params, "application/json", bodyReader)
}

// NewCREATEIpForUserCredentialPasswordIpRequestWithBody generates requests for CREATEIpForUserCredentialPasswordIp with any type of body
func NewCREATEIpForUserCredentialPasswordIpRequestWithBody(server string, userID int, credentialPasswordIpID int, params *CREATEIpForUserCredentialPasswordIpParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(credentialPasswordIpID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/credential-password-ip/%s/ip", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADIpForUserCredentialPasswordIpRequest generates requests for READIpForUserCredentialPasswordIp
func NewREADIpForUserCredentialPasswordIpRequest(server string, userID int, credentialPasswordIpID int, itemId int, params *READIpForUserCredentialPasswordIpParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(credentialPasswordIpID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/credential-password-ip/%s/ip/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEIpForUserCredentialPasswordIpRequest calls the generic UPDATEIpForUserCredentialPasswordIp builder with application/json body
func NewUPDATEIpForUserCredentialPasswordIpRequest(server string, userID int, credentialPasswordIpID int, itemId int, params *UPDATEIpForUserCredentialPasswordIpParams, body UPDATEIpForUserCredentialPasswordIpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEIpForUserCredentialPasswordIpRequestWithBody(server, userID, credentialPasswordIpID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEIpForUserCredentialPasswordIpRequestWithBody generates requests for UPDATEIpForUserCredentialPasswordIp with any type of body
func NewUPDATEIpForUserCredentialPasswordIpRequestWithBody(server string, userID int, credentialPasswordIpID int, itemId int, params *UPDATEIpForUserCredentialPasswordIpParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(credentialPasswordIpID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/credential-password-ip/%s/ip/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADCredentialPasswordIpForUserRequest generates requests for READCredentialPasswordIpForUser
func NewREADCredentialPasswordIpForUserRequest(server string, userID int, itemId int, params *READCredentialPasswordIpForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/credential-password-ip/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllCurrencyCloudBeneficiaryForUserRequest generates requests for ListAllCurrencyCloudBeneficiaryForUser
func NewListAllCurrencyCloudBeneficiaryForUserRequest(server string, userID int, params *ListAllCurrencyCloudBeneficiaryForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/currency-cloud-beneficiary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATECurrencyCloudBeneficiaryForUserRequest calls the generic CREATECurrencyCloudBeneficiaryForUser builder with application/json body
func NewCREATECurrencyCloudBeneficiaryForUserRequest(server string, userID int, params *CREATECurrencyCloudBeneficiaryForUserParams, body CREATECurrencyCloudBeneficiaryForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECurrencyCloudBeneficiaryForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATECurrencyCloudBeneficiaryForUserRequestWithBody generates requests for CREATECurrencyCloudBeneficiaryForUser with any type of body
func NewCREATECurrencyCloudBeneficiaryForUserRequestWithBody(server string, userID int, params *CREATECurrencyCloudBeneficiaryForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/currency-cloud-beneficiary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCurrencyCloudBeneficiaryRequirementForUserRequest generates requests for ListAllCurrencyCloudBeneficiaryRequirementForUser
func NewListAllCurrencyCloudBeneficiaryRequirementForUserRequest(server string, userID int, params *ListAllCurrencyCloudBeneficiaryRequirementForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/currency-cloud-beneficiary-requirement", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADCurrencyCloudBeneficiaryForUserRequest generates requests for READCurrencyCloudBeneficiaryForUser
func NewREADCurrencyCloudBeneficiaryForUserRequest(server string, userID int, itemId int, params *READCurrencyCloudBeneficiaryForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/currency-cloud-beneficiary/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllEventForUserRequest generates requests for ListAllEventForUser
func NewListAllEventForUserRequest(server string, userID int, params *ListAllEventForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/event", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADEventForUserRequest generates requests for READEventForUser
func NewREADEventForUserRequest(server string, userID int, itemId int, params *READEventForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/event/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllExportAnnualOverviewForUserRequest generates requests for ListAllExportAnnualOverviewForUser
func NewListAllExportAnnualOverviewForUserRequest(server string, userID int, params *ListAllExportAnnualOverviewForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/export-annual-overview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEExportAnnualOverviewForUserRequest calls the generic CREATEExportAnnualOverviewForUser builder with application/json body
func NewCREATEExportAnnualOverviewForUserRequest(server string, userID int, params *CREATEExportAnnualOverviewForUserParams, body CREATEExportAnnualOverviewForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEExportAnnualOverviewForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEExportAnnualOverviewForUserRequestWithBody generates requests for CREATEExportAnnualOverviewForUser with any type of body
func NewCREATEExportAnnualOverviewForUserRequestWithBody(server string, userID int, params *CREATEExportAnnualOverviewForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/export-annual-overview", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllContentForUserExportAnnualOverviewRequest generates requests for ListAllContentForUserExportAnnualOverview
func NewListAllContentForUserExportAnnualOverviewRequest(server string, userID int, exportAnnualOverviewID int, params *ListAllContentForUserExportAnnualOverviewParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(exportAnnualOverviewID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/export-annual-overview/%s/content", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDELETEExportAnnualOverviewForUserRequest generates requests for DELETEExportAnnualOverviewForUser
func NewDELETEExportAnnualOverviewForUserRequest(server string, userID int, itemId int, params *DELETEExportAnnualOverviewForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/export-annual-overview/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADExportAnnualOverviewForUserRequest generates requests for READExportAnnualOverviewForUser
func NewREADExportAnnualOverviewForUserRequest(server string, userID int, itemId int, params *READExportAnnualOverviewForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/export-annual-overview/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADFeatureAnnouncementForUserRequest generates requests for READFeatureAnnouncementForUser
func NewREADFeatureAnnouncementForUserRequest(server string, userID int, itemId int, params *READFeatureAnnouncementForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/feature-announcement/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllInsightPreferenceDateForUserRequest generates requests for ListAllInsightPreferenceDateForUser
func NewListAllInsightPreferenceDateForUserRequest(server string, userID int, params *ListAllInsightPreferenceDateForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/insight-preference-date", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllInsightsForUserRequest generates requests for ListAllInsightsForUser
func NewListAllInsightsForUserRequest(server string, userID int, params *ListAllInsightsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/insights", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllInsightsSearchForUserRequest generates requests for ListAllInsightsSearchForUser
func NewListAllInsightsSearchForUserRequest(server string, userID int, params *ListAllInsightsSearchForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/insights-search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllInvoiceForUserRequest generates requests for ListAllInvoiceForUser
func NewListAllInvoiceForUserRequest(server string, userID int, params *ListAllInvoiceForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/invoice", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEInvoiceExportForUserInvoiceRequest calls the generic CREATEInvoiceExportForUserInvoice builder with application/json body
func NewCREATEInvoiceExportForUserInvoiceRequest(server string, userID int, invoiceID int, params *CREATEInvoiceExportForUserInvoiceParams, body CREATEInvoiceExportForUserInvoiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEInvoiceExportForUserInvoiceRequestWithBody(server, userID, invoiceID, params, "application/json", bodyReader)
}

// NewCREATEInvoiceExportForUserInvoiceRequestWithBody generates requests for CREATEInvoiceExportForUserInvoice with any type of body
func NewCREATEInvoiceExportForUserInvoiceRequestWithBody(server string, userID int, invoiceID int, params *CREATEInvoiceExportForUserInvoiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(invoiceID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/invoice/%s/invoice-export", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETEInvoiceExportForUserInvoiceRequest generates requests for DELETEInvoiceExportForUserInvoice
func NewDELETEInvoiceExportForUserInvoiceRequest(server string, userID int, invoiceID int, itemId int, params *DELETEInvoiceExportForUserInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(invoiceID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/invoice/%s/invoice-export/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADInvoiceExportForUserInvoiceRequest generates requests for READInvoiceExportForUserInvoice
func NewREADInvoiceExportForUserInvoiceRequest(server string, userID int, invoiceID int, itemId int, params *READInvoiceExportForUserInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(invoiceID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/invoice/%s/invoice-export/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEInvoiceExportForUserInvoiceRequest calls the generic UPDATEInvoiceExportForUserInvoice builder with application/json body
func NewUPDATEInvoiceExportForUserInvoiceRequest(server string, userID int, invoiceID int, itemId int, params *UPDATEInvoiceExportForUserInvoiceParams, body UPDATEInvoiceExportForUserInvoiceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEInvoiceExportForUserInvoiceRequestWithBody(server, userID, invoiceID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEInvoiceExportForUserInvoiceRequestWithBody generates requests for UPDATEInvoiceExportForUserInvoice with any type of body
func NewUPDATEInvoiceExportForUserInvoiceRequestWithBody(server string, userID int, invoiceID int, itemId int, params *UPDATEInvoiceExportForUserInvoiceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(invoiceID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/invoice/%s/invoice-export/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllPdfContentForUserInvoiceRequest generates requests for ListAllPdfContentForUserInvoice
func NewListAllPdfContentForUserInvoiceRequest(server string, userID int, invoiceID int, params *ListAllPdfContentForUserInvoiceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(invoiceID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/invoice/%s/pdf-content", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADInvoiceForUserRequest generates requests for READInvoiceForUser
func NewREADInvoiceForUserRequest(server string, userID int, itemId int, params *READInvoiceForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/invoice/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllLegalNameForUserRequest generates requests for ListAllLegalNameForUser
func NewListAllLegalNameForUserRequest(server string, userID int, params *ListAllLegalNameForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/legal-name", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllLimitForUserRequest generates requests for ListAllLimitForUser
func NewListAllLimitForUserRequest(server string, userID int, params *ListAllLimitForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/limit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllMonetaryAccountForUserRequest generates requests for ListAllMonetaryAccountForUser
func NewListAllMonetaryAccountForUserRequest(server string, userID int, params *ListAllMonetaryAccountForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != 0 {
			queryFrag := strconv.Itoa(params.Count)
			queryValues.Add("count", queryFrag)
		}
		if params.NewerId != 0 {
			queryFrag := strconv.Itoa(params.NewerId)
			queryValues.Add("newer_id", queryFrag)
		}
		if params.OlderId != 0 {
			queryFrag := strconv.Itoa(params.OlderId)
			queryValues.Add("older_id", queryFrag)
		}
		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllMonetaryAccountBankForUserRequest generates requests for ListAllMonetaryAccountBankForUser
func NewListAllMonetaryAccountBankForUserRequest(server string, userID int, params *ListAllMonetaryAccountBankForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-bank", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEMonetaryAccountBankForUserRequest calls the generic CREATEMonetaryAccountBankForUser builder with application/json body
func NewCREATEMonetaryAccountBankForUserRequest(server string, userID int, params *CREATEMonetaryAccountBankForUserParams, body CREATEMonetaryAccountBankForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEMonetaryAccountBankForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEMonetaryAccountBankForUserRequestWithBody generates requests for CREATEMonetaryAccountBankForUser with any type of body
func NewCREATEMonetaryAccountBankForUserRequestWithBody(server string, userID int, params *CREATEMonetaryAccountBankForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-bank", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADMonetaryAccountBankForUserRequest generates requests for READMonetaryAccountBankForUser
func NewREADMonetaryAccountBankForUserRequest(server string, userID int, itemId int, params *READMonetaryAccountBankForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-bank/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEMonetaryAccountBankForUserRequest calls the generic UPDATEMonetaryAccountBankForUser builder with application/json body
func NewUPDATEMonetaryAccountBankForUserRequest(server string, userID int, itemId int, params *UPDATEMonetaryAccountBankForUserParams, body UPDATEMonetaryAccountBankForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEMonetaryAccountBankForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEMonetaryAccountBankForUserRequestWithBody generates requests for UPDATEMonetaryAccountBankForUser with any type of body
func NewUPDATEMonetaryAccountBankForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEMonetaryAccountBankForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-bank/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllMonetaryAccountCardForUserRequest generates requests for ListAllMonetaryAccountCardForUser
func NewListAllMonetaryAccountCardForUserRequest(server string, userID int, params *ListAllMonetaryAccountCardForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-card", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADMonetaryAccountCardForUserRequest generates requests for READMonetaryAccountCardForUser
func NewREADMonetaryAccountCardForUserRequest(server string, userID int, itemId int, params *READMonetaryAccountCardForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-card/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEMonetaryAccountCardForUserRequest calls the generic UPDATEMonetaryAccountCardForUser builder with application/json body
func NewUPDATEMonetaryAccountCardForUserRequest(server string, userID int, itemId int, params *UPDATEMonetaryAccountCardForUserParams, body UPDATEMonetaryAccountCardForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEMonetaryAccountCardForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEMonetaryAccountCardForUserRequestWithBody generates requests for UPDATEMonetaryAccountCardForUser with any type of body
func NewUPDATEMonetaryAccountCardForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEMonetaryAccountCardForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-card/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllMonetaryAccountExternalForUserRequest generates requests for ListAllMonetaryAccountExternalForUser
func NewListAllMonetaryAccountExternalForUserRequest(server string, userID int, params *ListAllMonetaryAccountExternalForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEMonetaryAccountExternalForUserRequest calls the generic CREATEMonetaryAccountExternalForUser builder with application/json body
func NewCREATEMonetaryAccountExternalForUserRequest(server string, userID int, params *CREATEMonetaryAccountExternalForUserParams, body CREATEMonetaryAccountExternalForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEMonetaryAccountExternalForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEMonetaryAccountExternalForUserRequestWithBody generates requests for CREATEMonetaryAccountExternalForUser with any type of body
func NewCREATEMonetaryAccountExternalForUserRequestWithBody(server string, userID int, params *CREATEMonetaryAccountExternalForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllMonetaryAccountExternalSavingsForUserRequest generates requests for ListAllMonetaryAccountExternalSavingsForUser
func NewListAllMonetaryAccountExternalSavingsForUserRequest(server string, userID int, params *ListAllMonetaryAccountExternalSavingsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external-savings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEMonetaryAccountExternalSavingsForUserRequest calls the generic CREATEMonetaryAccountExternalSavingsForUser builder with application/json body
func NewCREATEMonetaryAccountExternalSavingsForUserRequest(server string, userID int, params *CREATEMonetaryAccountExternalSavingsForUserParams, body CREATEMonetaryAccountExternalSavingsForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEMonetaryAccountExternalSavingsForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEMonetaryAccountExternalSavingsForUserRequestWithBody generates requests for CREATEMonetaryAccountExternalSavingsForUser with any type of body
func NewCREATEMonetaryAccountExternalSavingsForUserRequestWithBody(server string, userID int, params *CREATEMonetaryAccountExternalSavingsForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external-savings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADMonetaryAccountExternalSavingsForUserRequest generates requests for READMonetaryAccountExternalSavingsForUser
func NewREADMonetaryAccountExternalSavingsForUserRequest(server string, userID int, itemId int, params *READMonetaryAccountExternalSavingsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external-savings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEMonetaryAccountExternalSavingsForUserRequest calls the generic UPDATEMonetaryAccountExternalSavingsForUser builder with application/json body
func NewUPDATEMonetaryAccountExternalSavingsForUserRequest(server string, userID int, itemId int, params *UPDATEMonetaryAccountExternalSavingsForUserParams, body UPDATEMonetaryAccountExternalSavingsForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEMonetaryAccountExternalSavingsForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEMonetaryAccountExternalSavingsForUserRequestWithBody generates requests for UPDATEMonetaryAccountExternalSavingsForUser with any type of body
func NewUPDATEMonetaryAccountExternalSavingsForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEMonetaryAccountExternalSavingsForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external-savings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADMonetaryAccountExternalForUserRequest generates requests for READMonetaryAccountExternalForUser
func NewREADMonetaryAccountExternalForUserRequest(server string, userID int, itemId int, params *READMonetaryAccountExternalForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEMonetaryAccountExternalForUserRequest calls the generic UPDATEMonetaryAccountExternalForUser builder with application/json body
func NewUPDATEMonetaryAccountExternalForUserRequest(server string, userID int, itemId int, params *UPDATEMonetaryAccountExternalForUserParams, body UPDATEMonetaryAccountExternalForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEMonetaryAccountExternalForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEMonetaryAccountExternalForUserRequestWithBody generates requests for UPDATEMonetaryAccountExternalForUser with any type of body
func NewUPDATEMonetaryAccountExternalForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEMonetaryAccountExternalForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-external/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllMonetaryAccountJointForUserRequest generates requests for ListAllMonetaryAccountJointForUser
func NewListAllMonetaryAccountJointForUserRequest(server string, userID int, params *ListAllMonetaryAccountJointForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-joint", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEMonetaryAccountJointForUserRequest calls the generic CREATEMonetaryAccountJointForUser builder with application/json body
func NewCREATEMonetaryAccountJointForUserRequest(server string, userID int, params *CREATEMonetaryAccountJointForUserParams, body CREATEMonetaryAccountJointForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEMonetaryAccountJointForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEMonetaryAccountJointForUserRequestWithBody generates requests for CREATEMonetaryAccountJointForUser with any type of body
func NewCREATEMonetaryAccountJointForUserRequestWithBody(server string, userID int, params *CREATEMonetaryAccountJointForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-joint", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADMonetaryAccountJointForUserRequest generates requests for READMonetaryAccountJointForUser
func NewREADMonetaryAccountJointForUserRequest(server string, userID int, itemId int, params *READMonetaryAccountJointForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-joint/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEMonetaryAccountJointForUserRequest calls the generic UPDATEMonetaryAccountJointForUser builder with application/json body
func NewUPDATEMonetaryAccountJointForUserRequest(server string, userID int, itemId int, params *UPDATEMonetaryAccountJointForUserParams, body UPDATEMonetaryAccountJointForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEMonetaryAccountJointForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEMonetaryAccountJointForUserRequestWithBody generates requests for UPDATEMonetaryAccountJointForUser with any type of body
func NewUPDATEMonetaryAccountJointForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEMonetaryAccountJointForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-joint/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllMonetaryAccountSavingsForUserRequest generates requests for ListAllMonetaryAccountSavingsForUser
func NewListAllMonetaryAccountSavingsForUserRequest(server string, userID int, params *ListAllMonetaryAccountSavingsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-savings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEMonetaryAccountSavingsForUserRequest calls the generic CREATEMonetaryAccountSavingsForUser builder with application/json body
func NewCREATEMonetaryAccountSavingsForUserRequest(server string, userID int, params *CREATEMonetaryAccountSavingsForUserParams, body CREATEMonetaryAccountSavingsForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEMonetaryAccountSavingsForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEMonetaryAccountSavingsForUserRequestWithBody generates requests for CREATEMonetaryAccountSavingsForUser with any type of body
func NewCREATEMonetaryAccountSavingsForUserRequestWithBody(server string, userID int, params *CREATEMonetaryAccountSavingsForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-savings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADMonetaryAccountSavingsForUserRequest generates requests for READMonetaryAccountSavingsForUser
func NewREADMonetaryAccountSavingsForUserRequest(server string, userID int, itemId int, params *READMonetaryAccountSavingsForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-savings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEMonetaryAccountSavingsForUserRequest calls the generic UPDATEMonetaryAccountSavingsForUser builder with application/json body
func NewUPDATEMonetaryAccountSavingsForUserRequest(server string, userID int, itemId int, params *UPDATEMonetaryAccountSavingsForUserParams, body UPDATEMonetaryAccountSavingsForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEMonetaryAccountSavingsForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEMonetaryAccountSavingsForUserRequestWithBody generates requests for UPDATEMonetaryAccountSavingsForUser with any type of body
func NewUPDATEMonetaryAccountSavingsForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEMonetaryAccountSavingsForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account-savings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADMonetaryAccountForUserRequest generates requests for READMonetaryAccountForUser
func NewREADMonetaryAccountForUserRequest(server string, userID int, itemId int, params *READMonetaryAccountForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransaction
func NewListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server, userID, monetaryAccountID, adyenCardTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransaction
func NewDELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest generates requests for READNoteAttachmentForUserMonetaryAccountAdyenCardTransaction
func NewREADNoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransaction with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountAdyenCardTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountAdyenCardTransactionRequest generates requests for ListAllNoteTextForUserMonetaryAccountAdyenCardTransaction
func NewListAllNoteTextForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *ListAllNoteTextForUserMonetaryAccountAdyenCardTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountAdyenCardTransactionRequest calls the generic CREATENoteTextForUserMonetaryAccountAdyenCardTransaction builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, body CREATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server, userID, monetaryAccountID, adyenCardTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountAdyenCardTransactionRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountAdyenCardTransaction with any type of body
func NewCREATENoteTextForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, params *CREATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountAdyenCardTransactionRequest generates requests for DELETENoteTextForUserMonetaryAccountAdyenCardTransaction
func NewDELETENoteTextForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountAdyenCardTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountAdyenCardTransactionRequest generates requests for READNoteTextForUserMonetaryAccountAdyenCardTransaction
func NewREADNoteTextForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountAdyenCardTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountAdyenCardTransactionRequest calls the generic UPDATENoteTextForUserMonetaryAccountAdyenCardTransaction builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountAdyenCardTransactionRequest(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, body UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server, userID, monetaryAccountID, adyenCardTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountAdyenCardTransactionRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountAdyenCardTransaction with any type of body
func NewUPDATENoteTextForUserMonetaryAccountAdyenCardTransactionRequestWithBody(server string, userID int, monetaryAccountID int, adyenCardTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountAdyenCardTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(adyenCardTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/adyen-card-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATEAttachmentForUserMonetaryAccountRequest calls the generic CREATEAttachmentForUserMonetaryAccount builder with application/json body
func NewCREATEAttachmentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEAttachmentForUserMonetaryAccountParams, body CREATEAttachmentForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEAttachmentForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEAttachmentForUserMonetaryAccountRequestWithBody generates requests for CREATEAttachmentForUserMonetaryAccount with any type of body
func NewCREATEAttachmentForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEAttachmentForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/attachment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllContentForUserMonetaryAccountAttachmentRequest generates requests for ListAllContentForUserMonetaryAccountAttachment
func NewListAllContentForUserMonetaryAccountAttachmentRequest(server string, userID int, monetaryAccountID int, attachmentID int, params *ListAllContentForUserMonetaryAccountAttachmentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(attachmentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/attachment/%s/content", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult
func NewListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *ListAllNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, body CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server, userID, monetaryAccountID, bunqmeFundraiserResultID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult
func NewDELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest generates requests for READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult
func NewREADNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, body UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResult with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountBunqmeFundraiserResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest generates requests for ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResult
func NewListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *ListAllNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest calls the generic CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResult builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, body CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server, userID, monetaryAccountID, bunqmeFundraiserResultID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResult with any type of body
func NewCREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, params *CREATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest generates requests for DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResult
func NewDELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *DELETENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest generates requests for READNoteTextForUserMonetaryAccountBunqmeFundraiserResult
func NewREADNoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *READNoteTextForUserMonetaryAccountBunqmeFundraiserResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest calls the generic UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResult builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequest(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, body UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server, userID, monetaryAccountID, bunqmeFundraiserResultID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResult with any type of body
func NewUPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultRequestWithBody(server string, userID int, monetaryAccountID int, bunqmeFundraiserResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountBunqmeFundraiserResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(bunqmeFundraiserResultID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADBunqmeFundraiserResultForUserMonetaryAccountRequest generates requests for READBunqmeFundraiserResultForUserMonetaryAccount
func NewREADBunqmeFundraiserResultForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READBunqmeFundraiserResultForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-fundraiser-result/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllBunqmeTabForUserMonetaryAccountRequest generates requests for ListAllBunqmeTabForUserMonetaryAccount
func NewListAllBunqmeTabForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllBunqmeTabForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-tab", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEBunqmeTabForUserMonetaryAccountRequest calls the generic CREATEBunqmeTabForUserMonetaryAccount builder with application/json body
func NewCREATEBunqmeTabForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEBunqmeTabForUserMonetaryAccountParams, body CREATEBunqmeTabForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEBunqmeTabForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEBunqmeTabForUserMonetaryAccountRequestWithBody generates requests for CREATEBunqmeTabForUserMonetaryAccount with any type of body
func NewCREATEBunqmeTabForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEBunqmeTabForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-tab", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADBunqmeTabResultResponseForUserMonetaryAccountRequest generates requests for READBunqmeTabResultResponseForUserMonetaryAccount
func NewREADBunqmeTabResultResponseForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READBunqmeTabResultResponseForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-tab-result-response/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADBunqmeTabForUserMonetaryAccountRequest generates requests for READBunqmeTabForUserMonetaryAccount
func NewREADBunqmeTabForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READBunqmeTabForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-tab/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEBunqmeTabForUserMonetaryAccountRequest calls the generic UPDATEBunqmeTabForUserMonetaryAccount builder with application/json body
func NewUPDATEBunqmeTabForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEBunqmeTabForUserMonetaryAccountParams, body UPDATEBunqmeTabForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEBunqmeTabForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEBunqmeTabForUserMonetaryAccountRequestWithBody generates requests for UPDATEBunqmeTabForUserMonetaryAccount with any type of body
func NewUPDATEBunqmeTabForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEBunqmeTabForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/bunqme-tab/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATECurrencyCloudPaymentQuoteForUserMonetaryAccountRequest calls the generic CREATECurrencyCloudPaymentQuoteForUserMonetaryAccount builder with application/json body
func NewCREATECurrencyCloudPaymentQuoteForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountParams, body CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECurrencyCloudPaymentQuoteForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATECurrencyCloudPaymentQuoteForUserMonetaryAccountRequestWithBody generates requests for CREATECurrencyCloudPaymentQuoteForUserMonetaryAccount with any type of body
func NewCREATECurrencyCloudPaymentQuoteForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATECurrencyCloudPaymentQuoteForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/currency-cloud-payment-quote", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCurrencyConversionForUserMonetaryAccountRequest generates requests for ListAllCurrencyConversionForUserMonetaryAccount
func NewListAllCurrencyConversionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllCurrencyConversionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/currency-conversion", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATECurrencyConversionQuoteForUserMonetaryAccountRequest calls the generic CREATECurrencyConversionQuoteForUserMonetaryAccount builder with application/json body
func NewCREATECurrencyConversionQuoteForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATECurrencyConversionQuoteForUserMonetaryAccountParams, body CREATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECurrencyConversionQuoteForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATECurrencyConversionQuoteForUserMonetaryAccountRequestWithBody generates requests for CREATECurrencyConversionQuoteForUserMonetaryAccount with any type of body
func NewCREATECurrencyConversionQuoteForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATECurrencyConversionQuoteForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/currency-conversion-quote", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADCurrencyConversionQuoteForUserMonetaryAccountRequest generates requests for READCurrencyConversionQuoteForUserMonetaryAccount
func NewREADCurrencyConversionQuoteForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READCurrencyConversionQuoteForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/currency-conversion-quote/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATECurrencyConversionQuoteForUserMonetaryAccountRequest calls the generic UPDATECurrencyConversionQuoteForUserMonetaryAccount builder with application/json body
func NewUPDATECurrencyConversionQuoteForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATECurrencyConversionQuoteForUserMonetaryAccountParams, body UPDATECurrencyConversionQuoteForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATECurrencyConversionQuoteForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATECurrencyConversionQuoteForUserMonetaryAccountRequestWithBody generates requests for UPDATECurrencyConversionQuoteForUserMonetaryAccount with any type of body
func NewUPDATECurrencyConversionQuoteForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATECurrencyConversionQuoteForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/currency-conversion-quote/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADCurrencyConversionForUserMonetaryAccountRequest generates requests for READCurrencyConversionForUserMonetaryAccount
func NewREADCurrencyConversionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READCurrencyConversionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/currency-conversion/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllCustomerStatementForUserMonetaryAccountRequest generates requests for ListAllCustomerStatementForUserMonetaryAccount
func NewListAllCustomerStatementForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllCustomerStatementForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/customer-statement", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATECustomerStatementForUserMonetaryAccountRequest calls the generic CREATECustomerStatementForUserMonetaryAccount builder with application/json body
func NewCREATECustomerStatementForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATECustomerStatementForUserMonetaryAccountParams, body CREATECustomerStatementForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECustomerStatementForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATECustomerStatementForUserMonetaryAccountRequestWithBody generates requests for CREATECustomerStatementForUserMonetaryAccount with any type of body
func NewCREATECustomerStatementForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATECustomerStatementForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/customer-statement", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllContentForUserMonetaryAccountCustomerStatementRequest generates requests for ListAllContentForUserMonetaryAccountCustomerStatement
func NewListAllContentForUserMonetaryAccountCustomerStatementRequest(server string, userID int, monetaryAccountID int, customerStatementID int, params *ListAllContentForUserMonetaryAccountCustomerStatementParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(customerStatementID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/customer-statement/%s/content", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDELETECustomerStatementForUserMonetaryAccountRequest generates requests for DELETECustomerStatementForUserMonetaryAccount
func NewDELETECustomerStatementForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *DELETECustomerStatementForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/customer-statement/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADCustomerStatementForUserMonetaryAccountRequest generates requests for READCustomerStatementForUserMonetaryAccount
func NewREADCustomerStatementForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READCustomerStatementForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/customer-statement/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllDraftPaymentForUserMonetaryAccountRequest generates requests for ListAllDraftPaymentForUserMonetaryAccount
func NewListAllDraftPaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllDraftPaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEDraftPaymentForUserMonetaryAccountRequest calls the generic CREATEDraftPaymentForUserMonetaryAccount builder with application/json body
func NewCREATEDraftPaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEDraftPaymentForUserMonetaryAccountParams, body CREATEDraftPaymentForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEDraftPaymentForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEDraftPaymentForUserMonetaryAccountRequestWithBody generates requests for CREATEDraftPaymentForUserMonetaryAccount with any type of body
func NewCREATEDraftPaymentForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEDraftPaymentForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountDraftPaymentRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountDraftPayment
func NewListAllNoteAttachmentForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountDraftPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountDraftPaymentRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountDraftPayment builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, body CREATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountDraftPaymentRequestWithBody(server, userID, monetaryAccountID, draftPaymentID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountDraftPaymentRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountDraftPayment with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountDraftPaymentRequestWithBody(server string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountDraftPaymentRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountDraftPayment
func NewDELETENoteAttachmentForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountDraftPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountDraftPaymentRequest generates requests for READNoteAttachmentForUserMonetaryAccountDraftPayment
func NewREADNoteAttachmentForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountDraftPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountDraftPaymentRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountDraftPayment builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountDraftPaymentRequestWithBody(server, userID, monetaryAccountID, draftPaymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountDraftPaymentRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountDraftPayment with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountDraftPaymentRequestWithBody(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountDraftPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountDraftPaymentRequest generates requests for ListAllNoteTextForUserMonetaryAccountDraftPayment
func NewListAllNoteTextForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, params *ListAllNoteTextForUserMonetaryAccountDraftPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountDraftPaymentRequest calls the generic CREATENoteTextForUserMonetaryAccountDraftPayment builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteTextForUserMonetaryAccountDraftPaymentParams, body CREATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountDraftPaymentRequestWithBody(server, userID, monetaryAccountID, draftPaymentID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountDraftPaymentRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountDraftPayment with any type of body
func NewCREATENoteTextForUserMonetaryAccountDraftPaymentRequestWithBody(server string, userID int, monetaryAccountID int, draftPaymentID int, params *CREATENoteTextForUserMonetaryAccountDraftPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountDraftPaymentRequest generates requests for DELETENoteTextForUserMonetaryAccountDraftPayment
func NewDELETENoteTextForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountDraftPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountDraftPaymentRequest generates requests for READNoteTextForUserMonetaryAccountDraftPayment
func NewREADNoteTextForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountDraftPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountDraftPaymentRequest calls the generic UPDATENoteTextForUserMonetaryAccountDraftPayment builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountDraftPaymentRequest(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountDraftPaymentParams, body UPDATENoteTextForUserMonetaryAccountDraftPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountDraftPaymentRequestWithBody(server, userID, monetaryAccountID, draftPaymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountDraftPaymentRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountDraftPayment with any type of body
func NewUPDATENoteTextForUserMonetaryAccountDraftPaymentRequestWithBody(server string, userID int, monetaryAccountID int, draftPaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountDraftPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(draftPaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADDraftPaymentForUserMonetaryAccountRequest generates requests for READDraftPaymentForUserMonetaryAccount
func NewREADDraftPaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READDraftPaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEDraftPaymentForUserMonetaryAccountRequest calls the generic UPDATEDraftPaymentForUserMonetaryAccount builder with application/json body
func NewUPDATEDraftPaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEDraftPaymentForUserMonetaryAccountParams, body UPDATEDraftPaymentForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEDraftPaymentForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEDraftPaymentForUserMonetaryAccountRequestWithBody generates requests for UPDATEDraftPaymentForUserMonetaryAccount with any type of body
func NewUPDATEDraftPaymentForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEDraftPaymentForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/draft-payment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATEStatementForUserMonetaryAccountEventRequest calls the generic CREATEStatementForUserMonetaryAccountEvent builder with application/json body
func NewCREATEStatementForUserMonetaryAccountEventRequest(server string, userID int, monetaryAccountID int, eventID int, params *CREATEStatementForUserMonetaryAccountEventParams, body CREATEStatementForUserMonetaryAccountEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEStatementForUserMonetaryAccountEventRequestWithBody(server, userID, monetaryAccountID, eventID, params, "application/json", bodyReader)
}

// NewCREATEStatementForUserMonetaryAccountEventRequestWithBody generates requests for CREATEStatementForUserMonetaryAccountEvent with any type of body
func NewCREATEStatementForUserMonetaryAccountEventRequestWithBody(server string, userID int, monetaryAccountID int, eventID int, params *CREATEStatementForUserMonetaryAccountEventParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(eventID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/event/%s/statement", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADStatementForUserMonetaryAccountEventRequest generates requests for READStatementForUserMonetaryAccountEvent
func NewREADStatementForUserMonetaryAccountEventRequest(server string, userID int, monetaryAccountID int, eventID int, itemId int, params *READStatementForUserMonetaryAccountEventParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(eventID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/event/%s/statement/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllContentForUserMonetaryAccountEventStatementRequest generates requests for ListAllContentForUserMonetaryAccountEventStatement
func NewListAllContentForUserMonetaryAccountEventStatementRequest(server string, userID int, monetaryAccountID int, eventID int, statementID int, params *ListAllContentForUserMonetaryAccountEventStatementParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(eventID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(statementID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/event/%s/statement/%s/content", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllExportRibForUserMonetaryAccountRequest generates requests for ListAllExportRibForUserMonetaryAccount
func NewListAllExportRibForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllExportRibForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/export-rib", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEExportRibForUserMonetaryAccountRequest calls the generic CREATEExportRibForUserMonetaryAccount builder with application/json body
func NewCREATEExportRibForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEExportRibForUserMonetaryAccountParams, body CREATEExportRibForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEExportRibForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEExportRibForUserMonetaryAccountRequestWithBody generates requests for CREATEExportRibForUserMonetaryAccount with any type of body
func NewCREATEExportRibForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEExportRibForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/export-rib", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllContentForUserMonetaryAccountExportRibRequest generates requests for ListAllContentForUserMonetaryAccountExportRib
func NewListAllContentForUserMonetaryAccountExportRibRequest(server string, userID int, monetaryAccountID int, exportRibID int, params *ListAllContentForUserMonetaryAccountExportRibParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(exportRibID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/export-rib/%s/content", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDELETEExportRibForUserMonetaryAccountRequest generates requests for DELETEExportRibForUserMonetaryAccount
func NewDELETEExportRibForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *DELETEExportRibForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/export-rib/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADExportRibForUserMonetaryAccountRequest generates requests for READExportRibForUserMonetaryAccount
func NewREADExportRibForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READExportRibForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/export-rib/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllIdealMerchantTransactionForUserMonetaryAccountRequest generates requests for ListAllIdealMerchantTransactionForUserMonetaryAccount
func NewListAllIdealMerchantTransactionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllIdealMerchantTransactionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEIdealMerchantTransactionForUserMonetaryAccountRequest calls the generic CREATEIdealMerchantTransactionForUserMonetaryAccount builder with application/json body
func NewCREATEIdealMerchantTransactionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEIdealMerchantTransactionForUserMonetaryAccountParams, body CREATEIdealMerchantTransactionForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEIdealMerchantTransactionForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEIdealMerchantTransactionForUserMonetaryAccountRequestWithBody generates requests for CREATEIdealMerchantTransactionForUserMonetaryAccount with any type of body
func NewCREATEIdealMerchantTransactionForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEIdealMerchantTransactionForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction
func NewListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, idealMerchantTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction
func NewDELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest generates requests for READNoteAttachmentForUserMonetaryAccountIdealMerchantTransaction
func NewREADNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransaction with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountIdealMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionRequest generates requests for ListAllNoteTextForUserMonetaryAccountIdealMerchantTransaction
func NewListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountIdealMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest calls the generic CREATENoteTextForUserMonetaryAccountIdealMerchantTransaction builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, idealMerchantTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountIdealMerchantTransaction with any type of body
func NewCREATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest generates requests for DELETENoteTextForUserMonetaryAccountIdealMerchantTransaction
func NewDELETENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountIdealMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountIdealMerchantTransactionRequest generates requests for READNoteTextForUserMonetaryAccountIdealMerchantTransaction
func NewREADNoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountIdealMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest calls the generic UPDATENoteTextForUserMonetaryAccountIdealMerchantTransaction builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequest(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, idealMerchantTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountIdealMerchantTransaction with any type of body
func NewUPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, idealMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountIdealMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(idealMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADIdealMerchantTransactionForUserMonetaryAccountRequest generates requests for READIdealMerchantTransactionForUserMonetaryAccount
func NewREADIdealMerchantTransactionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READIdealMerchantTransactionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/ideal-merchant-transaction/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllInvoiceForUserMonetaryAccountRequest generates requests for ListAllInvoiceForUserMonetaryAccount
func NewListAllInvoiceForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllInvoiceForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/invoice", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADInvoiceForUserMonetaryAccountRequest generates requests for READInvoiceForUserMonetaryAccount
func NewREADInvoiceForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READInvoiceForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/invoice/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllMastercardActionForUserMonetaryAccountRequest generates requests for ListAllMastercardActionForUserMonetaryAccount
func NewListAllMastercardActionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllMastercardActionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADMastercardActionForUserMonetaryAccountRequest generates requests for READMastercardActionForUserMonetaryAccount
func NewREADMastercardActionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READMastercardActionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountMastercardActionRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountMastercardAction
func NewListAllNoteAttachmentForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllNoteAttachmentForUserMonetaryAccountMastercardActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountMastercardActionRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountMastercardAction builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteAttachmentForUserMonetaryAccountMastercardActionParams, body CREATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountMastercardActionRequestWithBody(server, userID, monetaryAccountID, mastercardActionID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountMastercardActionRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountMastercardAction with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountMastercardActionRequestWithBody(server string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteAttachmentForUserMonetaryAccountMastercardActionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountMastercardActionRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountMastercardAction
func NewDELETENoteAttachmentForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountMastercardActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountMastercardActionRequest generates requests for READNoteAttachmentForUserMonetaryAccountMastercardAction
func NewREADNoteAttachmentForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountMastercardActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountMastercardActionRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountMastercardAction builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountMastercardActionParams, body UPDATENoteAttachmentForUserMonetaryAccountMastercardActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountMastercardActionRequestWithBody(server, userID, monetaryAccountID, mastercardActionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountMastercardActionRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountMastercardAction with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountMastercardActionRequestWithBody(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountMastercardActionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountMastercardActionRequest generates requests for ListAllNoteTextForUserMonetaryAccountMastercardAction
func NewListAllNoteTextForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllNoteTextForUserMonetaryAccountMastercardActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountMastercardActionRequest calls the generic CREATENoteTextForUserMonetaryAccountMastercardAction builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteTextForUserMonetaryAccountMastercardActionParams, body CREATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountMastercardActionRequestWithBody(server, userID, monetaryAccountID, mastercardActionID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountMastercardActionRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountMastercardAction with any type of body
func NewCREATENoteTextForUserMonetaryAccountMastercardActionRequestWithBody(server string, userID int, monetaryAccountID int, mastercardActionID int, params *CREATENoteTextForUserMonetaryAccountMastercardActionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountMastercardActionRequest generates requests for DELETENoteTextForUserMonetaryAccountMastercardAction
func NewDELETENoteTextForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountMastercardActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountMastercardActionRequest generates requests for READNoteTextForUserMonetaryAccountMastercardAction
func NewREADNoteTextForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *READNoteTextForUserMonetaryAccountMastercardActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountMastercardActionRequest calls the generic UPDATENoteTextForUserMonetaryAccountMastercardAction builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountMastercardActionParams, body UPDATENoteTextForUserMonetaryAccountMastercardActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountMastercardActionRequestWithBody(server, userID, monetaryAccountID, mastercardActionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountMastercardActionRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountMastercardAction with any type of body
func NewUPDATENoteTextForUserMonetaryAccountMastercardActionRequestWithBody(server string, userID int, monetaryAccountID int, mastercardActionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountMastercardActionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllPaymentForUserMonetaryAccountMastercardActionRequest generates requests for ListAllPaymentForUserMonetaryAccountMastercardAction
func NewListAllPaymentForUserMonetaryAccountMastercardActionRequest(server string, userID int, monetaryAccountID int, mastercardActionID int, params *ListAllPaymentForUserMonetaryAccountMastercardActionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(mastercardActionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/mastercard-action/%s/payment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNotificationFilterUrlForUserMonetaryAccountRequest generates requests for ListAllNotificationFilterUrlForUserMonetaryAccount
func NewListAllNotificationFilterUrlForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllNotificationFilterUrlForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/notification-filter-url", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENotificationFilterUrlForUserMonetaryAccountRequest calls the generic CREATENotificationFilterUrlForUserMonetaryAccount builder with application/json body
func NewCREATENotificationFilterUrlForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATENotificationFilterUrlForUserMonetaryAccountParams, body CREATENotificationFilterUrlForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENotificationFilterUrlForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATENotificationFilterUrlForUserMonetaryAccountRequestWithBody generates requests for CREATENotificationFilterUrlForUserMonetaryAccount with any type of body
func NewCREATENotificationFilterUrlForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATENotificationFilterUrlForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/notification-filter-url", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction
func NewListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, openBankingMerchantTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction
func NewDELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest generates requests for READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction
func NewREADNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransaction with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountOpenBankingMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest generates requests for ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction
func NewListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest calls the generic CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, openBankingMerchantTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction with any type of body
func NewCREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest generates requests for DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction
func NewDELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest generates requests for READNoteTextForUserMonetaryAccountOpenBankingMerchantTransaction
func NewREADNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest calls the generic UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequest(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, openBankingMerchantTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransaction with any type of body
func NewUPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, openBankingMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountOpenBankingMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(openBankingMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/open-banking-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllPaymentForUserMonetaryAccountRequest generates requests for ListAllPaymentForUserMonetaryAccount
func NewListAllPaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllPaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != 0 {
			queryFrag := strconv.Itoa(params.Count)
			queryValues.Add("count", queryFrag)
		}
		if params.NewerId != 0 {
			queryFrag := strconv.Itoa(params.NewerId)
			queryValues.Add("newer_id", queryFrag)
		}
		if params.OlderId != 0 {
			queryFrag := strconv.Itoa(params.OlderId)
			queryValues.Add("older_id", queryFrag)
		}
		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEPaymentForUserMonetaryAccountRequest calls the generic CREATEPaymentForUserMonetaryAccount builder with application/json body
func NewCREATEPaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEPaymentForUserMonetaryAccountParams, body CREATEPaymentForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEPaymentForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEPaymentForUserMonetaryAccountRequestWithBody generates requests for CREATEPaymentForUserMonetaryAccount with any type of body
func NewCREATEPaymentForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEPaymentForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllPaymentAutoAllocateForUserMonetaryAccountRequest generates requests for ListAllPaymentAutoAllocateForUserMonetaryAccount
func NewListAllPaymentAutoAllocateForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllPaymentAutoAllocateForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEPaymentAutoAllocateForUserMonetaryAccountRequest calls the generic CREATEPaymentAutoAllocateForUserMonetaryAccount builder with application/json body
func NewCREATEPaymentAutoAllocateForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEPaymentAutoAllocateForUserMonetaryAccountParams, body CREATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEPaymentAutoAllocateForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEPaymentAutoAllocateForUserMonetaryAccountRequestWithBody generates requests for CREATEPaymentAutoAllocateForUserMonetaryAccount with any type of body
func NewCREATEPaymentAutoAllocateForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEPaymentAutoAllocateForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETEPaymentAutoAllocateForUserMonetaryAccountRequest generates requests for DELETEPaymentAutoAllocateForUserMonetaryAccount
func NewDELETEPaymentAutoAllocateForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *DELETEPaymentAutoAllocateForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADPaymentAutoAllocateForUserMonetaryAccountRequest generates requests for READPaymentAutoAllocateForUserMonetaryAccount
func NewREADPaymentAutoAllocateForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READPaymentAutoAllocateForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEPaymentAutoAllocateForUserMonetaryAccountRequest calls the generic UPDATEPaymentAutoAllocateForUserMonetaryAccount builder with application/json body
func NewUPDATEPaymentAutoAllocateForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentAutoAllocateForUserMonetaryAccountParams, body UPDATEPaymentAutoAllocateForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEPaymentAutoAllocateForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEPaymentAutoAllocateForUserMonetaryAccountRequestWithBody generates requests for UPDATEPaymentAutoAllocateForUserMonetaryAccount with any type of body
func NewUPDATEPaymentAutoAllocateForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentAutoAllocateForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateRequest generates requests for ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocate
func NewListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateRequest(server string, userID int, monetaryAccountID int, paymentAutoAllocateID int, params *ListAllDefinitionForUserMonetaryAccountPaymentAutoAllocateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentAutoAllocateID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate/%s/definition", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllInstanceForUserMonetaryAccountPaymentAutoAllocateRequest generates requests for ListAllInstanceForUserMonetaryAccountPaymentAutoAllocate
func NewListAllInstanceForUserMonetaryAccountPaymentAutoAllocateRequest(server string, userID int, monetaryAccountID int, paymentAutoAllocateID int, params *ListAllInstanceForUserMonetaryAccountPaymentAutoAllocateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentAutoAllocateID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate/%s/instance", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADInstanceForUserMonetaryAccountPaymentAutoAllocateRequest generates requests for READInstanceForUserMonetaryAccountPaymentAutoAllocate
func NewREADInstanceForUserMonetaryAccountPaymentAutoAllocateRequest(server string, userID int, monetaryAccountID int, paymentAutoAllocateID int, itemId int, params *READInstanceForUserMonetaryAccountPaymentAutoAllocateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentAutoAllocateID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-auto-allocate/%s/instance/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllPaymentBatchForUserMonetaryAccountRequest generates requests for ListAllPaymentBatchForUserMonetaryAccount
func NewListAllPaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllPaymentBatchForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEPaymentBatchForUserMonetaryAccountRequest calls the generic CREATEPaymentBatchForUserMonetaryAccount builder with application/json body
func NewCREATEPaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEPaymentBatchForUserMonetaryAccountParams, body CREATEPaymentBatchForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEPaymentBatchForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEPaymentBatchForUserMonetaryAccountRequestWithBody generates requests for CREATEPaymentBatchForUserMonetaryAccount with any type of body
func NewCREATEPaymentBatchForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEPaymentBatchForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADPaymentBatchForUserMonetaryAccountRequest generates requests for READPaymentBatchForUserMonetaryAccount
func NewREADPaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READPaymentBatchForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEPaymentBatchForUserMonetaryAccountRequest calls the generic UPDATEPaymentBatchForUserMonetaryAccount builder with application/json body
func NewUPDATEPaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentBatchForUserMonetaryAccountParams, body UPDATEPaymentBatchForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEPaymentBatchForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEPaymentBatchForUserMonetaryAccountRequestWithBody generates requests for UPDATEPaymentBatchForUserMonetaryAccount with any type of body
func NewUPDATEPaymentBatchForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEPaymentBatchForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountPaymentBatchRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountPaymentBatch
func NewListAllNoteAttachmentForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountPaymentBatchRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountPaymentBatch builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountPaymentBatchRequestWithBody(server, userID, monetaryAccountID, paymentBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountPaymentBatchRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountPaymentBatch with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountPaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountPaymentBatchRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountPaymentBatch
func NewDELETENoteAttachmentForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountPaymentBatchRequest generates requests for READNoteAttachmentForUserMonetaryAccountPaymentBatch
func NewREADNoteAttachmentForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountPaymentBatchRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountPaymentBatch builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountPaymentBatchRequestWithBody(server, userID, monetaryAccountID, paymentBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountPaymentBatchRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountPaymentBatch with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountPaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountPaymentBatchRequest generates requests for ListAllNoteTextForUserMonetaryAccountPaymentBatch
func NewListAllNoteTextForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, params *ListAllNoteTextForUserMonetaryAccountPaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountPaymentBatchRequest calls the generic CREATENoteTextForUserMonetaryAccountPaymentBatch builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteTextForUserMonetaryAccountPaymentBatchParams, body CREATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountPaymentBatchRequestWithBody(server, userID, monetaryAccountID, paymentBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountPaymentBatchRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountPaymentBatch with any type of body
func NewCREATENoteTextForUserMonetaryAccountPaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, paymentBatchID int, params *CREATENoteTextForUserMonetaryAccountPaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountPaymentBatchRequest generates requests for DELETENoteTextForUserMonetaryAccountPaymentBatch
func NewDELETENoteTextForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountPaymentBatchRequest generates requests for READNoteTextForUserMonetaryAccountPaymentBatch
func NewREADNoteTextForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountPaymentBatchRequest calls the generic UPDATENoteTextForUserMonetaryAccountPaymentBatch builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountPaymentBatchRequest(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentBatchParams, body UPDATENoteTextForUserMonetaryAccountPaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountPaymentBatchRequestWithBody(server, userID, monetaryAccountID, paymentBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountPaymentBatchRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountPaymentBatch with any type of body
func NewUPDATENoteTextForUserMonetaryAccountPaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, paymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayed
func NewListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentDelayedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountPaymentDelayed builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequestWithBody(server, userID, monetaryAccountID, paymentDelayedID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountPaymentDelayed with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequestWithBody(server string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountPaymentDelayed
func NewDELETENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentDelayedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountPaymentDelayedRequest generates requests for READNoteAttachmentForUserMonetaryAccountPaymentDelayed
func NewREADNoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentDelayedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayed builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequestWithBody(server, userID, monetaryAccountID, paymentDelayedID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayed with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedRequestWithBody(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentDelayedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountPaymentDelayedRequest generates requests for ListAllNoteTextForUserMonetaryAccountPaymentDelayed
func NewListAllNoteTextForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, params *ListAllNoteTextForUserMonetaryAccountPaymentDelayedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountPaymentDelayedRequest calls the generic CREATENoteTextForUserMonetaryAccountPaymentDelayed builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteTextForUserMonetaryAccountPaymentDelayedParams, body CREATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountPaymentDelayedRequestWithBody(server, userID, monetaryAccountID, paymentDelayedID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountPaymentDelayedRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountPaymentDelayed with any type of body
func NewCREATENoteTextForUserMonetaryAccountPaymentDelayedRequestWithBody(server string, userID int, monetaryAccountID int, paymentDelayedID int, params *CREATENoteTextForUserMonetaryAccountPaymentDelayedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountPaymentDelayedRequest generates requests for DELETENoteTextForUserMonetaryAccountPaymentDelayed
func NewDELETENoteTextForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentDelayedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountPaymentDelayedRequest generates requests for READNoteTextForUserMonetaryAccountPaymentDelayed
func NewREADNoteTextForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentDelayedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountPaymentDelayedRequest calls the generic UPDATENoteTextForUserMonetaryAccountPaymentDelayed builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountPaymentDelayedRequest(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentDelayedParams, body UPDATENoteTextForUserMonetaryAccountPaymentDelayedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountPaymentDelayedRequestWithBody(server, userID, monetaryAccountID, paymentDelayedID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountPaymentDelayedRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountPaymentDelayed with any type of body
func NewUPDATENoteTextForUserMonetaryAccountPaymentDelayedRequestWithBody(server string, userID int, monetaryAccountID int, paymentDelayedID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentDelayedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentDelayedID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment-delayed/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADPaymentForUserMonetaryAccountRequest generates requests for READPaymentForUserMonetaryAccount
func NewREADPaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READPaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountPaymentRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountPayment
func NewListAllNoteAttachmentForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountPaymentRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountPayment builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentParams, body CREATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountPaymentRequestWithBody(server, userID, monetaryAccountID, paymentID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountPaymentRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountPayment with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountPaymentRequestWithBody(server string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteAttachmentForUserMonetaryAccountPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountPaymentRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountPayment
func NewDELETENoteAttachmentForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountPaymentRequest generates requests for READNoteAttachmentForUserMonetaryAccountPayment
func NewREADNoteAttachmentForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountPaymentRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountPayment builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountPaymentRequestWithBody(server, userID, monetaryAccountID, paymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountPaymentRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountPayment with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountPaymentRequestWithBody(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountPaymentRequest generates requests for ListAllNoteTextForUserMonetaryAccountPayment
func NewListAllNoteTextForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, params *ListAllNoteTextForUserMonetaryAccountPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountPaymentRequest calls the generic CREATENoteTextForUserMonetaryAccountPayment builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteTextForUserMonetaryAccountPaymentParams, body CREATENoteTextForUserMonetaryAccountPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountPaymentRequestWithBody(server, userID, monetaryAccountID, paymentID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountPaymentRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountPayment with any type of body
func NewCREATENoteTextForUserMonetaryAccountPaymentRequestWithBody(server string, userID int, monetaryAccountID int, paymentID int, params *CREATENoteTextForUserMonetaryAccountPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountPaymentRequest generates requests for DELETENoteTextForUserMonetaryAccountPayment
func NewDELETENoteTextForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountPaymentRequest generates requests for READNoteTextForUserMonetaryAccountPayment
func NewREADNoteTextForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *READNoteTextForUserMonetaryAccountPaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountPaymentRequest calls the generic UPDATENoteTextForUserMonetaryAccountPayment builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountPaymentRequest(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentParams, body UPDATENoteTextForUserMonetaryAccountPaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountPaymentRequestWithBody(server, userID, monetaryAccountID, paymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountPaymentRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountPayment with any type of body
func NewUPDATENoteTextForUserMonetaryAccountPaymentRequestWithBody(server string, userID int, monetaryAccountID int, paymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountPaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(paymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllRequestInquiryForUserMonetaryAccountRequest generates requests for ListAllRequestInquiryForUserMonetaryAccount
func NewListAllRequestInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllRequestInquiryForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATERequestInquiryForUserMonetaryAccountRequest calls the generic CREATERequestInquiryForUserMonetaryAccount builder with application/json body
func NewCREATERequestInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATERequestInquiryForUserMonetaryAccountParams, body CREATERequestInquiryForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATERequestInquiryForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATERequestInquiryForUserMonetaryAccountRequestWithBody generates requests for CREATERequestInquiryForUserMonetaryAccount with any type of body
func NewCREATERequestInquiryForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATERequestInquiryForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllRequestInquiryBatchForUserMonetaryAccountRequest generates requests for ListAllRequestInquiryBatchForUserMonetaryAccount
func NewListAllRequestInquiryBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllRequestInquiryBatchForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATERequestInquiryBatchForUserMonetaryAccountRequest calls the generic CREATERequestInquiryBatchForUserMonetaryAccount builder with application/json body
func NewCREATERequestInquiryBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATERequestInquiryBatchForUserMonetaryAccountParams, body CREATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATERequestInquiryBatchForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATERequestInquiryBatchForUserMonetaryAccountRequestWithBody generates requests for CREATERequestInquiryBatchForUserMonetaryAccount with any type of body
func NewCREATERequestInquiryBatchForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATERequestInquiryBatchForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADRequestInquiryBatchForUserMonetaryAccountRequest generates requests for READRequestInquiryBatchForUserMonetaryAccount
func NewREADRequestInquiryBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READRequestInquiryBatchForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATERequestInquiryBatchForUserMonetaryAccountRequest calls the generic UPDATERequestInquiryBatchForUserMonetaryAccount builder with application/json body
func NewUPDATERequestInquiryBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryBatchForUserMonetaryAccountParams, body UPDATERequestInquiryBatchForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATERequestInquiryBatchForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATERequestInquiryBatchForUserMonetaryAccountRequestWithBody generates requests for UPDATERequestInquiryBatchForUserMonetaryAccount with any type of body
func NewUPDATERequestInquiryBatchForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryBatchForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatch
func NewListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, body CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, requestInquiryBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatch
func NewDELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest generates requests for READNoteAttachmentForUserMonetaryAccountRequestInquiryBatch
func NewREADNoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatch with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountRequestInquiryBatchRequest generates requests for ListAllNoteTextForUserMonetaryAccountRequestInquiryBatch
func NewListAllNoteTextForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *ListAllNoteTextForUserMonetaryAccountRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountRequestInquiryBatchRequest calls the generic CREATENoteTextForUserMonetaryAccountRequestInquiryBatch builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, body CREATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, requestInquiryBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountRequestInquiryBatchRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountRequestInquiryBatch with any type of body
func NewCREATENoteTextForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountRequestInquiryBatchRequest generates requests for DELETENoteTextForUserMonetaryAccountRequestInquiryBatch
func NewDELETENoteTextForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountRequestInquiryBatchRequest generates requests for READNoteTextForUserMonetaryAccountRequestInquiryBatch
func NewREADNoteTextForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountRequestInquiryBatchRequest calls the generic UPDATENoteTextForUserMonetaryAccountRequestInquiryBatch builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, body UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, requestInquiryBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountRequestInquiryBatchRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountRequestInquiryBatch with any type of body
func NewUPDATENoteTextForUserMonetaryAccountRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADRequestInquiryForUserMonetaryAccountRequest generates requests for READRequestInquiryForUserMonetaryAccount
func NewREADRequestInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READRequestInquiryForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATERequestInquiryForUserMonetaryAccountRequest calls the generic UPDATERequestInquiryForUserMonetaryAccount builder with application/json body
func NewUPDATERequestInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryForUserMonetaryAccountParams, body UPDATERequestInquiryForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATERequestInquiryForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATERequestInquiryForUserMonetaryAccountRequestWithBody generates requests for UPDATERequestInquiryForUserMonetaryAccount with any type of body
func NewUPDATERequestInquiryForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestInquiryForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountRequestInquiryRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountRequestInquiry
func NewListAllNoteAttachmentForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountRequestInquiry builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, body CREATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryRequestWithBody(server, userID, monetaryAccountID, requestInquiryID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountRequestInquiry with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountRequestInquiryRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountRequestInquiry
func NewDELETENoteAttachmentForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountRequestInquiryRequest generates requests for READNoteAttachmentForUserMonetaryAccountRequestInquiry
func NewREADNoteAttachmentForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountRequestInquiry builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryRequestWithBody(server, userID, monetaryAccountID, requestInquiryID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountRequestInquiry with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountRequestInquiryRequest generates requests for ListAllNoteTextForUserMonetaryAccountRequestInquiry
func NewListAllNoteTextForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, params *ListAllNoteTextForUserMonetaryAccountRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountRequestInquiryRequest calls the generic CREATENoteTextForUserMonetaryAccountRequestInquiry builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryParams, body CREATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountRequestInquiryRequestWithBody(server, userID, monetaryAccountID, requestInquiryID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountRequestInquiryRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountRequestInquiry with any type of body
func NewCREATENoteTextForUserMonetaryAccountRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryID int, params *CREATENoteTextForUserMonetaryAccountRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountRequestInquiryRequest generates requests for DELETENoteTextForUserMonetaryAccountRequestInquiry
func NewDELETENoteTextForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountRequestInquiryRequest generates requests for READNoteTextForUserMonetaryAccountRequestInquiry
func NewREADNoteTextForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountRequestInquiryRequest calls the generic UPDATENoteTextForUserMonetaryAccountRequestInquiry builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountRequestInquiryRequest(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryParams, body UPDATENoteTextForUserMonetaryAccountRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountRequestInquiryRequestWithBody(server, userID, monetaryAccountID, requestInquiryID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountRequestInquiryRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountRequestInquiry with any type of body
func NewUPDATENoteTextForUserMonetaryAccountRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, requestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-inquiry/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllRequestResponseForUserMonetaryAccountRequest generates requests for ListAllRequestResponseForUserMonetaryAccount
func NewListAllRequestResponseForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllRequestResponseForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADRequestResponseForUserMonetaryAccountRequest generates requests for READRequestResponseForUserMonetaryAccount
func NewREADRequestResponseForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READRequestResponseForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATERequestResponseForUserMonetaryAccountRequest calls the generic UPDATERequestResponseForUserMonetaryAccount builder with application/json body
func NewUPDATERequestResponseForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestResponseForUserMonetaryAccountParams, body UPDATERequestResponseForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATERequestResponseForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATERequestResponseForUserMonetaryAccountRequestWithBody generates requests for UPDATERequestResponseForUserMonetaryAccount with any type of body
func NewUPDATERequestResponseForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATERequestResponseForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountRequestResponseRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountRequestResponse
func NewListAllNoteAttachmentForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, params *ListAllNoteAttachmentForUserMonetaryAccountRequestResponseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountRequestResponseRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountRequestResponse builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestResponseParams, body CREATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountRequestResponseRequestWithBody(server, userID, monetaryAccountID, requestResponseID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountRequestResponseRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountRequestResponse with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountRequestResponseRequestWithBody(server string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteAttachmentForUserMonetaryAccountRequestResponseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountRequestResponseRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountRequestResponse
func NewDELETENoteAttachmentForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountRequestResponseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountRequestResponseRequest generates requests for READNoteAttachmentForUserMonetaryAccountRequestResponse
func NewREADNoteAttachmentForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountRequestResponseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountRequestResponseRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountRequestResponse builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestResponseParams, body UPDATENoteAttachmentForUserMonetaryAccountRequestResponseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountRequestResponseRequestWithBody(server, userID, monetaryAccountID, requestResponseID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountRequestResponseRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountRequestResponse with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountRequestResponseRequestWithBody(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountRequestResponseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountRequestResponseRequest generates requests for ListAllNoteTextForUserMonetaryAccountRequestResponse
func NewListAllNoteTextForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, params *ListAllNoteTextForUserMonetaryAccountRequestResponseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountRequestResponseRequest calls the generic CREATENoteTextForUserMonetaryAccountRequestResponse builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteTextForUserMonetaryAccountRequestResponseParams, body CREATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountRequestResponseRequestWithBody(server, userID, monetaryAccountID, requestResponseID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountRequestResponseRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountRequestResponse with any type of body
func NewCREATENoteTextForUserMonetaryAccountRequestResponseRequestWithBody(server string, userID int, monetaryAccountID int, requestResponseID int, params *CREATENoteTextForUserMonetaryAccountRequestResponseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountRequestResponseRequest generates requests for DELETENoteTextForUserMonetaryAccountRequestResponse
func NewDELETENoteTextForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *DELETENoteTextForUserMonetaryAccountRequestResponseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountRequestResponseRequest generates requests for READNoteTextForUserMonetaryAccountRequestResponse
func NewREADNoteTextForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *READNoteTextForUserMonetaryAccountRequestResponseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountRequestResponseRequest calls the generic UPDATENoteTextForUserMonetaryAccountRequestResponse builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountRequestResponseRequest(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestResponseParams, body UPDATENoteTextForUserMonetaryAccountRequestResponseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountRequestResponseRequestWithBody(server, userID, monetaryAccountID, requestResponseID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountRequestResponseRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountRequestResponse with any type of body
func NewUPDATENoteTextForUserMonetaryAccountRequestResponseRequestWithBody(server string, userID int, monetaryAccountID int, requestResponseID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountRequestResponseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(requestResponseID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/request-response/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllScheduleForUserMonetaryAccountRequest generates requests for ListAllScheduleForUserMonetaryAccount
func NewListAllScheduleForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllScheduleForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllSchedulePaymentForUserMonetaryAccountRequest generates requests for ListAllSchedulePaymentForUserMonetaryAccount
func NewListAllSchedulePaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllSchedulePaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATESchedulePaymentForUserMonetaryAccountRequest calls the generic CREATESchedulePaymentForUserMonetaryAccount builder with application/json body
func NewCREATESchedulePaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATESchedulePaymentForUserMonetaryAccountParams, body CREATESchedulePaymentForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATESchedulePaymentForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATESchedulePaymentForUserMonetaryAccountRequestWithBody generates requests for CREATESchedulePaymentForUserMonetaryAccount with any type of body
func NewCREATESchedulePaymentForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATESchedulePaymentForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATESchedulePaymentBatchForUserMonetaryAccountRequest calls the generic CREATESchedulePaymentBatchForUserMonetaryAccount builder with application/json body
func NewCREATESchedulePaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATESchedulePaymentBatchForUserMonetaryAccountParams, body CREATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATESchedulePaymentBatchForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATESchedulePaymentBatchForUserMonetaryAccountRequestWithBody generates requests for CREATESchedulePaymentBatchForUserMonetaryAccount with any type of body
func NewCREATESchedulePaymentBatchForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATESchedulePaymentBatchForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETESchedulePaymentBatchForUserMonetaryAccountRequest generates requests for DELETESchedulePaymentBatchForUserMonetaryAccount
func NewDELETESchedulePaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *DELETESchedulePaymentBatchForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADSchedulePaymentBatchForUserMonetaryAccountRequest generates requests for READSchedulePaymentBatchForUserMonetaryAccount
func NewREADSchedulePaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READSchedulePaymentBatchForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATESchedulePaymentBatchForUserMonetaryAccountRequest calls the generic UPDATESchedulePaymentBatchForUserMonetaryAccount builder with application/json body
func NewUPDATESchedulePaymentBatchForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentBatchForUserMonetaryAccountParams, body UPDATESchedulePaymentBatchForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATESchedulePaymentBatchForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATESchedulePaymentBatchForUserMonetaryAccountRequestWithBody generates requests for UPDATESchedulePaymentBatchForUserMonetaryAccount with any type of body
func NewUPDATESchedulePaymentBatchForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentBatchForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch
func NewListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, body CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server, userID, monetaryAccountID, schedulePaymentBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch
func NewDELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest generates requests for READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatch
func NewREADNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatch with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchRequest generates requests for ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatch
func NewListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *ListAllNoteTextForUserMonetaryAccountSchedulePaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest calls the generic CREATENoteTextForUserMonetaryAccountSchedulePaymentBatch builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, body CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server, userID, monetaryAccountID, schedulePaymentBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountSchedulePaymentBatch with any type of body
func NewCREATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest generates requests for DELETENoteTextForUserMonetaryAccountSchedulePaymentBatch
func NewDELETENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSchedulePaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountSchedulePaymentBatchRequest generates requests for READNoteTextForUserMonetaryAccountSchedulePaymentBatch
func NewREADNoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountSchedulePaymentBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest calls the generic UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatch builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequest(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, body UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server, userID, monetaryAccountID, schedulePaymentBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatch with any type of body
func NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETESchedulePaymentForUserMonetaryAccountRequest generates requests for DELETESchedulePaymentForUserMonetaryAccount
func NewDELETESchedulePaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *DELETESchedulePaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADSchedulePaymentForUserMonetaryAccountRequest generates requests for READSchedulePaymentForUserMonetaryAccount
func NewREADSchedulePaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READSchedulePaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATESchedulePaymentForUserMonetaryAccountRequest calls the generic UPDATESchedulePaymentForUserMonetaryAccount builder with application/json body
func NewUPDATESchedulePaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentForUserMonetaryAccountParams, body UPDATESchedulePaymentForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATESchedulePaymentForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATESchedulePaymentForUserMonetaryAccountRequestWithBody generates requests for UPDATESchedulePaymentForUserMonetaryAccount with any type of body
func NewUPDATESchedulePaymentForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATESchedulePaymentForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountSchedulePayment
func NewListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountSchedulePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountSchedulePayment builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, body CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequestWithBody(server, userID, monetaryAccountID, schedulePaymentID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountSchedulePayment with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountSchedulePayment
func NewDELETENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSchedulePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountSchedulePaymentRequest generates requests for READNoteAttachmentForUserMonetaryAccountSchedulePayment
func NewREADNoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSchedulePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountSchedulePayment builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequestWithBody(server, userID, monetaryAccountID, schedulePaymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountSchedulePayment with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSchedulePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountSchedulePaymentRequest generates requests for ListAllNoteTextForUserMonetaryAccountSchedulePayment
func NewListAllNoteTextForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, params *ListAllNoteTextForUserMonetaryAccountSchedulePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountSchedulePaymentRequest calls the generic CREATENoteTextForUserMonetaryAccountSchedulePayment builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentParams, body CREATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountSchedulePaymentRequestWithBody(server, userID, monetaryAccountID, schedulePaymentID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountSchedulePaymentRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountSchedulePayment with any type of body
func NewCREATENoteTextForUserMonetaryAccountSchedulePaymentRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentID int, params *CREATENoteTextForUserMonetaryAccountSchedulePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountSchedulePaymentRequest generates requests for DELETENoteTextForUserMonetaryAccountSchedulePayment
func NewDELETENoteTextForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSchedulePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountSchedulePaymentRequest generates requests for READNoteTextForUserMonetaryAccountSchedulePayment
func NewREADNoteTextForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountSchedulePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentRequest calls the generic UPDATENoteTextForUserMonetaryAccountSchedulePayment builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentRequest(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentParams, body UPDATENoteTextForUserMonetaryAccountSchedulePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentRequestWithBody(server, userID, monetaryAccountID, schedulePaymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountSchedulePayment with any type of body
func NewUPDATENoteTextForUserMonetaryAccountSchedulePaymentRequestWithBody(server string, userID int, monetaryAccountID int, schedulePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSchedulePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(schedulePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch
func NewListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch
func NewDELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest generates requests for READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch
func NewREADNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatch with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest generates requests for ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch
func NewListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest calls the generic CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, body CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch with any type of body
func NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest generates requests for DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch
func NewDELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest generates requests for READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatch
func NewREADNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest calls the generic UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, body UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryBatchID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatch with any type of body
func NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryBatchID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryBatchID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry-batch/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry
func NewListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry
func NewDELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest generates requests for READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiry
func NewREADNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiry with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryRequest generates requests for ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiry
func NewListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *ListAllNoteTextForUserMonetaryAccountScheduleRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest calls the generic CREATENoteTextForUserMonetaryAccountScheduleRequestInquiry builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, body CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountScheduleRequestInquiry with any type of body
func NewCREATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, params *CREATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest generates requests for DELETENoteTextForUserMonetaryAccountScheduleRequestInquiry
func NewDELETENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountScheduleRequestInquiryRequest generates requests for READNoteTextForUserMonetaryAccountScheduleRequestInquiry
func NewREADNoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleRequestInquiryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest calls the generic UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiry builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequest(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, body UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server, userID, monetaryAccountID, scheduleRequestInquiryID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiry with any type of body
func NewUPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryRequestWithBody(server string, userID int, monetaryAccountID int, scheduleRequestInquiryID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleRequestInquiryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleRequestInquiryID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule-request-inquiry/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADScheduleForUserMonetaryAccountRequest generates requests for READScheduleForUserMonetaryAccount
func NewREADScheduleForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READScheduleForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllScheduleInstanceForUserMonetaryAccountScheduleRequest generates requests for ListAllScheduleInstanceForUserMonetaryAccountSchedule
func NewListAllScheduleInstanceForUserMonetaryAccountScheduleRequest(server string, userID int, monetaryAccountID int, scheduleID int, params *ListAllScheduleInstanceForUserMonetaryAccountScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADScheduleInstanceForUserMonetaryAccountScheduleRequest generates requests for READScheduleInstanceForUserMonetaryAccountSchedule
func NewREADScheduleInstanceForUserMonetaryAccountScheduleRequest(server string, userID int, monetaryAccountID int, scheduleID int, itemId int, params *READScheduleInstanceForUserMonetaryAccountScheduleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEScheduleInstanceForUserMonetaryAccountScheduleRequest calls the generic UPDATEScheduleInstanceForUserMonetaryAccountSchedule builder with application/json body
func NewUPDATEScheduleInstanceForUserMonetaryAccountScheduleRequest(server string, userID int, monetaryAccountID int, scheduleID int, itemId int, params *UPDATEScheduleInstanceForUserMonetaryAccountScheduleParams, body UPDATEScheduleInstanceForUserMonetaryAccountScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEScheduleInstanceForUserMonetaryAccountScheduleRequestWithBody(server, userID, monetaryAccountID, scheduleID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEScheduleInstanceForUserMonetaryAccountScheduleRequestWithBody generates requests for UPDATEScheduleInstanceForUserMonetaryAccountSchedule with any type of body
func NewUPDATEScheduleInstanceForUserMonetaryAccountScheduleRequestWithBody(server string, userID int, monetaryAccountID int, scheduleID int, itemId int, params *UPDATEScheduleInstanceForUserMonetaryAccountScheduleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance
func NewListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *ListAllNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-attachment", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, body CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-attachment", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance
func NewDELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest generates requests for READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstance
func NewREADNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, body UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstance with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountScheduleScheduleInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest generates requests for ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstance
func NewListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *ListAllNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-text", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest calls the generic CREATENoteTextForUserMonetaryAccountScheduleScheduleInstance builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, body CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountScheduleScheduleInstance with any type of body
func NewCREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, params *CREATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-text", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest generates requests for DELETENoteTextForUserMonetaryAccountScheduleScheduleInstance
func NewDELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *DELETENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest generates requests for READNoteTextForUserMonetaryAccountScheduleScheduleInstance
func NewREADNoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *READNoteTextForUserMonetaryAccountScheduleScheduleInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest calls the generic UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstance builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequest(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, body UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server, userID, monetaryAccountID, scheduleID, scheduleInstanceID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstance with any type of body
func NewUPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceRequestWithBody(server string, userID int, monetaryAccountID int, scheduleID int, scheduleInstanceID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountScheduleScheduleInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(scheduleID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(scheduleInstanceID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/schedule/%s/schedule-instance/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest generates requests for ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccount
func NewListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/share-invite-monetary-account-inquiry", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest calls the generic CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount builder with application/json body
func NewCREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, body CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, params, "application/json", bodyReader)
}

// NewCREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequestWithBody generates requests for CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount with any type of body
func NewCREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, params *CREATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/share-invite-monetary-account-inquiry", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest generates requests for READShareInviteMonetaryAccountInquiryForUserMonetaryAccount
func NewREADShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/share-invite-monetary-account-inquiry/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest calls the generic UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount builder with application/json body
func NewUPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, body UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequestWithBody(server, userID, monetaryAccountID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequestWithBody generates requests for UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccount with any type of body
func NewUPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountRequestWithBody(server string, userID int, monetaryAccountID int, itemId int, params *UPDATEShareInviteMonetaryAccountInquiryForUserMonetaryAccountParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/share-invite-monetary-account-inquiry/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllSofortMerchantTransactionForUserMonetaryAccountRequest generates requests for ListAllSofortMerchantTransactionForUserMonetaryAccount
func NewListAllSofortMerchantTransactionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllSofortMerchantTransactionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADSofortMerchantTransactionForUserMonetaryAccountRequest generates requests for READSofortMerchantTransactionForUserMonetaryAccount
func NewREADSofortMerchantTransactionForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READSofortMerchantTransactionForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction
func NewListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *ListAllNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, body CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, sofortMerchantTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction
func NewDELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest generates requests for READNoteAttachmentForUserMonetaryAccountSofortMerchantTransaction
func NewREADNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, body UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransaction with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSofortMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionRequest generates requests for ListAllNoteTextForUserMonetaryAccountSofortMerchantTransaction
func NewListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *ListAllNoteTextForUserMonetaryAccountSofortMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest calls the generic CREATENoteTextForUserMonetaryAccountSofortMerchantTransaction builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, body CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, sofortMerchantTransactionID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountSofortMerchantTransaction with any type of body
func NewCREATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, params *CREATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest generates requests for DELETENoteTextForUserMonetaryAccountSofortMerchantTransaction
func NewDELETENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSofortMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountSofortMerchantTransactionRequest generates requests for READNoteTextForUserMonetaryAccountSofortMerchantTransaction
func NewREADNoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *READNoteTextForUserMonetaryAccountSofortMerchantTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest calls the generic UPDATENoteTextForUserMonetaryAccountSofortMerchantTransaction builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequest(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, body UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server, userID, monetaryAccountID, sofortMerchantTransactionID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountSofortMerchantTransaction with any type of body
func NewUPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionRequestWithBody(server string, userID int, monetaryAccountID int, sofortMerchantTransactionID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSofortMerchantTransactionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(sofortMerchantTransactionID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/sofort-merchant-transaction/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADSwitchServicePaymentForUserMonetaryAccountRequest generates requests for READSwitchServicePaymentForUserMonetaryAccount
func NewREADSwitchServicePaymentForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READSwitchServicePaymentForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePayment
func NewListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, params *ListAllNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountSwitchServicePayment builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, body CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server, userID, monetaryAccountID, switchServicePaymentID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountSwitchServicePayment with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-attachment", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountSwitchServicePayment
func NewDELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest generates requests for READNoteAttachmentForUserMonetaryAccountSwitchServicePayment
func NewREADNoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePayment builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, body UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server, userID, monetaryAccountID, switchServicePaymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePayment with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountSwitchServicePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountSwitchServicePaymentRequest generates requests for ListAllNoteTextForUserMonetaryAccountSwitchServicePayment
func NewListAllNoteTextForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, params *ListAllNoteTextForUserMonetaryAccountSwitchServicePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountSwitchServicePaymentRequest calls the generic CREATENoteTextForUserMonetaryAccountSwitchServicePayment builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, body CREATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server, userID, monetaryAccountID, switchServicePaymentID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountSwitchServicePaymentRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountSwitchServicePayment with any type of body
func NewCREATENoteTextForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server string, userID int, monetaryAccountID int, switchServicePaymentID int, params *CREATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-text", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountSwitchServicePaymentRequest generates requests for DELETENoteTextForUserMonetaryAccountSwitchServicePayment
func NewDELETENoteTextForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *DELETENoteTextForUserMonetaryAccountSwitchServicePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountSwitchServicePaymentRequest generates requests for READNoteTextForUserMonetaryAccountSwitchServicePayment
func NewREADNoteTextForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *READNoteTextForUserMonetaryAccountSwitchServicePaymentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountSwitchServicePaymentRequest calls the generic UPDATENoteTextForUserMonetaryAccountSwitchServicePayment builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountSwitchServicePaymentRequest(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, body UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server, userID, monetaryAccountID, switchServicePaymentID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountSwitchServicePaymentRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountSwitchServicePayment with any type of body
func NewUPDATENoteTextForUserMonetaryAccountSwitchServicePaymentRequestWithBody(server string, userID int, monetaryAccountID int, switchServicePaymentID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountSwitchServicePaymentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(switchServicePaymentID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/switch-service-payment/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllWhitelistSddForUserMonetaryAccountRequest generates requests for ListAllWhitelistSddForUserMonetaryAccount
func NewListAllWhitelistSddForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, params *ListAllWhitelistSddForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist-sdd", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADWhitelistSddForUserMonetaryAccountRequest generates requests for READWhitelistSddForUserMonetaryAccount
func NewREADWhitelistSddForUserMonetaryAccountRequest(server string, userID int, monetaryAccountID int, itemId int, params *READWhitelistSddForUserMonetaryAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist-sdd/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest generates requests for ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult
func NewListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *ListAllNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-attachment", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest calls the generic CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult builder with application/json body
func NewCREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, body CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server, userID, monetaryAccountID, whitelistID, whitelistResultID, params, "application/json", bodyReader)
}

// NewCREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody generates requests for CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult with any type of body
func NewCREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-attachment", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest generates requests for DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult
func NewDELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *DELETENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest generates requests for READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult
func NewREADNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *READNoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest calls the generic UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult builder with application/json body
func NewUPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, body UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody generates requests for UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResult with any type of body
func NewUPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteAttachmentForUserMonetaryAccountWhitelistWhitelistResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-attachment/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest generates requests for ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResult
func NewListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *ListAllNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-text", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest calls the generic CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResult builder with application/json body
func NewCREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, body CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server, userID, monetaryAccountID, whitelistID, whitelistResultID, params, "application/json", bodyReader)
}

// NewCREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody generates requests for CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResult with any type of body
func NewCREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, params *CREATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-text", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest generates requests for DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResult
func NewDELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *DELETENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADNoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest generates requests for READNoteTextForUserMonetaryAccountWhitelistWhitelistResult
func NewREADNoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *READNoteTextForUserMonetaryAccountWhitelistWhitelistResultParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest calls the generic UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResult builder with application/json body
func NewUPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequest(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, body UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server, userID, monetaryAccountID, whitelistID, whitelistResultID, itemId, params, "application/json", bodyReader)
}

// NewUPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody generates requests for UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResult with any type of body
func NewUPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultRequestWithBody(server string, userID int, monetaryAccountID int, whitelistID int, whitelistResultID int, itemId int, params *UPDATENoteTextForUserMonetaryAccountWhitelistWhitelistResultParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(monetaryAccountID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(whitelistID)

	var pathParam3 string

	pathParam3 = strconv.Itoa(whitelistResultID)

	var pathParam4 string

	pathParam4 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/monetary-account/%s/whitelist/%s/whitelist-result/%s/note-text/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNotificationFilterEmailForUserRequest generates requests for ListAllNotificationFilterEmailForUser
func NewListAllNotificationFilterEmailForUserRequest(server string, userID int, params *ListAllNotificationFilterEmailForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENotificationFilterEmailForUserRequest calls the generic CREATENotificationFilterEmailForUser builder with application/json body
func NewCREATENotificationFilterEmailForUserRequest(server string, userID int, params *CREATENotificationFilterEmailForUserParams, body CREATENotificationFilterEmailForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENotificationFilterEmailForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATENotificationFilterEmailForUserRequestWithBody generates requests for CREATENotificationFilterEmailForUser with any type of body
func NewCREATENotificationFilterEmailForUserRequestWithBody(server string, userID int, params *CREATENotificationFilterEmailForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNotificationFilterFailureForUserRequest generates requests for ListAllNotificationFilterFailureForUser
func NewListAllNotificationFilterFailureForUserRequest(server string, userID int, params *ListAllNotificationFilterFailureForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-failure", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENotificationFilterFailureForUserRequest calls the generic CREATENotificationFilterFailureForUser builder with application/json body
func NewCREATENotificationFilterFailureForUserRequest(server string, userID int, params *CREATENotificationFilterFailureForUserParams, body CREATENotificationFilterFailureForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENotificationFilterFailureForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATENotificationFilterFailureForUserRequestWithBody generates requests for CREATENotificationFilterFailureForUser with any type of body
func NewCREATENotificationFilterFailureForUserRequestWithBody(server string, userID int, params *CREATENotificationFilterFailureForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-failure", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNotificationFilterPushForUserRequest generates requests for ListAllNotificationFilterPushForUser
func NewListAllNotificationFilterPushForUserRequest(server string, userID int, params *ListAllNotificationFilterPushForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-push", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENotificationFilterPushForUserRequest calls the generic CREATENotificationFilterPushForUser builder with application/json body
func NewCREATENotificationFilterPushForUserRequest(server string, userID int, params *CREATENotificationFilterPushForUserParams, body CREATENotificationFilterPushForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENotificationFilterPushForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATENotificationFilterPushForUserRequestWithBody generates requests for CREATENotificationFilterPushForUser with any type of body
func NewCREATENotificationFilterPushForUserRequestWithBody(server string, userID int, params *CREATENotificationFilterPushForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-push", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllNotificationFilterUrlForUserRequest generates requests for ListAllNotificationFilterUrlForUser
func NewListAllNotificationFilterUrlForUserRequest(server string, userID int, params *ListAllNotificationFilterUrlForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-url", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATENotificationFilterUrlForUserRequest calls the generic CREATENotificationFilterUrlForUser builder with application/json body
func NewCREATENotificationFilterUrlForUserRequest(server string, userID int, params *CREATENotificationFilterUrlForUserParams, body CREATENotificationFilterUrlForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATENotificationFilterUrlForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATENotificationFilterUrlForUserRequestWithBody generates requests for CREATENotificationFilterUrlForUser with any type of body
func NewCREATENotificationFilterUrlForUserRequestWithBody(server string, userID int, params *CREATENotificationFilterUrlForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/notification-filter-url", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllOauthClientForUserRequest generates requests for ListAllOauthClientForUser
func NewListAllOauthClientForUserRequest(server string, userID int, params *ListAllOauthClientForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEOauthClientForUserRequest calls the generic CREATEOauthClientForUser builder with application/json body
func NewCREATEOauthClientForUserRequest(server string, userID int, params *CREATEOauthClientForUserParams, body CREATEOauthClientForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEOauthClientForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEOauthClientForUserRequestWithBody generates requests for CREATEOauthClientForUser with any type of body
func NewCREATEOauthClientForUserRequestWithBody(server string, userID int, params *CREATEOauthClientForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADOauthClientForUserRequest generates requests for READOauthClientForUser
func NewREADOauthClientForUserRequest(server string, userID int, itemId int, params *READOauthClientForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEOauthClientForUserRequest calls the generic UPDATEOauthClientForUser builder with application/json body
func NewUPDATEOauthClientForUserRequest(server string, userID int, itemId int, params *UPDATEOauthClientForUserParams, body UPDATEOauthClientForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEOauthClientForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEOauthClientForUserRequestWithBody generates requests for UPDATEOauthClientForUser with any type of body
func NewUPDATEOauthClientForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEOauthClientForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllCallbackUrlForUserOauthClientRequest generates requests for ListAllCallbackUrlForUserOauthClient
func NewListAllCallbackUrlForUserOauthClientRequest(server string, userID int, oauthClientID int, params *ListAllCallbackUrlForUserOauthClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(oauthClientID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client/%s/callback-url", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATECallbackUrlForUserOauthClientRequest calls the generic CREATECallbackUrlForUserOauthClient builder with application/json body
func NewCREATECallbackUrlForUserOauthClientRequest(server string, userID int, oauthClientID int, params *CREATECallbackUrlForUserOauthClientParams, body CREATECallbackUrlForUserOauthClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATECallbackUrlForUserOauthClientRequestWithBody(server, userID, oauthClientID, params, "application/json", bodyReader)
}

// NewCREATECallbackUrlForUserOauthClientRequestWithBody generates requests for CREATECallbackUrlForUserOauthClient with any type of body
func NewCREATECallbackUrlForUserOauthClientRequestWithBody(server string, userID int, oauthClientID int, params *CREATECallbackUrlForUserOauthClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(oauthClientID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client/%s/callback-url", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETECallbackUrlForUserOauthClientRequest generates requests for DELETECallbackUrlForUserOauthClient
func NewDELETECallbackUrlForUserOauthClientRequest(server string, userID int, oauthClientID int, itemId int, params *DELETECallbackUrlForUserOauthClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(oauthClientID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client/%s/callback-url/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADCallbackUrlForUserOauthClientRequest generates requests for READCallbackUrlForUserOauthClient
func NewREADCallbackUrlForUserOauthClientRequest(server string, userID int, oauthClientID int, itemId int, params *READCallbackUrlForUserOauthClientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(oauthClientID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client/%s/callback-url/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATECallbackUrlForUserOauthClientRequest calls the generic UPDATECallbackUrlForUserOauthClient builder with application/json body
func NewUPDATECallbackUrlForUserOauthClientRequest(server string, userID int, oauthClientID int, itemId int, params *UPDATECallbackUrlForUserOauthClientParams, body UPDATECallbackUrlForUserOauthClientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATECallbackUrlForUserOauthClientRequestWithBody(server, userID, oauthClientID, itemId, params, "application/json", bodyReader)
}

// NewUPDATECallbackUrlForUserOauthClientRequestWithBody generates requests for UPDATECallbackUrlForUserOauthClient with any type of body
func NewUPDATECallbackUrlForUserOauthClientRequestWithBody(server string, userID int, oauthClientID int, itemId int, params *UPDATECallbackUrlForUserOauthClientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(oauthClientID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/oauth-client/%s/callback-url/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllPaymentAutoAllocateForUserRequest generates requests for ListAllPaymentAutoAllocateForUser
func NewListAllPaymentAutoAllocateForUserRequest(server string, userID int, params *ListAllPaymentAutoAllocateForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-auto-allocate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllPaymentServiceProviderDraftPaymentForUserRequest generates requests for ListAllPaymentServiceProviderDraftPaymentForUser
func NewListAllPaymentServiceProviderDraftPaymentForUserRequest(server string, userID int, params *ListAllPaymentServiceProviderDraftPaymentForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-draft-payment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEPaymentServiceProviderDraftPaymentForUserRequest calls the generic CREATEPaymentServiceProviderDraftPaymentForUser builder with application/json body
func NewCREATEPaymentServiceProviderDraftPaymentForUserRequest(server string, userID int, params *CREATEPaymentServiceProviderDraftPaymentForUserParams, body CREATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEPaymentServiceProviderDraftPaymentForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEPaymentServiceProviderDraftPaymentForUserRequestWithBody generates requests for CREATEPaymentServiceProviderDraftPaymentForUser with any type of body
func NewCREATEPaymentServiceProviderDraftPaymentForUserRequestWithBody(server string, userID int, params *CREATEPaymentServiceProviderDraftPaymentForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-draft-payment", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADPaymentServiceProviderDraftPaymentForUserRequest generates requests for READPaymentServiceProviderDraftPaymentForUser
func NewREADPaymentServiceProviderDraftPaymentForUserRequest(server string, userID int, itemId int, params *READPaymentServiceProviderDraftPaymentForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-draft-payment/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEPaymentServiceProviderDraftPaymentForUserRequest calls the generic UPDATEPaymentServiceProviderDraftPaymentForUser builder with application/json body
func NewUPDATEPaymentServiceProviderDraftPaymentForUserRequest(server string, userID int, itemId int, params *UPDATEPaymentServiceProviderDraftPaymentForUserParams, body UPDATEPaymentServiceProviderDraftPaymentForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEPaymentServiceProviderDraftPaymentForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEPaymentServiceProviderDraftPaymentForUserRequestWithBody generates requests for UPDATEPaymentServiceProviderDraftPaymentForUser with any type of body
func NewUPDATEPaymentServiceProviderDraftPaymentForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEPaymentServiceProviderDraftPaymentForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-draft-payment/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllPaymentServiceProviderIssuerTransactionForUserRequest generates requests for ListAllPaymentServiceProviderIssuerTransactionForUser
func NewListAllPaymentServiceProviderIssuerTransactionForUserRequest(server string, userID int, params *ListAllPaymentServiceProviderIssuerTransactionForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-issuer-transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEPaymentServiceProviderIssuerTransactionForUserRequest calls the generic CREATEPaymentServiceProviderIssuerTransactionForUser builder with application/json body
func NewCREATEPaymentServiceProviderIssuerTransactionForUserRequest(server string, userID int, params *CREATEPaymentServiceProviderIssuerTransactionForUserParams, body CREATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEPaymentServiceProviderIssuerTransactionForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEPaymentServiceProviderIssuerTransactionForUserRequestWithBody generates requests for CREATEPaymentServiceProviderIssuerTransactionForUser with any type of body
func NewCREATEPaymentServiceProviderIssuerTransactionForUserRequestWithBody(server string, userID int, params *CREATEPaymentServiceProviderIssuerTransactionForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-issuer-transaction", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADPaymentServiceProviderIssuerTransactionForUserRequest generates requests for READPaymentServiceProviderIssuerTransactionForUser
func NewREADPaymentServiceProviderIssuerTransactionForUserRequest(server string, userID int, itemId int, params *READPaymentServiceProviderIssuerTransactionForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-issuer-transaction/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEPaymentServiceProviderIssuerTransactionForUserRequest calls the generic UPDATEPaymentServiceProviderIssuerTransactionForUser builder with application/json body
func NewUPDATEPaymentServiceProviderIssuerTransactionForUserRequest(server string, userID int, itemId int, params *UPDATEPaymentServiceProviderIssuerTransactionForUserParams, body UPDATEPaymentServiceProviderIssuerTransactionForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEPaymentServiceProviderIssuerTransactionForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEPaymentServiceProviderIssuerTransactionForUserRequestWithBody generates requests for UPDATEPaymentServiceProviderIssuerTransactionForUser with any type of body
func NewUPDATEPaymentServiceProviderIssuerTransactionForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEPaymentServiceProviderIssuerTransactionForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/payment-service-provider-issuer-transaction/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllScheduleForUserRequest generates requests for ListAllScheduleForUser
func NewListAllScheduleForUserRequest(server string, userID int, params *ListAllScheduleForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/schedule", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllShareInviteMonetaryAccountResponseForUserRequest generates requests for ListAllShareInviteMonetaryAccountResponseForUser
func NewListAllShareInviteMonetaryAccountResponseForUserRequest(server string, userID int, params *ListAllShareInviteMonetaryAccountResponseForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/share-invite-monetary-account-response", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADShareInviteMonetaryAccountResponseForUserRequest generates requests for READShareInviteMonetaryAccountResponseForUser
func NewREADShareInviteMonetaryAccountResponseForUserRequest(server string, userID int, itemId int, params *READShareInviteMonetaryAccountResponseForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/share-invite-monetary-account-response/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEShareInviteMonetaryAccountResponseForUserRequest calls the generic UPDATEShareInviteMonetaryAccountResponseForUser builder with application/json body
func NewUPDATEShareInviteMonetaryAccountResponseForUserRequest(server string, userID int, itemId int, params *UPDATEShareInviteMonetaryAccountResponseForUserParams, body UPDATEShareInviteMonetaryAccountResponseForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEShareInviteMonetaryAccountResponseForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEShareInviteMonetaryAccountResponseForUserRequestWithBody generates requests for UPDATEShareInviteMonetaryAccountResponseForUser with any type of body
func NewUPDATEShareInviteMonetaryAccountResponseForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEShareInviteMonetaryAccountResponseForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/share-invite-monetary-account-response/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATETokenQrRequestIdealForUserRequest calls the generic CREATETokenQrRequestIdealForUser builder with application/json body
func NewCREATETokenQrRequestIdealForUserRequest(server string, userID int, params *CREATETokenQrRequestIdealForUserParams, body CREATETokenQrRequestIdealForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETokenQrRequestIdealForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATETokenQrRequestIdealForUserRequestWithBody generates requests for CREATETokenQrRequestIdealForUser with any type of body
func NewCREATETokenQrRequestIdealForUserRequestWithBody(server string, userID int, params *CREATETokenQrRequestIdealForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/token-qr-request-ideal", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATETokenQrRequestSofortForUserRequest calls the generic CREATETokenQrRequestSofortForUser builder with application/json body
func NewCREATETokenQrRequestSofortForUserRequest(server string, userID int, params *CREATETokenQrRequestSofortForUserParams, body CREATETokenQrRequestSofortForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETokenQrRequestSofortForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATETokenQrRequestSofortForUserRequestWithBody generates requests for CREATETokenQrRequestSofortForUser with any type of body
func NewCREATETokenQrRequestSofortForUserRequestWithBody(server string, userID int, params *CREATETokenQrRequestSofortForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/token-qr-request-sofort", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllTransferwiseCurrencyForUserRequest generates requests for ListAllTransferwiseCurrencyForUser
func NewListAllTransferwiseCurrencyForUserRequest(server string, userID int, params *ListAllTransferwiseCurrencyForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-currency", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATETransferwiseQuoteForUserRequest calls the generic CREATETransferwiseQuoteForUser builder with application/json body
func NewCREATETransferwiseQuoteForUserRequest(server string, userID int, params *CREATETransferwiseQuoteForUserParams, body CREATETransferwiseQuoteForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETransferwiseQuoteForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATETransferwiseQuoteForUserRequestWithBody generates requests for CREATETransferwiseQuoteForUser with any type of body
func NewCREATETransferwiseQuoteForUserRequestWithBody(server string, userID int, params *CREATETransferwiseQuoteForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATETransferwiseQuoteTemporaryForUserRequest calls the generic CREATETransferwiseQuoteTemporaryForUser builder with application/json body
func NewCREATETransferwiseQuoteTemporaryForUserRequest(server string, userID int, params *CREATETransferwiseQuoteTemporaryForUserParams, body CREATETransferwiseQuoteTemporaryForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETransferwiseQuoteTemporaryForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATETransferwiseQuoteTemporaryForUserRequestWithBody generates requests for CREATETransferwiseQuoteTemporaryForUser with any type of body
func NewCREATETransferwiseQuoteTemporaryForUserRequestWithBody(server string, userID int, params *CREATETransferwiseQuoteTemporaryForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote-temporary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADTransferwiseQuoteTemporaryForUserRequest generates requests for READTransferwiseQuoteTemporaryForUser
func NewREADTransferwiseQuoteTemporaryForUserRequest(server string, userID int, itemId int, params *READTransferwiseQuoteTemporaryForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote-temporary/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADTransferwiseQuoteForUserRequest generates requests for READTransferwiseQuoteForUser
func NewREADTransferwiseQuoteForUserRequest(server string, userID int, itemId int, params *READTransferwiseQuoteForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllTransferwiseRecipientForUserTransferwiseQuoteRequest generates requests for ListAllTransferwiseRecipientForUserTransferwiseQuote
func NewListAllTransferwiseRecipientForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseRecipientForUserTransferwiseQuoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-recipient", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATETransferwiseRecipientForUserTransferwiseQuoteRequest calls the generic CREATETransferwiseRecipientForUserTransferwiseQuote builder with application/json body
func NewCREATETransferwiseRecipientForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientForUserTransferwiseQuoteParams, body CREATETransferwiseRecipientForUserTransferwiseQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETransferwiseRecipientForUserTransferwiseQuoteRequestWithBody(server, userID, transferwiseQuoteID, params, "application/json", bodyReader)
}

// NewCREATETransferwiseRecipientForUserTransferwiseQuoteRequestWithBody generates requests for CREATETransferwiseRecipientForUserTransferwiseQuote with any type of body
func NewCREATETransferwiseRecipientForUserTransferwiseQuoteRequestWithBody(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientForUserTransferwiseQuoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-recipient", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteRequest generates requests for ListAllTransferwiseRecipientRequirementForUserTransferwiseQuote
func NewListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseRecipientRequirementForUserTransferwiseQuoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-recipient-requirement", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATETransferwiseRecipientRequirementForUserTransferwiseQuoteRequest calls the generic CREATETransferwiseRecipientRequirementForUserTransferwiseQuote builder with application/json body
func NewCREATETransferwiseRecipientRequirementForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteParams, body CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETransferwiseRecipientRequirementForUserTransferwiseQuoteRequestWithBody(server, userID, transferwiseQuoteID, params, "application/json", bodyReader)
}

// NewCREATETransferwiseRecipientRequirementForUserTransferwiseQuoteRequestWithBody generates requests for CREATETransferwiseRecipientRequirementForUserTransferwiseQuote with any type of body
func NewCREATETransferwiseRecipientRequirementForUserTransferwiseQuoteRequestWithBody(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseRecipientRequirementForUserTransferwiseQuoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-recipient-requirement", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETETransferwiseRecipientForUserTransferwiseQuoteRequest generates requests for DELETETransferwiseRecipientForUserTransferwiseQuote
func NewDELETETransferwiseRecipientForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, itemId int, params *DELETETransferwiseRecipientForUserTransferwiseQuoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-recipient/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADTransferwiseRecipientForUserTransferwiseQuoteRequest generates requests for READTransferwiseRecipientForUserTransferwiseQuote
func NewREADTransferwiseRecipientForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, itemId int, params *READTransferwiseRecipientForUserTransferwiseQuoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-recipient/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllTransferwiseTransferForUserTransferwiseQuoteRequest generates requests for ListAllTransferwiseTransferForUserTransferwiseQuote
func NewListAllTransferwiseTransferForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, params *ListAllTransferwiseTransferForUserTransferwiseQuoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-transfer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATETransferwiseTransferForUserTransferwiseQuoteRequest calls the generic CREATETransferwiseTransferForUserTransferwiseQuote builder with application/json body
func NewCREATETransferwiseTransferForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferForUserTransferwiseQuoteParams, body CREATETransferwiseTransferForUserTransferwiseQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETransferwiseTransferForUserTransferwiseQuoteRequestWithBody(server, userID, transferwiseQuoteID, params, "application/json", bodyReader)
}

// NewCREATETransferwiseTransferForUserTransferwiseQuoteRequestWithBody generates requests for CREATETransferwiseTransferForUserTransferwiseQuote with any type of body
func NewCREATETransferwiseTransferForUserTransferwiseQuoteRequestWithBody(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferForUserTransferwiseQuoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-transfer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCREATETransferwiseTransferRequirementForUserTransferwiseQuoteRequest calls the generic CREATETransferwiseTransferRequirementForUserTransferwiseQuote builder with application/json body
func NewCREATETransferwiseTransferRequirementForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferRequirementForUserTransferwiseQuoteParams, body CREATETransferwiseTransferRequirementForUserTransferwiseQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETransferwiseTransferRequirementForUserTransferwiseQuoteRequestWithBody(server, userID, transferwiseQuoteID, params, "application/json", bodyReader)
}

// NewCREATETransferwiseTransferRequirementForUserTransferwiseQuoteRequestWithBody generates requests for CREATETransferwiseTransferRequirementForUserTransferwiseQuote with any type of body
func NewCREATETransferwiseTransferRequirementForUserTransferwiseQuoteRequestWithBody(server string, userID int, transferwiseQuoteID int, params *CREATETransferwiseTransferRequirementForUserTransferwiseQuoteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-transfer-requirement", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADTransferwiseTransferForUserTransferwiseQuoteRequest generates requests for READTransferwiseTransferForUserTransferwiseQuote
func NewREADTransferwiseTransferForUserTransferwiseQuoteRequest(server string, userID int, transferwiseQuoteID int, itemId int, params *READTransferwiseTransferForUserTransferwiseQuoteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(transferwiseQuoteID)

	var pathParam2 string

	pathParam2 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-quote/%s/transferwise-transfer/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllTransferwiseUserForUserRequest generates requests for ListAllTransferwiseUserForUser
func NewListAllTransferwiseUserForUserRequest(server string, userID int, params *ListAllTransferwiseUserForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATETransferwiseUserForUserRequest calls the generic CREATETransferwiseUserForUser builder with application/json body
func NewCREATETransferwiseUserForUserRequest(server string, userID int, params *CREATETransferwiseUserForUserParams, body CREATETransferwiseUserForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATETransferwiseUserForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATETransferwiseUserForUserRequestWithBody generates requests for CREATETransferwiseUserForUser with any type of body
func NewCREATETransferwiseUserForUserRequestWithBody(server string, userID int, params *CREATETransferwiseUserForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/transferwise-user", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllTreeProgressForUserRequest generates requests for ListAllTreeProgressForUser
func NewListAllTreeProgressForUserRequest(server string, userID int, params *ListAllTreeProgressForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/tree-progress", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllWhitelistSddForUserRequest generates requests for ListAllWhitelistSddForUser
func NewListAllWhitelistSddForUserRequest(server string, userID int, params *ListAllWhitelistSddForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAllWhitelistSddOneOffForUserRequest generates requests for ListAllWhitelistSddOneOffForUser
func NewListAllWhitelistSddOneOffForUserRequest(server string, userID int, params *ListAllWhitelistSddOneOffForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-one-off", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEWhitelistSddOneOffForUserRequest calls the generic CREATEWhitelistSddOneOffForUser builder with application/json body
func NewCREATEWhitelistSddOneOffForUserRequest(server string, userID int, params *CREATEWhitelistSddOneOffForUserParams, body CREATEWhitelistSddOneOffForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEWhitelistSddOneOffForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEWhitelistSddOneOffForUserRequestWithBody generates requests for CREATEWhitelistSddOneOffForUser with any type of body
func NewCREATEWhitelistSddOneOffForUserRequestWithBody(server string, userID int, params *CREATEWhitelistSddOneOffForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-one-off", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETEWhitelistSddOneOffForUserRequest generates requests for DELETEWhitelistSddOneOffForUser
func NewDELETEWhitelistSddOneOffForUserRequest(server string, userID int, itemId int, params *DELETEWhitelistSddOneOffForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-one-off/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADWhitelistSddOneOffForUserRequest generates requests for READWhitelistSddOneOffForUser
func NewREADWhitelistSddOneOffForUserRequest(server string, userID int, itemId int, params *READWhitelistSddOneOffForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-one-off/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEWhitelistSddOneOffForUserRequest calls the generic UPDATEWhitelistSddOneOffForUser builder with application/json body
func NewUPDATEWhitelistSddOneOffForUserRequest(server string, userID int, itemId int, params *UPDATEWhitelistSddOneOffForUserParams, body UPDATEWhitelistSddOneOffForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEWhitelistSddOneOffForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEWhitelistSddOneOffForUserRequestWithBody generates requests for UPDATEWhitelistSddOneOffForUser with any type of body
func NewUPDATEWhitelistSddOneOffForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEWhitelistSddOneOffForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-one-off/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAllWhitelistSddRecurringForUserRequest generates requests for ListAllWhitelistSddRecurringForUser
func NewListAllWhitelistSddRecurringForUserRequest(server string, userID int, params *ListAllWhitelistSddRecurringForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-recurring", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCREATEWhitelistSddRecurringForUserRequest calls the generic CREATEWhitelistSddRecurringForUser builder with application/json body
func NewCREATEWhitelistSddRecurringForUserRequest(server string, userID int, params *CREATEWhitelistSddRecurringForUserParams, body CREATEWhitelistSddRecurringForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCREATEWhitelistSddRecurringForUserRequestWithBody(server, userID, params, "application/json", bodyReader)
}

// NewCREATEWhitelistSddRecurringForUserRequestWithBody generates requests for CREATEWhitelistSddRecurringForUser with any type of body
func NewCREATEWhitelistSddRecurringForUserRequestWithBody(server string, userID int, params *CREATEWhitelistSddRecurringForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-recurring", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDELETEWhitelistSddRecurringForUserRequest generates requests for DELETEWhitelistSddRecurringForUser
func NewDELETEWhitelistSddRecurringForUserRequest(server string, userID int, itemId int, params *DELETEWhitelistSddRecurringForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-recurring/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewREADWhitelistSddRecurringForUserRequest generates requests for READWhitelistSddRecurringForUser
func NewREADWhitelistSddRecurringForUserRequest(server string, userID int, itemId int, params *READWhitelistSddRecurringForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-recurring/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUPDATEWhitelistSddRecurringForUserRequest calls the generic UPDATEWhitelistSddRecurringForUser builder with application/json body
func NewUPDATEWhitelistSddRecurringForUserRequest(server string, userID int, itemId int, params *UPDATEWhitelistSddRecurringForUserParams, body UPDATEWhitelistSddRecurringForUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUPDATEWhitelistSddRecurringForUserRequestWithBody(server, userID, itemId, params, "application/json", bodyReader)
}

// NewUPDATEWhitelistSddRecurringForUserRequestWithBody generates requests for UPDATEWhitelistSddRecurringForUser with any type of body
func NewUPDATEWhitelistSddRecurringForUserRequestWithBody(server string, userID int, itemId int, params *UPDATEWhitelistSddRecurringForUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd-recurring/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewREADWhitelistSddForUserRequest generates requests for READWhitelistSddForUser
func NewREADWhitelistSddForUserRequest(server string, userID int, itemId int, params *READWhitelistSddForUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0 = strconv.Itoa(userID)

	var pathParam1 string

	pathParam1 = strconv.Itoa(itemId)

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/whitelist-sdd/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// not generating client-with-responses
